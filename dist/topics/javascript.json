{
  "slug": "javascript",
  "repo": "Laboratoria/curriculum",
  "path": "topics/javascript",
  "version": "8.2.0",
  "parserVersion": "5.3.0",
  "createdAt": "2024-02-08T16:56:33.613Z",
  "track": "web-dev",
  "tracks": [
    "web-dev"
  ],
  "intl": {
    "es": {
      "title": "JavaScript",
      "summary": "<p>JavaScript, comúnmente abreviado JS, es  un lenguaje de programación\nque forma parte de las tecnologías centrales del desarrollo web,\njunto con HTML y CSS. Actualmente, la inmensa mayoría de los sitios\nwebs utilizan JavaScript en el lado del <em>cliente</em> para controlar el\ncomportamiento y agregarle funcionalidad a ellos, usualmente\nincorporando librerías de terceros.</p>\n<p>Originalmente, los motores que interpretaban JavaScript fueron\ndiseñados y utilizados para los navegadores web, sin embargo,\nhoy en día existen motores de ejecución de JS nativos para\nlos sistemas operativos, expandiendo el uso de JS hacia <em>servidores</em>\ny una gran variedad de aplicaciones de escritorio.</p>"
    },
    "pt": {
      "title": "JavaScript",
      "summary": "<p>En un mundo que rápidamente se está digitalizando, aprender a programar abre\nnuevas (y muchas veces mejores) oportunidades. Con este curso darás tus primeros\npasos hacia el mundo de la programación. Empezaremos desde cero, enseñándote los\nfundamentos de JavaScript, el lenguaje de programación más popular de la Web.</p>\n<p>En este curso aprenderás mejores formas de estructurar y manipular la data de tu\nprograma haciendo uso de estructuras de datos básicas: <code>arreglos</code> y <code>objetos</code>.</p>"
    }
  },
  "cover": null,
  "thumb": "data:image/png;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gOTAK/9sAQwADAgIDAgIDAwMDBAMDBAUIBQUEBAUKBwcGCAwKDAwLCgsLDQ4SEA0OEQ4LCxAWEBETFBUVFQwPFxgWFBgSFBUU/9sAQwEDBAQFBAUJBQUJFA0LDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU/8AAEQgAyAGQAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+1aKKK/zyP0sKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPjn9qH9v+6/Z1+Kk3g+HwTDryR2kN19sfUzAT5gJ27RE3THXNeSf8PdL/8A6Jhbf+Dtv/jFeSf8FNf+Torv/sE2f8mr5Rr+ruH+C8hxuU4XE18MpTnCLb5p6trXaVj4/E47EU604xlon2X+R+tX7K/7e91+0h8UG8IzeCodAQWE179rTUjcH5Cg27TEvXd1z2r7Ar8j/wDgl7/yc0//AGA7v/0OKv1wr8V48yvB5Pm/1bA0+SHJF2u3q7922e7l1adejz1Hd3CmXFxFawSTTSJDDGpd5JGCqqgZJJPQAU8nAr8mf27f2y9Q+LXia/8AA/hPUHtvAunymGeW3fB1WVThmYjrCCPlXo2Nxz8oXx+G+HMTxJjPq9B8sY6yl0iv1b6L9EzbFYqGFhzS36I+qfjJ/wAFL/hv8OrufTvDUFx481OIlWexkENkrDt57A7vqisvvXzVr/8AwVc+Jd5O39keGfDOmW5PyrcRT3Eg/wCBeaoP/fNfE9Ff03gOAMgwMFGVH2ku823f5aL8D5SpmWJqPSVl5H2Zpv8AwVU+LNrMDd6J4UvYv4lNncRt+BE/H5Gvbvhf/wAFW/DGtXUNn468LXfhsuQp1HTZftkA/wBpo9quo/3d5r8xaK6MXwJw/i4OLwyg+8W4tfp96ZMMwxMHfmv6n9CPhDxnofj/AEC11vw7qtrrOk3IzFd2cgdG9Rx0I6EHBB4IFbNfht+zT+0z4m/Zt8Zxalpc0l5oVy6jU9Fd8RXUfcjssgH3XHTocgkH9qfAHjvRviZ4N0nxR4fuxe6RqcAnglHBweCrDsykFSOxBFfzfxZwlX4ZrKSfPRn8MvP+WXn+D3XVL6jB42OLj2kuh0FFFFfAHpBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH5B/8ABTX/AJOiu/8AsE2f8mr5Rr6u/wCCmv8AydFd/wDYJs/5NXyjX9ycK/8AIiwX/XuP5HwGM/3ifqz66/4Je/8AJzT/APYDu/8A0OKv1wr8j/8Agl7/AMnNP/2A7v8A9Dir9cK/nXxO/wCR9/25H82fTZT/ALv82eG/tr/Eu4+Fn7NnjDVLKUwaldQLplo6nDK87CMsD2KoXYH1UV+I9frP/wAFTVlP7NtgY87B4htTJj+75Nx/XbX5MV+p+F+Hp0slnWivenN3+SSS/P7zyM2k3XUeyCvuj9nf/gmTf/EPwlYeJvHmvXHhy21CJZ7XSbCFWuvKYZV5Hf5YyRg7drHBGSDkV8RaPNbW+r2Mt4nmWiTo0yYzuQMCw/LNf0L6deW2o2FtdWcsc9pPGssMsRyjowyrKfQgjFPxE4ix+R0KFLAPldTmvKybXLbRXutb/hoLLMLTxEpOprbofAXj3/gkzpLaTNJ4L8bX0WpIpMdvrsKSRSn+6ZIlUp9drfSvz68feAde+GHi3UfDXiXTpNL1mwk2TW8nPuGUjhlIwQw4IOa/oKryb4s/su/D342eMPD/AIj8W6OdRvdGRo0jEmyO5QkMqTgcuqtkhcgfM2cgkV+d8OeJGMwdR084k6tNp2aS5k+nZNPbXbe9j08VlcJq9DR/gfk5+zx+yJ48/aLvkl0iz/srw2r7bjX79CtuuDyIx1lf/ZXgHG4rnNfrj+z58B9G/Z2+HkPhTRb2+1GLzmuZ7m+k3GSZgAxVB8sa/KMKv4kkkn0PT9OtNJsbeysbaGzs7dBHDb28YjjjUDAVVHAAHYVYr5bifjPHcRv2MlyUU7qK/ByfV/cvLqdmEwNPC+9vLuFFFFfnx6QUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB+Qf8AwU1/5Oiu/wDsE2f8mr5Rr6u/4Ka/8nRXf/YJs/5NXyjX9ycK/wDIiwX/AF7j+R8BjP8AeJ+rPrr/AIJe/wDJzT/9gO7/APQ4q/XCvyP/AOCXv/JzT/8AYDu//Q4q/XCv518Tv+R9/wBuR/Nn02U/7v8ANnhf7bnw6n+Jv7NHjLTbOIzahZwLqdsijJZoGEjADuSiuoHq1fiTX9FLKGUgjIPUGvyA/bn/AGR774GeM7rxPoFk8vgHVpzJC8S5XTpmOTbv6Ln7hPUfL1HP0/hfn1Gj7TJ68rOT5oX6u1nH10TXfU5M2w8pWrRW2jPlWvrz9lf/AIKEa98ENMs/C3iqyl8UeD7fCW7RuBe2Kf3Yy3EiDsjEY6BgABXyHRX7tmeVYPOcO8LjqanH8U+6e6fofPUq06Euem7M/d34Q/tJ/Dr442qN4T8TWl5eldz6ZOfJvI/XMTYYgf3lyvvXpuc1/Oza3U1lcxXFvNJbzxMHjliYqyMOhBHIPvX1V8Dv+CjXxL+Fz29j4jmHjzQUwpi1OQi8jX/YuMEk/wDXQP8AhX4HnXhbWpXq5TV51/LLR/KWz+aXqfR0M3i9Kyt5o/XyivJfgN+1B4C/aH0wzeGNT8vVIkD3OjXuI7yAdyUyQ68j5kJHIyQeK9ar8PxeExGBrSw+Kg4TW6asz34TjUjzQd0FFFFchYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB+Qf/BTX/k6K7/7BNn/ACavlGvq7/gpr/ydFd/9gmz/AJNXyjX9ycK/8iLBf9e4/kfAYz/eJ+rPrr/gl7/yc0//AGA7v/0OKv1wr8j/APgl7/yc0/8A2A7v/wBDir9cK/nXxO/5H3/bkfzZ9NlP+7/NhVLW9E0/xJpN3peq2UGo6ddxmK4tLqMSRyoeqsp4Iq7RX5NGTg1KLs0exvoz85/2iv8Agl7KZ7rXPhJdoY2Jkbw1qM20r7QTtwR6LIRj++elfBXjPwH4i+HetSaR4n0S+0LUo+tvfQNExH95cjDL6MMg9jX9BtYHjXwB4b+I2jPpPifQ7DXtPbnyL+BZAp/vLkZVvcYI9a/Zci8TMfgIxo5jH20F12mvntL52fdnh4jKqdT3qT5X+B/PpRX6Z/G//gljoWrx3GpfDHWH0K85YaNqrtNasf7qS8yJ/wAC3/UV+efxG+Gfib4S+KLjw94s0ifRtVg5MUwBWRT0dGGVdTg4ZSRwfSv37JOJssz+P+xVPeW8XpJfLr6q68z52vhKuGf7xad+hleG/Euq+D9cs9Z0TULjStVs5BLb3drIUkjYdwR/LuODX69fsS/tew/tG+GJtI10w2vjvSYg13HGAqXsOQBcRr25IDqOASCMBgB+OdegfAL4p3fwY+L3hjxdbSOkdhdp9rRf+Wtsx2zIR3yhbHocHtXn8W8N0OIcBKPL++gm4S63/l9Ht5bmmCxUsNUWvuvc/eqimxSpPGskbB0cBlZTkEHoRTq/ivY+7CiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiuU+J3xS8M/B3wjc+JfFmpppWkwEJ5jKXaRznaiKoJZjg4AHYnoCa1o0amIqRpUouUpOyS1bfkiZSUVeT0OrrlLL4reENR8fXPgm08Q2N14qtrZrqfS4Zd8sUYYKd2OAwLL8pO7BzjHNfmX+0f/wUj8W/Er7VongFZ/Bvhx8o14HA1G5X3dTiEH0Q7v8AbwcV8ufDj4k658LPH2k+MNDujFrGnXHnq8hLCXOQ6P6q6llb1DGv2rLPC/G4jCTrY6p7Oo0+WK116cz2S8ld+fQ8Krm0IzUaauur/wAj+gKivB/gb+2d8NfjV4etbhNfsfD2ulALrRNWuUgmikxyIyxAlX0Ze2MhTwOr+If7S3wy+GGi3Go654y0lREhZbO1u0nupj2VIkJZiemcYGeSBzX5RVybMaOJ+qTw8vaXtbld/l39Voewq9KUedSVj8zP+CmFwk37Uuoohy0Wl2aOPQ7C38mFfKtd18cvindfGr4s+JfGl1EbZtVut8VuTkwwqoSJCe5VFQE9yCa4Wv7ayPCVMBleGwtX4oQin6pK/wCJ8HiJqpVlNbNs+vP+CXUbP+0xMwGQmg3TH6eZCP61+t1fmR/wSY8Hy3XxA8ceKWjPkWOmRaarkcF5pRIQPcC3Gf8AeHrX6aTyNFC7rG0rKpIjUgFj6DJA59zX8weJNWNXiCcI/ZjFP1tf9T6zK4tYZN9Wx9fPHxr/AG6vhf8ABTW4NEu9SfXtY+0JFdWujgTfYkLAO8r52gqMnYCWyACBnNfCX7Tn7fPxG+JOpap4Y0uKf4f6HBLJa3FjA5F/KVJVlnlGCvIIKJgdQS1fJJOTX1/D3hj7SKxGczsntCL/ADlt8o/f0OLE5tZ8tBfN/wCR/Q/pOrWevaXaalp1zFe2F3Ek9vcwNuSWNgCrKR1BBBq3X5Gfse/t36j8A4IvCviqC41zwOXJh8khrnTSTkmMEgPGSSShIwSSD1DfpP4E/aX+F3xJsorjQfHOi3LOAfs090tvcL/vQybXH5V+a8QcIZlkWIlF03Ol9maV01522fdP5XR6mGxtLERTvZ9j0yvkv/gpf8O9K8Tfs4X/AIluIIxq3hu5t57W5wN+yWeOGSPP90+YGx6otfQ3iD4veBvClk93rPjDQtMt1GS91qMKZ+gLZJ9hzX5w/t6fts6P8ZdIj8A+BXlufDkdwtxqGrSI0YvHTlI41bB8sH5izAEkLgYGW7eCspzLEZzh8Rh6clGEk5Ss0lFbq/mrq3n2Ix9alGhKMnq1oj4hooq1pWl3Ot6pZ6dZRNPeXkyW8ES9XkdgqqPqSBX9jtqKu9j4c/e74LX0up/B3wLeTEtNcaDYSuT3ZrdCf1NdlWT4Q0FPCvhTRtFjYNHptlDZqw7iOMID+la1f5+YqcalepOGzba9Ln6RBNRSYUUUVzFhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFcf8XfhhpHxl+HWt+D9bQmx1OAx+aoBeCQHdHKv+0rBWH0weDXYUVtRrVMPVjWpO0otNNdGtUyZRUk4vZn4EfF74S+IPgn491Lwn4ktTBfWj/JKoPlXMRJ2TRnujAfhyDgggcZX7r/AB//AGb/AAf+0Z4XXSvEto0d5bhjY6ta4W5tGPXaxHKnjKHIOOxAI/Mf4yf8E8fiv8L7qebSNMPjjRFJMd5oqFp9vbfbffB/3N496/rXhnjzL84oxpYyapV1unopPvFvTXs9fXc+NxeXVKEm4K8T5goq9rGhal4eu2tdV0+7026XrBeQNE4/4CwBqkkbSuqIpd2OAqjJJr9QUlJcyeh5NraCVNZWVxqV5BaWkElzdTyLFFDCpZ5HY4VVA5JJIAAr1L4bfsp/Fb4r3MSaD4L1MWshH/Ewv4Ta2qj18yTAbHouT7V+j/7J37A2hfAW7t/E/iW5h8S+NkXMMiIfsmnkjnyQwyz/APTRgPZV5J+Jz/jDLMipSc6inV6Qi7u/nb4V5v5XO/D4KriJKysu56D+xv8AAZv2f/glpmi3yKviC+c6jqpUg7Z3AAjz3CIqJ6EhiOte5UCiv44x2NrZjiqmLxDvObbfz/RbLyPt6cI0oKEdkfn5/wAFCf2MbvxJc3fxS8C2DXOobN2uaTbJl5go/wCPmNR1YAfOo5IAYc7s/mxX9FVfJf7SX/BPDwb8Z7u617w1MvgzxVMTJK8EW6zu3PJMkQxtYnq6Y6klWNftfB3iDDA0Y5dm7fJHSM97LtJb2XRq9tmup4OOy11JOrR36r/I/ImivePiX+w98ZPhjPL9q8IXWu2KH5b/AEAG9jYf3tqDzFH+8grxDUdLvdIuWt7+0nsrhesVxE0bj6ggGv6FwmYYTHw9phKsZr+60/yPmp0503aaaK1FHWu98DfAT4jfEmeOPw14K1rVVkOBcR2bpAPrKwCL+LCuitXo4aDqVpqMV1bSX3smMZSdoq5wVfbX/BN39mS88beOrb4m65ZtH4a0KUtpolXAvL0cBl9UiPzbv74UDOGx237Pv/BLi4W8ttY+LGoRCBCHHh3S5Sxf/ZmnHAHqsec/3xX6HaLoth4d0m00zS7ODT9OtI1ht7W2jCRxIBgKqjgAV+FcZ8fYV4aeXZTPnlNWlNbJPdRfVva60S2d9vocDl0+dVayslsi5RRRX83H1AUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEVzaQXkRjnhjnjP8EiBh+RqvZ6Lp+nuXtbG2tmP8UMKof0FXaKpTklyp6CsgoooqRhRRRQAUUUUAFQXdjb38fl3MEVxH/clQMPyNT0U03F3QjOtPDmlWEnmWum2dtIP44rdFP5gVogYoopynKesncEktgoooqRhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/Z",
  "units": [
    {
      "slug": "basics",
      "intl": {
        "es": {
          "title": "Valores, variables, operadores, tipos y comentarios"
        },
        "pt": {
          "title": "Valores, variáveis, operadores, tipos e comentários"
        }
      },
      "prefix": "01",
      "parts": [
        {
          "prefix": "01",
          "slug": "values-variables-and-types",
          "type": "read",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Valores, tipos de datos y operadores",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Entender qué se entiende por <em>values</em> (valores) en JavaScript.</li>\n<li>Conocer los diferentes <em>data types</em> (tipos de datos) en JavaScript.</li>\n<li>Aprender cómo combinar y transformar valores con operadores en JavaScript.</li>\n</ul>\n<hr>\n<p>El texto a continuación se basa en gran medida, con ciertos ajustes, en el\ncapítulo 1 de <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>, de Marijn\nHaverbeke, 2014. Traducción en <a href=\"http://hectorip.github.io/Eloquent-JavaScript-ES-online/chapters/01_values.html\">Español</a>\ndisponible gracias a <a href=\"https://github.com/hectorip\">hectorip</a>.</p>\n<h2>Vivimos en un mundo de Data</h2>\n<p>En el 2010, el entonces CEO de Google, Eric Schmidt, mencionaba que\ncada dos días creamos tanta data como lo hicimos desde los inicios de la\ncivilización hasta el 2003 (<a href=\"https://techcrunch.com/2010/08/04/schmidt-data/\">fuente</a>).\nLas compras que haces son data, tus notas en el colegio son data, tu perfil de\nFacebook está minado de data. Tus búsquedas en Google, las señales de GPS de tu\ncelular, los videos que miras y subes a YouTube, las imágenes que ves en\nInstagram, los registros del clima, los corrreos electrónicos ... todo eso es\ndata!</p>\n<p>La data es crucial porque nos ayuda a tomar decisiones y a entender el mundo que\nnos rodea. La data es la base de la información, que a su vez es la base del\nconocimiento, y el conocimiento se traduce en mejores decisiones. Desde\ndecisiones simples, como elegir un lugar para almorzar en base a los reviews de\nYelp; hasta decisiones complejas, como predecir si una mujer está embarazada,\nsegún su historial de compra en un hipermercado (<a href=\"http://www.forbes.com/sites/kashmirhill/2012/02/16/how-target-figured-out-a-teen-girl-was-pregnant-before-her-father-did/#1a3ac4\">fuente</a>).</p>\n<h2>Tipos de datos</h2>\n<p>Las computadoras son un gran recurso para trabajar con grandes cantidades de\ndatos. De hecho, en el mundo de las computadoras solo existen datos. Con las\ncomputadoras podemos leer data, modificar data y crear nueva data. Toda la data\nes almacenada como secuencias largas de los famosos <em>bits</em> - esas secuencias de\nunos y ceros que viste en Matrix.</p>\n<p>Las computadoras manejan billones de bits. Para hacer más fácil el manejo de\ngrandes cantidades de bits, los podemos dividir en \"pedazos\" que representan\npiezas de información. En un entorno JavaScript, estos pedazos son llamados\n<em><strong>values</strong></em> (valores en español). Cada <em>value</em> tiene un <em>data type</em> (tipo de\ndato) que determina su rol. En JavaScript existen cinco (5) tipos de datos\nprimitivos:</p>\n<ol>\n<li><code>number</code> (número).</li>\n<li><code>string</code> (cadena).</li>\n<li><code>boolean</code> (booleano).</li>\n<li><code>undefined</code> (indefinido).</li>\n<li><code>null</code> (nulo).</li>\n</ol>\n<p>La data y los tipos de datos forman las bases de cualquier lenguaje de\nprogramación. Nos permiten organizar información y determinar cómo ejecutar el\nprograma. En esta lección aprenderás a definir y manipular estos tipos de datos.</p>\n<h2>1. Numbers</h2>\n<p>Los <em>values</em> de tipo <code>number</code> son, sin sorpresa alguna, valores numéricos. Es\ndecir, pedazos de data que representan información numérica se representan con\nel tipo <code>number</code>. Esto incluye números positivos, negativos, enteros y\ndecimales. Además, el tipo de datos <code>number</code> tiene tres valores simbólicos:\n<code>+Infinity</code>, <code>-Infinity</code> y <code>NaN</code> (no-un-número).</p>\n<p>Veamos varios ejemplos. Abre tu consola (recuerda que lo haces haciendo click\ncon el botón derecho del mouse -> inspect -> console) y escribe los siguientes\nnúmeros. Al hacerlo, la consola te regresa el número de vuelta.</p>\n<pre><code class=\"language-js\">13\n// retorna: 13\n\n-9.81\n// retorna: -9.81\n</code></pre>\n<p>También puedes hacer uso de la notación científica para números muy grandes o\nmuy pequeños, añadiendo una \"e\" de \"exponente\", seguido por el exponente del\nnúmero:</p>\n<pre><code class=\"language-js\">5e10\n// retorna: 50000000000\n\n-2.998e8\n// retorna: -299800000\n</code></pre>\n<h3>Operadores Aritméticos</h3>\n<p>Lo principal que se hace con los números es aritmética. Sigamos explorando el\ncomportamiento del tipo de dato <code>number</code> en tu consola. Escribe el siguiente\nejemplo en tu consola y confirma que tienes el mismo resultado:</p>\n<pre><code class=\"language-js\">100 + 4 * 11\n// retorna: 144\n</code></pre>\n<p>Los símbolos <code>+</code> y <code>*</code> son llamados <em>operators</em> (operadores). El primero\nrepresenta la suma y el segundo la multiplicación. Al poner un operador entre\ndos valores, se aplicará la operación a esos valores y producirá un nuevo valor.\nComo ves, la multiplicación ocurre primero. Pero como en matemáticas, puedes\ncambiar esto encerrando en paréntesis la suma.</p>\n<pre><code class=\"language-js\">(100 + 4) * 11\n// retorna: 1144\n</code></pre>\n<p>Para la resta existe el operador <code>-</code>, y la división se puede hacer con el\noperador <code>/</code>. Veamos más ejemplos (recuerda hacerlos en tu consola también!):</p>\n<pre><code class=\"language-js\">12345 / 250\n// retorna: 49.38\n\n1234 + 57 * 3 - 31 / 4\n// retorna: 1397.25\n\n100 / 0\n// retorna: Infinity\n\n100 / -0\n// retorna: -Infinity\n\n1000 * Infinity\n// retorna: Infinity\n\n0/0\n// retorna: NaN\n\nInfinity - Infinity\n// retorna: NaN\n</code></pre>\n<p>También existe un operador aritmético más, que podrías no reconocer\ninmediatamente. El símbolo <code>%</code> es usado para representar la operación <em>residuo</em>.\nX % Y resulta en el residuo de dividir X entre Y. Por ejemplo, 314 % 100 produce\n14 (porque 100 multiplicado por 3 + 14 = 314), y 144 % 12 da 0 (porque 12\nmultiplicado por 12 + 0 = 144). Verás a menudo este operador referido como\n<em>módulo</em>, aunque técnicamente residuo es más preciso.</p>\n<pre><code class=\"language-js\">5 % 3\n// retorna: 2\n\n7 % 2\n// retorna: 1\n</code></pre>\n<h2>2. Strings</h2>\n<p>El siguiente <em>data type</em> básico es el <code>String</code> (<em>cadena</em> en español, ya que hace\nreferencia a <em>cadena de caracteres</em>). Es el tipo de dato que\nutilzamos para representar texto. Se declaran al poner el contenido entre\ncomillas.</p>\n<p>Abre tu consola y escribe lo siguiente:</p>\n<pre><code class=\"language-js\">\"Hola, mi nombre es Michelle\"\n// retorna: \"Hola, mi nombre es Michelle\"\n\n'Soy desarrolladora web'\n// retorna: \"Soy desarrolladora web\"\n\n\"123\"\n// retorna: \"123\"\n</code></pre>\n<p>Tanto las comillas simples como las dobles pueden ser usadas para declarar\n<code>strings</code>, siempre y cuando coincidan al principio y al final. Casi cualquier\ncosa puede colocarse entre comillas, y JavaScript creará un <em>string value</em> de\nesa cosa.</p>\n<hr>\n<p><strong>Pro tip</strong>:</p>\n<p>Podemos usar tanto comillas simples (<code>'</code>) como dobles (<code>\"</code>) para delimitar\nnuestros strings, pero por convención, normalmente en cada proyecto se elige\nusar o una u otra y tratamos de ser consistentes. Esto ayuda a la <em>claridad</em> y\n<em>mantenibilidad</em> del código a largo plazo. En nuestro caso, vamos a elegir las\ncomillas simples de aquí en adelante.</p>\n<hr>\n<p>Existen un par de caracteres en los <code>strings</code> que tienen un\ncomportamiento especial. Por ejemplo, cuando una diagonal invertida (<code>\\</code>) se\nencuentra dentro de un texto entre comillas, indica que el carácter siguiente\ntiene un significado especial. Esto se denomina <em>escapar el carácter</em>. Cuando el\ncarácter <code>n</code> sigue a una diagonal invertida (backslash - <code>\\</code>), se interpreta\ncomo una nueva línea. Similarmente, una <code>t</code> después de la diagonal invertida\nsignifica un tab. Escribe los siguientes textos en tu consola (recuerda siempre\ncolocarlos entre comillas, sean simples o dobles).</p>\n<pre><code class=\"language-js\">'Esta es la primera línea \\n Y esta la segunda'\n// retorna: \"Esta es la primera línea\n//            Y esta la segunda\"\n\n'Mi lenguaje favorito es \\t JavaScript'\n// retorna: \"Mi lenguaje favorito es    JavaScript\"\n</code></pre>\n<p>Cuando una comilla es precedida por una diagonal invertida, la comilla no\nterminará la cadena sino que será parte de ella.</p>\n<pre><code class=\"language-js\">'Yo \\'estudio\\' en Laboratoria'\n// retorna: \"Yo 'estudio' en Laboratoria\"\n</code></pre>\n<p>Existen, por supuesto, situaciones en las que querrás que una diagonal invertida\nsea sólo eso en una cadena de texto, no un código especial. Si dos diagonales\ninvertidas están juntas, se volverán una, y sólo eso quedará como resultado en\nel valor de la cadena.</p>\n<pre><code class=\"language-js\">'Un carácter de nueva línea es escrito \\'\\\\n\\'.'\n// retorna: \"Un carácter de nueva línea es escrito '\\n'.\"\n</code></pre>\n<p>Las cadenas de texto no pueden ser divididas numéricamente, multiplicadas, o\nrestadas, pero el carácter + puede ser usado en ellas. No suma, sino que\nconcatena; pega dos <code>strings</code>. La siguiente línea produce el <code>string</code>\n\"concatenar\":</p>\n<pre><code class=\"language-js\">'con' + 'cat' + 'e' + 'nar'\n// retorna: \"concatenar\"\n</code></pre>\n<p>Ten cuidado mezclando operaciones entre <em>numbers</em> y <em>strings</em>. Por ejemplo,\nmultiplicar un <em>number</em> por un <em>string</em> resulta en NaN.</p>\n<pre><code class=\"language-js\">'hola' * 3\n// retorna: NaN\n</code></pre>\n<p>Hay más maneras de manipular <code>strings</code>, que veremos más adelante.</p>\n<h3>Operadores Unarios</h3>\n<p>No todos los operadores son símbolos. Algunos son escritos como palabras. Un\nejemplo es el operador <code>typeof</code>, que produce una cadena de caracteres (<em>string</em>)\nque representa el tipo del valor que le pasaste.</p>\n<pre><code class=\"language-js\">typeof 4.5\n// retorna: \"number\"\n\ntypeof 'hola'\n// retorna: \"string\"\n\ntypeof NaN\n// retorna: \"number\"\n\ntypeof Infinity\n// retorna: \"number\"\n</code></pre>\n<p>Fíjate que verificamos que <em>NaN</em> e <em>Infinity</em> son del tipo <code>number</code> (de valor\nsimbólico), tal como lo mencionamos anteriormente.</p>\n<p>Los otros operadores que hemos visto operaban sobre dos valores, pero <code>typeof</code>\nsólamente toma uno. Los operadores que usan dos valores son llamados operadores\n<em>binarios</em>, mientras que aquellos que sólo toman uno son llamados operadores\n<em>unarios</em>.</p>\n<p>El operador menos (<code>-</code>) puede usarse tanto como operador binario como operador\nunario.</p>\n<pre><code class=\"language-js\">- (10 - 2)\n// retorna: -8\n</code></pre>\n<h2>3. Booleans</h2>\n<p>A menudo, necesitarás un valor que simplemente distinga entre dos posibilidades,\ncomo \"sí\" y \"no\" o \"encendido\" y \"apagado\". Para esto, JavaScript tiene un tipo\nde dato <em>boolean</em>, que tiene solo dos valores: <em>true</em> (verdadero) y <em>false</em>\n(falso).</p>\n<h3>Operadores comparativos</h3>\n<p>Realiza esta comparación en tu consola:</p>\n<pre><code class=\"language-js\">3 > 2\n// retorna: true\n\n2 > 3\n// retorna: false\n\ntypeof (3 > 2)\n// retorna: \"boolean\"\n\ntypeof (2 > 3)\n// retorna: \"boolean\"\n</code></pre>\n<p>Los signos <code>></code> y <code>&#x3C;</code> son los símbolos tradicionales para \"mayor que\" y \"menor\nque\", respectivamente. Estos son operadores binarios (porque operan sobre dos\nvalores). Aplicarlos resulta en un valor de tipo <em>boolean</em> que indica si son\nciertos.</p>\n<p>Los <code>strings</code> pueden ser comparados de la misma manera.</p>\n<pre><code class=\"language-js\">\"Aardvark\" &#x3C; \"Zoroaster\"\n// retorna: true\n</code></pre>\n<p>La manera en que los <code>strings</code> son ordenadas es más o menos alfabéticamente: las\nletras mayúsculas son siempre \"menores\" que las minúsculas, así que <code>'Z' &#x3C; 'a'</code>\nes <em>true</em>, y los caracteres no alfabéticos (<code>!</code>, <code>-</code>, y así por el estilo) son\ntambién incluidos en el ordenamiento. La comparación real está basada en el\nestándar <a href=\"https://unicode-table.com/en/#control-character\">Unicode</a>.</p>\n<pre><code class=\"language-js\">'Zeyla' &#x3C; 'ana'\n// retorna: true\n\n'Zeyla' &#x3C; '!na'\n// retorna: false\n</code></pre>\n<p>Otros operadores similares son >= (mayor o igual que), &#x3C;= (menor o igual que),\n== (igual que), y != (no es igual que).</p>\n<pre><code class=\"language-js\">'Itchy' == 'Itchy'\n// retorna: true\n\n'Itchy' != 'Scratchy'\n// retorna: true\n\n5 == 5\n// retorna: true\n\n10 != 'diez'\n// retorna: true\n</code></pre>\n<p>Sólo existe un valor en JavaScript que no es igual a sí mismo, y este es NaN,\nque significa \"no es un número\".</p>\n<pre><code class=\"language-js\">NaN == NaN\n// retorna: false\n</code></pre>\n<p>La intención de NaN es representar el resultado de un cálculo sin sentido y como\ntal, no es igual al resultado de cualquier otro cálculo sin sentido.</p>\n<h3>Operadores Lógicos</h3>\n<p>Hay también algunas operaciones que pueden ser aplicadas a los valores\n<code>Booleans</code>. JavaScript soporta tres operadores lógicos: <em>and</em>, <em>or</em> y <em>not</em>.\nEstos pueden ser usados para \"razonar\" con los <code>Booleans</code>.</p>\n<p>El operador <code>&#x26;&#x26;</code> representa la operación lógica <em>and</em> (\"y\"). Es un operador\nbinario, y su resultado es <em>true</em> (verdadero) sólo si los dos valores dados son\nverdaderos. El operador <code>||</code> denota la operación lógica or (\"o\"). Devuelve\nverdadero si cualquiera de los dos valores dados es verdadero. <em>Not</em> (Negación)\nes escrito como un símbolo de admiración <code>!</code>. Es un operador binario que voltea\nel valor que se le de; !true produce false y !false produce true. Veamos unos\nejemplos:</p>\n<pre><code class=\"language-js\">true &#x26;&#x26; true\n// retorna: true\n\ntrue &#x26;&#x26; false\n// retorna: false\n\nfalse &#x26;&#x26; false\n// retorna: false\n\ntrue || true\n// retorna: true\n\ntrue || false\n// retorna: true\n\n!true\n// retorna: false\n\n!false\n// retorna: true\n\n</code></pre>\n<p>El último operador lógico del que aprenderás no es unario, ni binario, sino\nternario, opera en tres valores. Este es escrito con un símbolo de interrogación\ny dos puntos, como sigue:</p>\n<pre><code class=\"language-js\">true ? 1 : 2\n// retorna: 1\n\nfalse ? 1 : 2\n// retorna: 2\n</code></pre>\n<p>Este es llamado el operador condicional (o algunas veces el operador tenario\ndado que es el único operador de este tipo en el lenguaje). El valor a la\nizquierda del signo de interrogación \"escoge\" cuál de los otros dos valores\nresultará. Cuando es verdadero, el valor central es escogido, y cuando es falso,\nel valor de la derecha se da como resultado.</p>\n<h2>4. Null y undefined</h2>\n<p>Existen dos valores especiales, escritos <code>null</code> y <code>undefined</code>, que son usados\npara denotar la ausencia de un valor significativo. Son valores en sí mismos,\npero no poseen ninguna información. Muchas operaciones en el lenguaje que no\nproducen un valor con significado (lo verás después) producen <code>undefined</code>\nsimplemente porque tienen que producir algún valor.</p>\n<p>La diferencia en el significado entre <code>undefined</code> y <code>null</code> es un accidente del\ndiseño de JavaScript, y no importa la mayoría del tiempo.</p>\n<p>Entender la diferencia entre <code>undefined</code> y <code>null</code> (sí hay una diferencia\nsemántica) es importante, y más sencillo de lo que parece. Ambos valores denotan\nla ausencia de un valor, pero en un caso podríamos decir que es <em>intencional</em>\n(<code>null</code>) y en el otro no (<code>undefined</code>).</p>\n<p>El valor <code>undefined</code> significa que no se ha <em>asignado</em> un valor, a diferencia de\n<code>null</code>, que significa que hemos <em>asignado</em> el valor <code>null</code>. Esto puede ser muy\nútil para diferenciar estados en operaciones asíncronas, ... es común que\n<code>undefined</code> signifique que la operación no ha completado aún, mientras que\n<code>null</code> significa que completó pero retornó un valor nulo.</p>\n<h3>Conversión automática de tipo</h3>\n<p>Cuando un operador es aplicado al tipo \"incorrecto\" de valor, JavaScript\nconvertirá silenciosamente el valor en el tipo de dato que espera, usando un\nconjunto de reglas que a menudo no son lo que tú quieres o esperas. Esto es\nllamado <em>coerción de tipo</em>. Mira estos ejemplos:</p>\n<pre><code class=\"language-js\">8 * null\n// retorna: 0\n\n'5' - 1\n// retorna: 4\n\n'5' + 1\n// retorna: 51\n\n'cinco' * 2\n// retorna: NaN\n\nfalse == 0\n// retorna: true\n</code></pre>\n<p>El null en la primera expresión se vuelve 0, y el \"5\" en la segunda expresión se\nconvierte en 5 (de string a number). Aún así, en la tercera expresión, + intenta\nhacer concatenación de strings antes de una suma numérica, así que el 1 es\nconvertido en \"1\" (de number a string). Cuando algo que no se corresponde con un\nnúmero de manera obvia (como \"cinco\" o undefined) es convertido a un número, el\nvalor resultante es NaN. Las siguientes operaciones aritméticas sobre NaN\nseguirán produciendo NaN. Por eso, en la cuarta expresión, \"cinco\" * 2 retorna\nNaN.</p>\n<p>En el caso de la quinta expresión, cuando comparamos valores que tienen tipos de\ndato diferentes, JavaScript usa un complicado y confuso conjunto de reglas para\ndeterminar qué hacer. En la mayoría de los casos, sólo trata de convertir uno de\nlos valores al tipo de dato del otro valor. Sin embargo, cuando null o undefined\nestán en cualquier lado de la operación, resulta verdadero sólo en el caso de\nque los dos lados sean null o undefined.</p>\n<p>Siguiendo con la quinta expresión, las reglas para convertir cadenas y números a\nBooleanos dicen que 0, NaN y la cadena vacía (\"\") cuentan como <em>false</em>, mientras\nque todos los demás valores cuentan como <em>true</em>. Debido a esto, las siguientes\nexpresiones retornan <em>true</em>:</p>\n<pre><code class=\"language-js\">false == 0\n// retorna: true\n\n'' == 0\n// retorna: true\n</code></pre>\n<p>Para casos en el que no quieres que ocurra ninguna conversión automática de\ntipos, existen dos operadores extra: === y !==. El primero prueba si un valor es\nprecisamente igual a otro, y el segundo si no es precisamente igual. Por lo\ntanto, al cambiar de == a === las mismas expresiones anteriores, tenemos el\nresutado contrario: <em>false</em>:</p>\n<pre><code class=\"language-js\">false === 0\n// retorna: false\n\n'' === 0\n// retorna: false\n</code></pre>\n<hr>\n<h2>Notas sobre comparaciones de igualdad/desigualdad</h2>\n<p>A continuación veremos algunas peculiaridades sobre los operadoradores de\nigualdad (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>). Al final de la lectura te dejamos como\nreferencia el link a la documentación oficial de operadores y expresiones en MDN\nque recomendamos <em>leer</em> (o por lo menos ojear).</p>\n<h3>Diferencia entre <code>==</code> y <code>===</code></h3>\n<h4>Algoritmo de <code>==</code></h4>\n<p>Cuando se evalúan dos valores con este operador, se sigue la secuencia a\ncontinuación para determinar el resultado:</p>\n<ul>\n<li>Si son del mismo tipo, entonces, se prueban con ===.</li>\n<li>Si son de diferente tipo.\n<ul>\n<li>Si uno es null y otro undefined, retorna true.</li>\n<li>Si uno es string y otro number, se convierte el string, y se evalúan como\nnúmeros.</li>\n<li>Si uno es booleano, se transforma, true en 1 y false en 0, y se evalúan.</li>\n<li>Si uno es un object y otro un number o string, convierte el objeto a\nprimitivo.</li>\n<li>En otros casos, devuelve false.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">null == undefined // true\n10 == '10'        // true\ntrue == 1         // true\n[10] == 10        // true\n[] == []          // false\n</code></pre>\n<h4>Algoritmo de <code>===</code></h4>\n<p>Esta igualdad es más estricta con sus resultados, utilizando la siguiente\nsecuencia para determinar el resultado:</p>\n<ul>\n<li>Si tienen diferentes tipos, devuelve false.</li>\n<li>Si ambos son null, devuelve true.</li>\n<li>Si ambos son undefined, devuelve true.</li>\n<li>Si uno o ambos son NaN, devuelve false.</li>\n<li>Si ambos son true o false, devuelve true.</li>\n<li>Si ambos son number y tienen el mismo valor, devuelve true.</li>\n<li>Si ambos son string y tienen el mismo valor, devuelve true.</li>\n<li>En otros casos, devuelve false.</li>\n</ul>\n<pre><code class=\"language-js\">21 === \"21\"         // false\nundefined === null  // false\nNaN === NaN         // false\n[10] === 10         // false\ntrue === 1          // false\n[] === []           // false\n'10' === '10'       // true\n</code></pre>\n<p>Podrías tener lo siguiente en cuenta para saber cuál operador utilizar:</p>\n<ul>\n<li>Si cualquiera de los valores es boolean, utiliza <code>===</code>.</li>\n<li>Si no tienes claro si los valores son convertidos por coerción, usa <code>===</code>.</li>\n<li>En otros casos podrías usar con seguridad <code>==</code>.</li>\n</ul>\n<blockquote>\n<p>Nota: Por convención y una buena práctica la comunidad promueve el uso de\n<code>===</code>.</p>\n</blockquote>\n<h3>Desigualdades</h3>\n<p>Siempre el resultado de evaluar una desigualdad es un booleano. Los siguientes\noperadores son utilizados para comparar desigualdades:</p>\n<pre><code class=\"language-js\">&#x3C;  → Menor\n>  → Mayor\n&#x3C;= → Menor Igual\n>= → Mayor Igual\n</code></pre>\n<p>Casos de uso:</p>\n<ul>\n<li>Si alguno es un <code>object</code>, se convierte a primitivo y se evalúa.</li>\n<li>Si ambos son <code>string</code>, se evalúa el orden de los caracteres alfabéticamente.</li>\n<li>Si ambos son <code>number</code>, se evalúa.</li>\n<li>En otros casos es false.</li>\n</ul>\n<pre><code class=\"language-js\">[10] &#x3C; 9    // false, caso 1\n\"a\" &#x3C; \"b\"   // true, caso 2\n10 >= 10    // true, caso 3\n</code></pre>\n<h2>Lecturas complementarias</h2>\n<p><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Expressions_and_Operators\">Expresiones y Operadores - MDN</a></p>"
            },
            "pt": {
              "title": "Valores, tipos de dados e operadores",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Entender o que são <em>values</em> (valores) em JavaScript.</li>\n<li>Conhecer os diferentes <em>data types</em> (tipos de dados) em JavaScript.</li>\n<li>Aprender como manipular e transformar valores com operadores em JavaScript.</li>\n</ul>\n<hr>\n<p>O texto em seguida se baseia em grande parte, com certos ajustes, ao capítulo 1\nde <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>, de Marijn Haverbeke\n(2014). Tradução em\n<a href=\"https://github.com/braziljs/eloquente-javascript/blob/master/chapters/01-valores-tipos-operadores.md\">Português</a>.</p>\n<h2>Vivemos num mundo de Dados</h2>\n<p>Em 2010, o então CEO da Google, Eric\nSchmidt,(<a href=\"https://techcrunch.com/2010/08/04/schmidt-data/\">mencionava</a>) que num\nperíodo de dois dias nós criávamos tantos dados quanto no período que compreende\ndesde o início da civilização até o ano de 2003. As compras que você faz são\ndados, as suas notas na escola são dados, seu perfil do Facebook está repleto de\ndados. Suas buscas no Google, os sinais de GPS do seu celular, os vídeos que\nvocê assiste e envia para o YouTube, as fotos que você vê no Instagram, o\nhistórico do clima, os e-mails trocados… tudo são dados!</p>\n<p>Os dados são cruciais porque eles nos ajudam a tomar decisões e a entender o\nmundo que nos cerca. Dados são informações, informação é conhecimento, e\nconhecimento leva à tomada de decisões melhores: desde simples, como escolher um\nlugar para almoçar baseando-se nos comentários do Yelp; à complexas, como\n(<a href=\"http://www.forbes.com/sites/kashmirhill/2012/02/16/how-target-figured-out-a-teen-girl-was-pregnant-before-her-father-did/#1a3ac4\">predizer</a>)\nse uma mulher está grávida, baseando-se no seu histórico de compra em um\nsupermercado.</p>\n<h2>Tipos de dados</h2>\n<p>Os computadores são excelentes instrumentos para trabalhar com grandes\nquantidades de dados. De fato, no universo dos computadores existem somente\ndados. Com os computadores podemos ler dados, modificar dados e criar novos\ndados. Todos os dados são armazenados em longas sequências dos famosos <em>bits</em> as\nsequências de 0s e 1s que você provavelmente já viu no filme Matrix.</p>\n<p>Os computadores manipulam bilhões de bits. Para que o manejo destas grandes\nquantidades de informação seja mais fácil, eles são divididos em “pedaços” que\nrepresentam partes de informação. No contexto do JavaScript, esses pedaços são\nchamados de <em><strong>values</strong></em> (valores, em português). Cada <em>value</em> possui um <em>data\ntype</em> (tipo de dado) que determina qual a sua funcionalidade. Em JavaScript\nexistem cinco tipos de dados primitivos:</p>\n<ol>\n<li><code>number</code> (número).</li>\n<li><code>string</code> (cadeias de caracteres).</li>\n<li><code>boolean</code> (booleano).</li>\n<li><code>undefined</code> (indefinido).</li>\n<li><code>null</code> (nulo).</li>\n</ol>\n<p>Os dados e os tipos de dados formam as bases de qualquer linguagem de\nprogramação. Eles nos permitem organizar a informação e determinar como o\nprograma deve ser executado. Nesta seção você aprenderá a definir e manipular\nesses tipos de dados.</p>\n<h2>1. Numbers</h2>\n<p>Os <em>values</em> do tipo <code>number</code> são, sem muita surpresa, valores numéricos. Ou\nseja, pedaços de dado que representam uma informação numérica são representados\ncom o tipo <code>number</code>. Sua representação inclui números positivos, negativos,\ninteiros e decimais. Além disso, o tipo de dado <code>number</code> possui três valores\nsimbólicos: <code>+Infinity</code> (infinito positivo), <code>-Infinity</code> (infinito negativo) e\n<code>NaN</code> (not a number, ou “não-número”, em português).</p>\n<p>Vejamos alguns exemplos. Abra o seu console (lembre-se: clique com o botão\ndireito do mouse > inspect > console) e escreva os seguintes números. Ao tentar,\no console retornará o próprio número de volta.</p>\n<pre><code class=\"language-js\">13\n// retorna: 13\n\n-9.81\n// retorna: -9.81\n</code></pre>\n<p>Você também pode usar a notação científica para números muito grandes ou muito\npequenos, adicionando ao número a letra “e” (de “expoente”), seguido pelo\nexpoente do número:</p>\n<pre><code class=\"language-js\">5e10\n// retorna: 50000000000\n\n-2.998e8\n// retorna: -299800000\n</code></pre>\n<h3>Operadores Aritméticos</h3>\n<p>O que mais se faz com os números é aritmética. Sigamos explorando o\ncomportamento do tipo de dado <code>numbers</code> no seu próprio console. Digite o\nseguinte exemplo no console e confirme que o resultado é o mesmo:</p>\n<pre><code class=\"language-js\">100 + 4 * 11\n// retorna: 144\n</code></pre>\n<p>Os símbolos <code>+</code> e <code>*</code> são chamados de <em>operators</em> (operadores). O primeiro\nrepresenta a soma e o segundo, multiplicação. Ao colocar um operador entre dois\nvalores, a operação será aplicada a esses valores e produzirá um novo valor.\nComo pôde perceber, a multiplicação ocorre primeiro. Mas, assim como na\nmatemática, você pode mudar isso colocando a soma entre parênteses.</p>\n<pre><code class=\"language-js\">(100 + 4) * 11\n// retorna: 1144\n</code></pre>\n<p>Para a subtração, existe o operador <code>-</code>, e a divisão pode ser feita com o\noperador <code>/</code>. Vejamos mais exemplos (não se esqueça de fazê-los em seu console\ntambém!):</p>\n<pre><code class=\"language-js\">12345 / 250\n// retorna: 49.38\n\n1234 + 57 * 3 - 31 / 4\n// retorna: 1397.25\n\n100 / 0\n// retorna: Infinity\n\n100 / -0\n// retorna: -Infinity\n\n1000 * Infinity\n// retorna: Infinity\n\n0/0\n// retorna: NaN\n\nInfinity - Infinity\n// retorna: NaN\n</code></pre>\n<p>Também há um operador aritmético que pode não ser reconhecido imediatamente. O\nsímbolo <code>%</code> é utilizado para representar a operação <em>resíduo</em>. X <code>%</code> Y é o resto\nda divisão de X por Y. Por exemplo, 314 % 100 é 14 (porque 100 multiplicado por\n3 + 14 = 314), e 144 % 12 dá 0 (porque 12 multiplicado por 12 + 0 = 144). Você\nverá este operador frequentemente referido como <em>módulo</em> embora, tecnicamente,\nresto é mais preciso.</p>\n<pre><code class=\"language-js\">5 % 3\n// retorna: 2\n\n7 % 2\n// retorna: 1\n</code></pre>\n<h2>2. Strings</h2>\n<p>O próximo <em>data type</em> básico é a <code>string</code> (<em>sequência de caracteres</em> em\nportuguês). É o tipo de dado que utilizamos para representar texto. São\ndeclaradas ao colocar o conteúdo entre aspas.</p>\n<p>Abra seu console e escreva:</p>\n<pre><code class=\"language-js\">\"Olá, meu nome é Michelle\"\n// retorna: \"Olá, meu nome é Michelle\"\n\n'Sou desenvolvedora web'\n// retorna: \"Sou desenvolvedora web\"\n\n\"123\"\n// retorna: \"123\"\n</code></pre>\n<p>Tanto as aspas simples como as duplas podem ser usadas para declarar <code>strings</code>,\ndesde que o início coincida com o fim. Quase tudo pode ser colocado entre aspas,\ne o JavaScript criará um <em>string value</em> a partir do conteúdo entre elas.</p>\n<hr>\n<p><strong>Pro tip</strong>:</p>\n<p>Podemos usar tanto comillas simples (<code>'</code>) como dobles (<code>\"</code>) para delimitar\nnuestros strings, pero por convención, normalmente en cada proyecto se elige\nusar o una u otra y tratamos de ser consistentes. Esto ayuda a la <em>claridad</em> y\n<em>mantenibilidad</em> del código a largo plazo. En nuestro caso, vamos a elegir las\ncomillas simples de aquí en adelante.</p>\n<hr>\n<p>Existe um par de caracteres no <code>strings</code> que tem um comportamento especial. Por\nexemplo, quando uma barra invertida (<em>backslash</em> -<code>\\</code>) se encontra dentro de um\ntexto entre aspas, isso indica que o próximo caractere tem um significado\nespecial. Chamamos isso de <em>escapar caractere</em>. Quando o caractere <code>n</code> segue uma\nbarra invertida, o par de caracteres é interpretado como uma nova linha. Da\nmesma forma, um <code>t</code> após a barra invertida indica uma tabulação. Escreva os\nseguintes textos em seu console (lembre-se de sempre colocá-los entre aspas,\nsimples ou duplas).</p>\n<pre><code class=\"language-js\">'Esta é a primeira linha \\n E esta a segunda'\n// retorna: \"Esta é a primeira linha\n//            E esta a segunda\"\n\n'Minha linguagem favorita é \\t JavaScript'\n// retorna: \"Minha linguagem favorita é      JavaScript\"\n</code></pre>\n<p>Quando as aspas são precedidas pela barra invertida, elas não terminarão a\ncadeia de caracteres, mas farão parte dela.</p>\n<pre><code class=\"language-js\">'Eu \\'estudo\\' na Laboratoria'\n// retorna: \"Eu 'estudo' na Laboratoria\"\n</code></pre>\n<p>Existirão, com certeza, situações em que você desejará que uma barra invertida\nseja apenas isso em uma cadeia de caracteres, e não um código especial. Se duas\nbarras invertidas estão juntas, vão se tornar apenas uma, e somente uma barra\nsairá como resultado no valor da cadeia.</p>\n<pre><code class=\"language-js\">'Um caractere de nova linha está escrito \\'\\\\n\\'.'\n// retorna: \"Um caractere de nova linha está escrito '\\n'.\"\n</code></pre>\n<p>Cadeias de caracteres não podem ser divididas como os números, multiplicadas, ou\nsubtraídas, mas o caractere + pode ser utilizado nelas. Ele não soma, mas\nconcatena, ou seja, junta duas strings. A linha a seguir produz a string\n\"concatenar\":</p>\n<pre><code class=\"language-js\">\"con\" + \"cat\" + \"e\" + \"nar\"\n// retorna: \"concatenar\"\n</code></pre>\n<p>Tome cuidado ao misturar <em>numbers</em> e <em>strings</em> em uma operação. Por exemplo,\nmultiplicar um <em>número</em> por uma <em>string</em> resulta em NaN.</p>\n<pre><code class=\"language-js\">\"oi\" * 3\n// retorna: NaN\n</code></pre>\n<p>Há outras maneiras de manipular <code>strings</code>, como veremos mais adiante.</p>\n<h3>Operadores Unários</h3>\n<p>Nem todos os operadores são símbolos. Alguns são escritos como palavras. Um\nexemplo é o operador typeof que produz uma cadeia de texto que representa o tipo\ndo valor que lhe foi passado.</p>\n<pre><code class=\"language-js\">typeof 4.5\n// retorna: \"number\"\n\ntypeof \"hola\"\n// retorna: \"string\"\n\ntypeof NaN\n// retorna: \"number\"\n\ntypeof Infinity\n// retorna: \"number\"\n</code></pre>\n<p>Note que verificamos que <em>NaN</em> e <em>Infinity</em> são do tipo <code>number</code> (de valor\nsimbólico), como mencionamos anteriormente.</p>\n<p>Os outros operadores que vimos operavam sobre dois valores, mas <code>typeof</code> só\nrecebe um. Operadores que utilizam dois valores são chamados de operadores\n<em>binários</em>, enquanto aqueles que só recebem um são chamados de operadores\n<em>unários</em>.</p>\n<p>O operador menos (<code>-</code>) pode ser usado tanto como um operador binário como\nunário.</p>\n<pre><code class=\"language-js\">- (10 - 2)\n// retorna: -8\n</code></pre>\n<h2>3. Booleans</h2>\n<p>Muitas vezes, você precisará de um valor que simplesmente diferencie duas\npossibilidades, como \"sim\" e \"não\" ou \"ligado\" e \"desligado\". Para isso, o\nJavaScript tem o tipo de dado <em>boolean</em> que possui apenas dois valores: <em>true</em>\n(verdadeiro) e <em>false</em> (falso).</p>\n<h3>Operadores comparativos</h3>\n<p>Faça estas comparações em seu console:</p>\n<pre><code class=\"language-js\">3 > 2\n// retorna: true\n\n2 > 3\n// retorna: false\n\ntypeof (3 > 2)\n// retorna: \"boolean\"\n\ntypeof (2 > 3)\n// retorna: \"boolean\"\n</code></pre>\n<p>Os sinais > e &#x3C; são os símbolos clássicos de \"é maior que\" e \"é menor que\",\nrespectivamente. Estes são operadores binários (porque operam sobre dois\nvalores). Aplicá-los resulta em um valor de tipo <em>boolean</em> que indica se estão\ncorretos.</p>\n<p>As <code>strings</code> podem ser comparadas da mesma maneira.</p>\n<pre><code class=\"language-js\">\"Aardvark\" &#x3C; \"Zoroaster\"\n// retorna: true\n</code></pre>\n<p>A forma pela qual as <code>strings</code> são ordenadas é mais ou menos alfabética: em\nJavaScript, as letras maiúsculas são sempre \"menores\" que as minúsculas, por\nisso \"Z\" &#x3C; \"a\" é <em>true</em>, e os caracteres não alfabéticos (!, -, e assim por\ndiante) também estão incluídos na ordenação. A comparação efetiva é baseada no\npadrão <a href=\"https://unicode-table.com/en/#control-character\">Eloquent Unicode</a>.</p>\n<pre><code class=\"language-js\">\"Zeyla\" &#x3C; \"ana\"\n// retorna: true\n\n\"Zeyla\" &#x3C; \"!na\"\n// retorna: false\n</code></pre>\n<p>Outros operadores similares são >= (maior ou igual a), &#x3C;= (menor ou igual a), ==\n(igual a) e != (não é igual a).</p>\n<pre><code class=\"language-js\">\"Itchy\" == \"Itchy\"\n// retorna: true\n\n\"Itchy\" != \"Scratchy\"\n// retorna: true\n\n5 == 5\n// retorna: true\n\n10 != \"dez\"\n// retorna: true\n</code></pre>\n<p>Só existe um valor em JavaScript que não é igual a si mesmo: o NaN, que\nsignifica \"não é um número\".</p>\n<pre><code class=\"language-js\">NaN == NaN\n// retorna: false\n</code></pre>\n<p>A intenção do NaN é representar o resultado de um cálculo sem sentido e, como\ntal, não é igual ao resultado de qualquer outro cálculo sem sentido.</p>\n<h3>Operadores Lógicos</h3>\n<p>Há também algumas operações que podem ser aplicadas a valores <code>Booleans</code>. O\nJavaScript dá suporte a três operadores lógicos: <em>and</em>, <em>or</em> e <em>not</em>. Eles podem\nser usados para estabelecer relações entre <code>Booleans</code>.</p>\n<p>O operador <code>&#x26;&#x26;</code> representa a operação lógica <em>and</em> (\"e\"). É um operador binário,\ne o seu resultado é <em>true</em> (verdadeiro) somente se os dois valores fornecidos\nforem verdadeiros. O operador <code>||</code> denota a operação lógica or (\"ou\") e devolve\nverdadeiro quando qualquer um dos dois valores dados for verdadeiro. <em>Not</em>\n(negação) é escrito como o símbolo de exclamação <code>!</code>. É um operador binário que\ninverte o valor que lhe é dado: !true resulta em false e !false tem como\nresultado true. Vejamos alguns exemplos:</p>\n<pre><code class=\"language-js\">true &#x26;&#x26; true\n// retorna: true\n\ntrue &#x26;&#x26; false\n// retorna: false\n\nfalse &#x26;&#x26; false\n// retorna: false\n\ntrue || true\n// retorna: true\n\ntrue || false\n// retorna: true\n\n!true\n// retorna: false\n\n!false\n// retorna: true\n</code></pre>\n<p>O último operador lógico que você aprenderá não é unário. Este é escrito usando\num símbolo de interrogação e dois pontos, da seguinte forma:</p>\n<pre><code class=\"language-js\">true ? 1 : 2\n// retorna: 1\n\nfalse ? 1 : 2\n// retorna: 2\n</code></pre>\n<p>Este é chamado o operador condicional (ou algumas vezes o operador ternário já\nque é o único operador deste tipo na linguagem). O valor à esquerda do ponto de\ninterrogação \"escolhe\" qual dos outros dois valores será o resultado. Quando é\nverdadeiro, o valor central é escolhido, e quando é falso, o valor da direita é\no resultado.</p>\n<h2>4. Null e undefined ( nulo e indefinido)</h2>\n<p>Existem dois valores especiais, escritos como <code>null</code> e <code>undefined</code>, que são\nusados para denotar a ausência de um valor significativo. São valores por si\nmesmos, mas não possuem nenhuma informação. Muitas operações na linguagem que\nnão produzem um valor que tem significado (você verá isso depois) produzem\n<code>undefined</code> simplesmente porque têm que produzir algum valor.</p>\n<p>A diferença no significado entre <code>undefined</code> e <code>null</code> é um acidente no desenho\ndo JavaScript, e não importa a maior parte do tempo.</p>\n<p>Entender a diferença entre <code>undefined</code> e <code>null</code> (sim existe uma diferença\nsemântica) é importante e mais simples do que parece. Ambos valores denotam da\nausência de um valor, mas em um caso podemos dizer que é intencional (<code>null</code>) e\no no outro não (<code>undefined</code>).</p>\n<p>O valor <code>undefined</code> significa que não existe um valor designado, o que é\ndiferente de <code>null</code>, que significa que designamos o valor <code>null</code>. Este pode ser\nmuito útil para diferenciar o estado em operações asíncronas, ... é comum que\n<code>undefined</code> signifique que a operação não foi completada, enquanto que <code>null</code>\nsignifica que completo mas o retorno é um valor nulo.</p>\n<h3>Conversão automática do tipo</h3>\n<p>Quando um operador é aplicado ao tipo \"incorreto\" de valor, o JavaScript mudará\nsilenciosamente o valor no tipo de dado que espera, usando um conjunto de regras\nque frequentemente não são as que você quer ou espera. Isto é chamado <em>coerção\ndo tipo</em>. Olha estes exemplos:</p>\n<pre><code class=\"language-js\">8 * null\n// retorna: 0\n\n\"5\" - 1\n// retorna: 4\n\n\"5\" + 1\n// retorna: 51\n\n\"cinco\" * 2\n// retorna: NaN\n\nfalse == 0\n// retorna: true\n</code></pre>\n<p>O null na primeira expressão muda para 0, e o \"5\" na segunda expressão torna-se\n5 (de string a number). Todavia, na terceira expressão, o + tenta fazer\nconcatenação de strings antes de uma soma numérica, assim o 1 é convertido em\n\"1\" (de number a string). Quando algo que não corresponde com um número de forma\nóbvia (como o \"cinco\" ou o undefined) é convertido em número, o valor resultante\né NaN. As seguintes operações aritméticas sobre NaN continuaram produzindo NaN.\nÉ por isso que, na quarta expressão, \"cinco\" * 2 devolve NaN.</p>\n<p>No caso da quinta expressão, quando comparamos valores que têm tipos de dados\ndiferentes, o JavaScript usa um conjunto de regras, complicado e confuso, para\ndeterminar o que fazer. Na maioria dos casos, só tenta converter um dos valores\nao tipo de dado do outro valor. Contudo, quando null ou undefined estão em\nqualquer lado da operação, resulta verdadeiro só no caso de que os dois lados\nsejam null ou undefined.</p>\n<p>Continuando com a quinta expressão, as regras para converter cadeias e números a\nBooleanos dizem que 0, NaN e a cadeia vazia (\"\") contam como <em>false</em>, enquanto\ntodos os outros valores contam como <em>true</em>. É por isso que, as seguintes\nexpressões devolvem <em>true</em>:</p>\n<pre><code class=\"language-js\">false == 0\n// retorna: true\n\n\"\" == 0\n// retorna: true\n</code></pre>\n<p>Para casos em que você não quer que aconteça nenhuma conversão automática de\ntipos, existem dois operadores extras: === e !==. O primeiro prova se um valor é\nprecisamente igual a outro, e o segundo se não é precisamente igual. Portanto,\nao mudar de == a === as mesmas expressões anteriores, temos o resultado\ncontrário: <em>false</em>:</p>\n<pre><code class=\"language-js\">false === 0\n// retorna: false\n\n\"\" === 0\n// retorna: false\n</code></pre>\n<hr>\n<h2>Notas sobre comparações de igualdade/desigualdade</h2>\n<p>Nesta continuação veremos algumas particularidades sobre os operadores de\nigualdade (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>). Ao fim da leitura deixaremos como\nreferência para você o link para a documentação oficial de operadores e\nexpressões no MDN que recomendamos que você <em>leia</em> (ou olhe pelo menos).</p>\n<h2>Diferença entre <code>==</code> e <code>===</code></h2>\n<h3>Algoritmo de <code>==</code></h3>\n<p>Quando avaliamos dois valores com este operador, a sequência a seguir é\nexecutada para determinar o resultado:</p>\n<ul>\n<li>Se são do mesmo tipo, então são comparados com ===.</li>\n<li>Se são de tipos diferentes:\n<ul>\n<li>Se um é <code>null</code> e outro é <code>undefined</code>, retorna <code>true</code>.</li>\n<li>Se um é uma <code>string</code> e outro é um <code>number</code>, ele é convertido para <code>string</code> e\nsão comparados como números.</li>\n<li>Se um é booleano, são convertidos: <code>true</code> em 1 e <code>false</code> em 0, e se\ncomparam.</li>\n<li>Se um é um objeto e outro é um <code>number</code> ou <code>string</code>, converte o objeto para\num primitivo.</li>\n<li>Em outros casos, retorna <code>false</code>.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">null == undefined // true\n10 == '10'        // true\ntrue == 1         // true\n[10] == 10        // true\n[] == []          // false\n{} == {}          // false\n</code></pre>\n<h3>Algoritmo de <code>===</code></h3>\n<p>Esta igualdade é mais restrita com os resultados, utilizando a sequência a\nseguir para determinar o resultado:</p>\n<ul>\n<li>Se possuem tipos diferentes, retorna <code>false</code>.</li>\n<li>Se ambos são <code>null</code>, retorna <code>true</code>.</li>\n<li>Se ambos são <code>undefined</code>, retorna <code>true</code>.</li>\n<li>Se ambos são <code>NaN</code>, retorna <code>false</code>.</li>\n<li>Se ambos são <code>true</code> ou <code>false</code>, retorna <code>true</code></li>\n<li>Se ambos são <code>number</code> e possuem o mesmo valor, retorna <code>true</code>.</li>\n<li>Se ambos são <code>string</code> e possuem o mesmo valor, retorna <code>true</code>.</li>\n<li>Em outros casos, retorna <code>false</code>.</li>\n</ul>\n<pre><code class=\"language-js\">21 === \"21\"         // false\nundefined === null  // false\nNaN === NaN         // false\n[10] === 10         // false\ntrue === 1          // false\n[] === []           // false\n{} === {}           // false\n'10' === '10'       // true\n</code></pre>\n<p>Você pode considerar o seguinte para saber qual operador utilizar:</p>\n<ul>\n<li>Se qualquer dos valores é booleano, utilize <code>===</code>.</li>\n<li>Se não tiver certeza se os valores podem ser convertidos por coerção, utilize\n<code>===</code>.</li>\n<li>Nos outros casos pode utilizar <code>==</code> com certeza.</li>\n</ul>\n<blockquote>\n<p>Nota: Por convenção, e uma boa prática a comunidade incentiva o uso de <code>===</code>.</p>\n</blockquote>\n<h2>Desigualdades</h2>\n<p>Sempre o resultado de comparação de uma desigualdade é um booleano. Os\noperadores a seguir são utilizados para comparar desigualdades:</p>\n<pre><code class=\"language-js\">&#x3C;  → Menor\n>  → Maior\n&#x3C;= → Menor Igual\n>= → Maior Igual\n</code></pre>\n<p>Situações de uso:</p>\n<ul>\n<li>Se algum é um <code>object</code>, converte-se para primitivo e é comparado.</li>\n<li>Se ambos são <code>string</code>, é comparada a ordem dos caracteres alfabeticamente.</li>\n<li>Se ambos são <code>number</code>, são comparados.</li>\n<li>Em outros casos retorna <code>false</code>.</li>\n</ul>\n<pre><code class=\"language-js\">[10] &#x3C; 9    // false, caso 1\n\"a\" &#x3C; \"b\"   // true, caso 2\n10 >= 10    // true, caso 3\n</code></pre>\n<h2>Leituras complementares</h2>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Expressions_and_operators\">Expressões e Operadores -\nMDN</a></p>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "variables",
          "type": "read",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Variables",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Aprender qué son <em>variables</em> y su utilidad.</li>\n<li>Conocer las buenas prácticas de nombramiento de variables.</li>\n</ul>\n<hr>\n<p>El texto a continuación se basa en gran medida, con ciertos ajustes, en el\ncapítulo 2 de <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>, de Marijn\nHaverbeke, 2014. Traducción en <a href=\"http://hectorip.github.io/Eloquent-JavaScript-ES-online/chapters/01_values.html\">Español</a>\ndisponible gracias a <a href=\"https://github.com/hectorip\">hectorip</a>.</p>\n<h2>Variables</h2>\n<p>Ya conoces los tipos de datos más comunes en JavaScript. Sabes crear, combinar y\ntransformar <code>numbers</code>, <code>strings</code> y <code>booleans</code>. Pero, ¿qué podemos hacer con\nesto? Hasta ahora, todo lo que has trabajado ha sido para uso inmediato. Es\ndecir, los nuevos valores que generamos deben ser inmediatamente utilizados o se\npierden. Sigue en tu consola el siguiente ejemplo:</p>\n<pre><code class=\"language-js\">'Hola, mi nombre es ' + 'Michelle' + ' y tengo ' + 19 + ' años';\n// retorna: \"Hola, mi nombre es Michelle y tengo 19 años\"\n</code></pre>\n<p>Si quisiera utilizar ese <code>string</code> de nuevo, digamos porque Michelle cumplió años\ny ahora queremos que diga 20 años en lugar de 19, no lo podemos hacer. Se ha\nperdido.</p>\n<p>Para atrapar y mantener los valores, JavaScript proporciona una cosa llamada\n<code>variable</code>. Se utiliza así:</p>\n<pre><code class=\"language-js\">var age = 19;\n// retorna: undefined\n</code></pre>\n<p>La palabra clave (<em>keyword</em>) <code>var</code> indica que esta frase va a definir una\nvariable. Es seguida por el nombre de la variable (el nombre <em>age</em>) y, si\nqueremos asignarle de inmediato un valor, le sigue el operador <code>=</code> (operador de\nasignación) y una expresión (el número <code>19</code>).</p>\n<hr>\n<p>NOTA: En este primer ejemplo hemos usado <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/var\"><code>var</code></a>,\nque a día de hoy se considera una manera un poco anticuada de declarar\nvariables. Desde ES6 (ES2015), preferimos usar o <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/let\"><code>let</code></a>\n(para declarar variables a las que después necesitemos <em>reasignar</em> un valor\ndiferente) o <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/const\"><code>const</code></a>\n(para declarar variables que no se van a reasignar), ambas ahora con ámbito\n(<em>scope</em>) de bloque, como veremos más adelante.</p>\n<hr>\n<p>La declaración anterior crea una variable llamada <code>age</code> (o edad en español) y se\nusa para retener el número <code>19</code>. La consola devuelve <code>undefined</code>, pero no creas\nque es un error. Es lo que JavaScript hace cuando un comando no retorna valor.\nCuando escribes <code>12 + 5</code>, la consola retorna <code>17</code>. Pero al declarar una variable\nllamada <code>age</code> asignándole el valor <code>19</code>, no hay un valor de retorno. Por eso la\nconsola simplemente devuelve <code>undefined</code> (en el resto de los ejemplos vamos a\nomitir ese <code>undefined</code> de retorno porque no agrega mucho valor a la\nexplicación).</p>\n<p>Después de que una variable se ha definido, su nombre puede ser usado como una\n<em>expresión</em>. El valor de esa expresión es el valor que la variable alberga\nactualmente. Sigamos con el ejemplo anterior:</p>\n<pre><code class=\"language-js\">// declaramos `age` usando `const` ya que no vamos a reasignar esta variable.\nconst age = 19;\n'Hola, mi nombre es ' + 'Michelle' + ' y tengo ' + age + ' años';\n// retorna: \"Hola, mi nombre es Michelle y tengo 19 años\"\n</code></pre>\n<p>La consola nos ayuda a saber el valor de una variable. Si escribimos el nombre\nde una variable que ha sido declarada en la consola, nos devuelve su valor. Si\nesa variable no ha sido declarada, la consola retorna un error. Y si la variabla\nha sido declarada, pero no le hemos asignado valor, la consola devuleve\n<code>undefined</code>.</p>\n<pre><code class=\"language-js\">age\n// retorna: Uncaught ReferenceError: age is not defined\n//           at &#x3C;anonymous>:1:1\n\nconst age = 19;\nage\n// retorna: 19\n\nlet weight;\nweight\n// retorna: undefined\n</code></pre>\n<p>Cuando una variable apunta a un valor, eso no quiere decir que está ligada a ese\nvalor para siempre. De hecho, se llaman variables porque su valor puede variar.\nEl operador de asignación (<code>=</code>) se puede utilizar en cualquier momento en\nvariables existentes (declaradas con <code>let</code> o <code>var</code>) para desconectarlas de su\nvalor actual y apuntarlas a uno nuevo (identificadores declarados con <code>const</code> no\nse pueden reasignar).</p>\n<pre><code class=\"language-js\">let age = 19;\n// retorna: undefined\nage = 20;\n// retorna: 20\n'Hola, mi nombre es ' + 'Michelle' + ' y tengo ' + age + ' años';\n// retorna: \"Hola, mi nombre es Michelle y tengo 20 años\"\n</code></pre>\n<p>Ten en cuenta que para reasignarle un valor, no tienes que utilizar la <em>keyword</em>\n<code>let</code> o <code>var</code> de nuevo. Solo la utilizas cuando queremos <em>declarar</em> nuevas\nvariables.</p>\n<p>Muchas veces se explica el concepto de variables con la analogía de una caja:\nlas variables son como \"caja\" en las que puedes meter algún valor que luego\npudes cambiar por otro. Sin embargo, una analogía más fiel es pensar en\nvariables como <strong>tentáculos</strong>. Las variables en realidad no es que \"contengan\"\nlos valores (como una caja); más bien los agarra (como un tentáculo). De hecho,\ndos variables pueden referirse a un mismo valor. Un programa puede acceder sólo\na los valores que todavía mantiene \"agarrados\". Cuando necesitas recordar algo,\ncreas un tentáculo nuevo para \"agarrarlo\" o cambias unos de tus tentáculos\nexistentes para agarrar lo nuevo.</p>\n<h2>Nombrando Variables</h2>\n<p>En JavaScript, existen ciertas reglas para nombrar variables. Los nombres de\nvariables:</p>\n<ol>\n<li><strong>No</strong> pueden incluir espacios</li>\n<li><strong>No</strong> pueden ser palabras reservadas (o <em>keywords</em>), como la palabra <code>var</code></li>\n<li><strong>No</strong> pueden comenzar con números, aunque sí pueden haber números dentro del\nnombre (solo que no al comienzo)</li>\n<li><strong>No</strong> pueden contener signos de puntuación, con la excepción de los signos\n<code>$</code> y <code>_</code></li>\n</ol>\n<p>No seguir alguna de las reglas anteriores resulta en un <strong>error</strong> por parte de\nJavaScript.</p>\n<p>Además de estas reglas, existen una serie de \"sugerencias\" que debes tomar en\nconsideración a la hora de nombrar variables. Son \"sugerencias\" porque\nJavaScript no te dará un error si no las sigues. Sin embargo, son \"buenas\nprácticas\" de escritura de código que hacen que tu trabajo sea de mejor calidad.\nLas sugerencias son:</p>\n<ol>\n<li>Convención <em>camel case</em>. Dado que no podemos incluir espacios en los nombres\nde variables, una convención que se utiliza es la de <code>camel case</code>. La\nconvención dicta que el nombre de la variable empieza con una letra minúscula\ny se coloca en mayúscula la primera letra de las palabras que continúan. Por\nejemplo: <code>numberOfCandies</code> o <code>studentTechScore</code>. Se llama <em>camel case</em> porque\nsimula una joroba de camello.</li>\n<li>Utilizar nombres en inglés. La programación está basada en el inglés, así que\nes buena práctica que te acostumbres a escribir tu código en inglés.</li>\n<li>Utiliza nombres descriptivos. Al igual que las otras sugerencias, algo que\nsiempre tienes que tomar en cuenta es que otras personas leerán tu código y\ndebes hacer el esfuerzo por utilizar nombres descriptivos que ayuden al\nlector a entender mejor lo que hace tu programa.</li>\n</ol>\n<p>Veamos algunos ejemplos:</p>\n<p>| Mal nombre | Problema | Mejor nombre\n| ------------| -------- | ------------\n| age of fiends | Error: contiene espacios | ageOfFriends\n| null | Error: palabra clave (keyword) | empty\n| 1stName | Error: empieza con número | firstName\n| full.price | Error: contiene \".\" | fullPrice\n| full_price | no usa camel case | fullPrice\n| x | no es descriptivo | age\n| altura | en español | height</p>\n<h2>Incrementar y Disminuir</h2>\n<p>Como programadora, muchas veces tendrás que incrementar o disminuir el valor de\nuna variable numérica por un cierto valor. Por ejemplo, puede que tengas la\nvariable <code>score</code> que registra el puntaje en un juego de fútbol. Cada vez que\nalguien anote un gol, la variable <code>score</code> debe aumentar en 1. Esto lo puedes\nhacer de la siguiente manera:</p>\n<pre><code class=\"language-js\">let score = 0;\nscore = score + 1;\nscore;\n// retorna: 1\n</code></pre>\n<p>Esto mismo se puede escribir de una manera más sencilla:</p>\n<pre><code class=\"language-js\">let score = 0;\nscore++;\nscore;\n// retorna: 1\n</code></pre>\n<p>Lo mismo podemos hacer para disminuir el valor de una variable. Por ejemplo, en\nun video juego puede que tengas una variable llamada <code>lifePoints</code> que registra\nlos \"puntos de vida\" de un jugador. El jugador parte con 100 puntos y cada vez\nque un enemigo lo golpea, pierde 25 puntos. Cada vez que toma una bebida\nregenera 10 puntos.</p>\n<pre><code class=\"language-js\">let lifePoints = 100;\nlifePoints = lifePoints - 25;\nlifePoints\n// retorna: 75\n\nlifePoints = lifePoints + 10;\nlifePoints\n// retorna: 85\n</code></pre>\n<p>Esto se puede escribir de una manera reducida, así:</p>\n<pre><code class=\"language-js\">let lifePoints = 100;\nlifePoints -= 25;\nlifePoints\n// retorna: 75\n\nlifePoints += 10;\nlifePoints\n// retorna: 85\n</code></pre>\n<p>Existen otros operadores similares a <code>+=</code> y <code>-=</code>. Por ejemplo, existen también\n<code>*=</code> y <code>/=</code>:</p>\n<pre><code class=\"language-js\">let balloons = 100;\nballoons *= 2;\nballoons\n// retorna: 200\n\nlet balloons = 100;\nballoons /= 4;\nballoons\n// retorna: 25\n</code></pre>\n<h2>El scope de una variable</h2>\n<p>El <em>scope</em> de una variable son las ubicaciones desde donde puede ser accedida.\nPor ejemplo:</p>\n<pre><code class=\"language-js\">const foo = () => {\n  let x;\n}\n</code></pre>\n<p>Aquí, el <em>direct scope</em> (ámbito directo) de <code>x</code> es la función <code>foo</code>. Esta\nvariable podrá ser accedida desde dentro del cuerpo de la función <code>foo</code>, pero no\nfuera de ella.</p>\n<p>Tradicionalmente, en JavaScript solo podíamos crear un nuevo scope o ámbito\ncreando una nueva función. Desde ES6 (ES2015) tenemos <code>let</code> y <code>const</code>, que\nintroducen el concepto de <em>block sope</em> en JavaScript.</p>\n<h3>Lexical scoping</h3>\n<p>Las variables en JavaScript son <em>lexically scoped</em> (de ámbito léxico), lo que\nsignifica que la estructura estática de un programa determina el ámbito de la\nvariable (no es influenciada por dónde se invoca la función). En palabras más\nsimples, significa que las variables declaradas dentro de un <em>ámbito</em> (una\nfunción, o un bloque indicado por los caracteres <code>{}</code> en el caso de <code>let</code> y\n<code>const</code>), no son visibles fuera de ese <em>ámbito</em>.</p>\n<h3>Nested Scopes (ámbitos anidados)</h3>\n<p>Si el ámbito está anidado dentro del ámbito directo de una variable, la variable\nserá accesible en todos los ámbitos:</p>\n<pre><code class=\"language-js\">function foo(arg) {\n  function bar() {\n    console.log(`arg: ${arg}`);\n  }\n  bar();\n}\n\nconsole.log(foo('hello')); // arg: hello\n</code></pre>\n<p>El ámbito directo de <code>arg</code> es <code>foo</code>, pero es también accesible del ámbito\nanidado <code>bar</code>. Con respecto a la anidación, <code>foo</code> es el <em>outer scope</em> (alcance o\námbito externo) y <code>bar</code> es el <em>inner scope</em> (alcance o ámbito interno).</p>\n<h3>Shadowing (sombra)</h3>\n<p>Si un scope declara una variable que tiene el mismo nombre que otra en un scope\ninterno de una función, el acceso a la variable externa es bloqueado en el scope\ninterno y todos los scopes anidados dentro de ella. Cambios a la variable\ninterna no afecta a la variable externa, la cual es accesible nuevamente cuando\nel scope interno es dejado. Ejemplo:</p>\n<pre><code class=\"language-js\">let x = 'global';\nfunction f() {\n  let x = 'local';\n  console.log(x); // local\n}\nf();\nconsole.log(x); // global\n</code></pre>\n<p>Dentro de la función <code>f</code>, la variable <code>x</code> es sombreada por la variable local\n<code>x</code>.</p>\n<hr>\n<h2>Diferencia entre contexto y alcance</h2>\n<p>Cada invocación de función tiene tanto un alcance como un contexto asociados a\nella. Fundamentalmente, el alcance es un concepto asociado a funciones mientras\nque el contexto está asociado a objetos. En otras palabras, el alcance se\nrefiere a la accesibilidad de variables de una función cuando es invocada y es\núnico a cada invocación. En cambio, el contexto es siempre el valor de <code>this</code>\ncuya referencia es siempre el objeto que está ejecutando el código.</p>\n<h3>Alcance de variables</h3>\n<p>Las variables pueden ser declaradas con <strong>alcance local</strong> o <strong>alcance global</strong>,\nlo cual establece su accesibilidad desde diferentes alcances en tiempo de\nejecución. Cualquier variable definida como global será accesible en tiempo de\nejecución por cualquier alcance, ya que se habrá declarado fuera del cuerpo de\nuna función.</p>\n<p>En cambio, las variables locales existen solamente dentro del cuerpo de una\nfunción o bloque. El alcance local de una variable solo se define a partir del\ncuerpo de la función o bloque que la contiene.</p>\n<h2>Declaración de variables de ámbito local con \"let\"</h2>\n<p>La sentencia <code>let</code> declara una variable de alcance local, la cual,\nopcionalmente, puede ser inicializada con algún valor y permite ser reasignada\n(a diferencia de <code>const</code>).</p>\n<p>El alcance de <code>let</code> es local al bloque, declaración o expresión donde se está\nusando. Lo anterior diferencia la expresión <code>let</code> de la palabra reservada <code>var</code>,\nla cual define una variable global o local en una función sin importar el ámbito\ndel bloque.</p>\n<p>Veamos algunos ejemplos:</p>\n<pre><code class=\"language-js\">if (x > y) {\n  let gamma = 12.7 + y;\n  i = gamma * x;\n}\n</code></pre>\n<p>En el ejemplo anterior, <code>gamma</code> solo existe dentro del bloque del <code>if</code>.</p>\n<pre><code class=\"language-js\">for (let i = 0; i &#x3C; students.length; i++) {\n  console.log(students[i].name);\n}\n</code></pre>\n<p>Podemos utilizar <code>let</code> para que la variable sea local al alcance del bucle\n<code>for</code>. Si en su lugar usáramos <code>var</code>, la variable sería visible en toda la\nfunción que contiene dicho bucle.</p>\n<pre><code class=\"language-js\">(function () {\n  if (true) {\n    let x = 'hola mundo';\n  }\n  console.log(x);\n  // Da error, porque \"x\" ha sido definida dentro del \"if\"\n})();\n</code></pre>\n<p>En el ejemplo, <code>console.log(x)</code> no tiene acceso a <code>let x = \"hola mundo\"</code> y da\nerror porque <code>x</code> ha sido definida dentro del bloque <code>if</code>.</p>\n<p>En el siguiente ejemplo la consola imprime <code>Hola Ale</code>, ya que la variable <code>x</code> en\nel bloque del <code>if</code> se mantiene dentro de su ámbito.</p>\n<pre><code class=\"language-js\">(function () {\n  let x = 'Hola Ale';\n\n  if (true) {\n    let x = 'Hola Joan';\n  }\n  console.log(x);\n  // Imprime en consola Hola Ale\n})();\n</code></pre>\n<h2>Variables no reasignables con \"const\"</h2>\n<p>Las variables de solo lectura son otra de las novedades de ECMAScript 6,\nmediante la introducción de la nueva palabra reservada <code>const</code>. Cualquier\nvariable declarada como constante no podrá ser reasignada.</p>\n<p>Veamos un ejemplo:</p>\n<pre><code class=\"language-js\">(function () {\n  const HELLO = 'hello world';\n  HELLO = 'hola mundo';\n  // Dará ERROR, ya que `HELLO` no puede ser reasignada\n})();\n</code></pre>\n<p>En este ejemplo vemos cómo desde el momento en que declaramos la constante\n<code>HELLO</code>, su valor queda blindado y el intérprete lanzará error al tratar de\nasignar un nuevo valor.</p>\n<pre><code class=\"language-js\">(function () {\n  const PI;\n  PI = 3.15;\n  // Dará ERROR, ya que ha de asignarse un valor en la declaración\n})();\n</code></pre>\n<p>Pero, ¿qué pasa cuando la variable no se asigna a un valor, sino a un objeto?\nVeámoslo con un ejemplo:</p>\n<pre><code class=\"language-js\">const USER = {\n  name: 'Caro',\n  surname: 'Covarrubias',\n  age: 20\n};\n\n/**\n * La siguiente sentencia funciona, ya que estamos modificando una propiedad\n * del objeto, pero no el valor en sí, que es la referencia al objeto, la cual\n * no cambia.\n **/\nUSER.name = 'Joan';\n\nUSER.age = 'veinte'; // modificar el tipo de una propiedad también funciona\n\nconsole.log(USER); // {name: 'Joan', surname: 'Covarrubias', age: 'veinte'}\n\n// Si tratamos de asignar un nuevo valor a `USER` veremos un error\nUSER = 'Caro Covarrubias'; // Error, no esta permitido\n</code></pre>"
            },
            "pt": {
              "title": "Variáveis",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Aprender o que são <em>variáveis</em> e sua utilidade.</li>\n<li>Conhecer as boas práticas de nomeação de variáveis.</li>\n</ul>\n<hr>\n<p>O texto a continuação se baseia principalmente, com algumas modificações, no\ncapítulo 2 de <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn\nHaverbeke, 2014. Tradução em\n<a href=\"https://github.com/braziljs/eloquente-javascript/blob/master/chapters/01-valores-tipos-operadores.md\">Português</a>.</p>\n<h2>Variáveis</h2>\n<p>Você já conhece os tipos de dados mais frequentes no JavaScript. Você consegue\ncriar, combinar e transformar <code>numbers</code>, <code>strings</code> e <code>booleans</code>. Mas, o que\npodemos fazer com isso? Até agora, tudo o que foi trabalhado tem sido para uso\nimediato. Ou seja, os novos valores que geramos devem ser imediatamente\nutilizados ou se perdem. Segue no seu console o seguinte exemplo:</p>\n<pre><code class=\"language-js\">'Oi, meu nome é ' + 'Michelle' + ' e tenho ' + 19 + ' anos';\n// returns: \"Oi, meu nome é Michelle e tenho 19 anos\"\n</code></pre>\n<p>Se quisesse utilizar esse <code>string</code> de novo, talvez porque Michelle fez\naniversário e agora queremos que apareça 20 anos no lugar de 19, não poderíamos\nfazê-lo. O valor foi perdido.</p>\n<p>Para capturar e manter os valores, o JavaScript fornece algo chamado <code>variável</code>.\nÉ utilizada assim:</p>\n<pre><code class=\"language-js\">var age = 19;\n// returns: undefined\n</code></pre>\n<p>A palavra chave (<em>keyword</em>) <code>var</code> indica que esta frase irá definir uma\nvariável. É seguida pelo nome da variável (o nome <em>age</em>) e, se queremos atribuir\nimediatamente um valor, é seguido do operador <code>=</code> e uma expressão (o número 19).</p>\n<hr>\n<p>NOTA: Neste primeiro exemplo usamos\n<a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/var\"><code>var</code></a>,\nque nos dias de hoje é considerada uma forma antiquada de declarar variáveis.\nDesdo ES6 (ES2015), preferimos usar a\n<a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/let\"><code>let</code></a>\n(para declarar variáveis que vamos necessitar <em>reatribriuir</em> um valor diferente)\nou a\n<a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/const\"><code>const</code></a>\n(para declarar variáveis que não vamos reatribuir), ambas variáveis possuem\nescopo de bloco, como veremos mais a frente.</p>\n<hr>\n<p>A declaração anterior cria uma variável chamada <code>age</code> (ou idade no português) e\né usada para reter o número <code>19</code>. A console devolve <code>undefined</code>, mas não pense\nque é um erro. É o que o JavaScript faz quando um comando não devolve nenhum\nvalor. Quando você escreve <code>12 + 5</code>, o console devolve <code>17</code>. Mas ao declarar uma\nvariável chamada age atribuindo o valor <code>19</code>, não há um valor fornecido. É por\nisso que a console simplesmente devolve <code>undefined</code> (no restante dos exemplos\nvamos a omitir esse <code>undefined</code> devolvido porque não adiciona muito valor na\nexplicação).</p>\n<p>Depois que uma variável tem sido definida, o nome dela pode ser usada como uma\n<em>expressão</em>. O valor da expressão é o valor que a variável contém atualmente.\nContinuemos com o exemplo anterior:</p>\n<pre><code class=\"language-js\">// declaramos `age` usando `const` ja que não vamos reatribuir está variável.\nconst age = 19;\n'Oi, meu nome é' + 'Rafael' + 'e tenho' + age + 'anos';\n// returns \"Oi, meu nome é Rafael e tenho 19 anos\"\n</code></pre>\n<p>O console nos ajuda a saber o valor de uma variável. Se escrevemos o nome de uma\nvariável que foi declarada no console, nos devolve seu valor. Se essa variável\nnão foi declarada, o console devolve um erro. E se a variável foi declarada, mas\nnão foi atribuído nenhum valor, o console devolve <code>undefined</code>.</p>\n<pre><code class=\"language-js\">age\n// returns Uncaught ReferenceError: age is not defined\n//           at &#x3C;anonymous>:1:1\n\nconst age = 19;\nage\n// returns 19\n\nlet weight;\nweight\n// returns undefined\n</code></pre>\n<p>Quando uma variável aponta para um valor, não quer dizer que está ligada a esse\nvalor para sempre. De fato, são chamadas de variáveis porque seu valor pode\nmudar. O operador <code>=</code> pode ser utilizado em qualquer momento em variáveis\nexistentes (declaradas com <code>let</code> ou <code>var</code>)para desconectá-las do seu valor atual\ne ser apontadas para um novo. (valores declarados em <code>const</code> não podem ser\nalterados).</p>\n<pre><code class=\"language-js\">let age = 19;\n// returns undefined\nage = 24;\n// returns 24\n'Oi, meu nome é' + 'Rafael' + 'e tenho' + age + 'anos';\n// returns \"Oi, meu nome é Rafael e tenho 24 anos\"\n</code></pre>\n<p>Leve em consideração que para atribuir um novo valor, você não tem que utilizar\na <em>keyword</em> <code>var</code> ou <code>let</code> novamente. Você só utiliza ela quando precisa <em>criar</em>\nnovas variáveis.</p>\n<p>Muitas vezes é explicado o conceito de variáveis com a analogia de uma caixa: as\nvariáveis são como \"caixa\" nas quais você pode colocar algum valor que depois\npode mudar por outro. Contudo, uma analogia mais fiel é pensar nas variáveis\ncomo sendo <strong>tentáculos</strong>. As variáveis realmente não \"contém\" os valores (como\numa caixa); mas apenas os segura (como um tentáculo). De fato, duas variáveis\npodem se referir a um mesmo valor. Um programa pode acessar apenas os valores\nque ainda mantém \"segurados\". Quando você precisa lembrar algo, você cria um\nnovo tentáculo para \"segurá-lo\" ou muda um dos tentáculos existentes para\nsegurar o novo.</p>\n<h2>Nomeando Variáveis</h2>\n<p>No JavaScript, existem certas regras para nomear variáveis. Os nomes das\nvariáveis:</p>\n<ol>\n<li><strong>Não</strong> podem incluir espaços</li>\n<li><strong>Não</strong> podem ser palavras reservadas (ou <em>keywords</em>), como a palavra <code>var</code></li>\n<li><strong>Não</strong> podem começar com números, ainda que podem haver números dentro do\nnome (só não pode no início)</li>\n<li><strong>Não</strong> podem conter sinais de pontuação, salvo os símbolos <code>$</code> e <code>_</code></li>\n</ol>\n<p>Não respeitar alguma das regras anteriores produz um erro por parte do\nJavaScript.</p>\n<p>Além dessas regras, existem uma série de \"sugestões\" que você deve levar em\nconsideração na hora de nomear variáveis. São \"sugestões\" porque o JavaScript\nnão devolve nenhum erro se você não as segue. Porém, são \"boas práticas\" de\nescrita de código que fazem com que seu trabalho seja de melhor qualidade. As\nsugestões são:</p>\n<ol>\n<li>Convenção <em>CamelCase</em>. Já que não é possível incluir espaços nos nomes das\nvariáveis, uma convenção utilizada é a de <code>CamelCase</code>. A convenção determina\nque o nome da variável começa com uma letra minúscula e são colocadas em\nmaiúscula a primeira letra das palavras que continuam. Por exemplo:\n<code>numberOfCandies</code> ou <code>studentTechScore</code>. É chamada <em>CamelCase</em> porque\naparenta a corcova do camelo.</li>\n<li>Utilizar nomes em inglês. A programação está baseada no inglês, dessa forma é\numa boa prática que esteja acostumado a escrever seu código em inglês.</li>\n<li>Utilizar nomes descritivos. Assim como as outras sugestões, algo que você\nsempre tem que considerar é que outras pessoas irão ler seu código e você\ndeve fazer o esforço para utilizar nomes descritivos que ajudem o leitor a\nentender melhor o que seu programa faz.</li>\n</ol>\n<p>Vamos ver alguns exemplos:</p>\n<p>| Nome ruim | Problema | Nome melhor\n| ------------| -------- | ------------\n| age of fiends | Erro: contém espaços | ageOfFriends\n| null | Erro: palavra chave (keyword) | empty\n| 1stName | Erro: começa com número | firstName\n| full.price | Erro: contém \".\" | fullPrice\n| full_price | não usa CamelCase | fullPrice\n| x | não é descritivo | age\n| altura | em português | height</p>\n<h2>Aumentar e Diminuir</h2>\n<p>Como programadora, muitas vezes você terá que aumentar ou diminuir o valor de\numa variável numérica por um outro valor. Por exemplo, pode ser que você tenha a\nvariável <code>score</code> que registra a pontuação num jogo de futebol. Toda vez que\nalguém faz um gol, a variável <code>score</code> deve aumentar em 1. Você consegue fazer\nisso da seguinte forma:</p>\n<pre><code class=\"language-js\">let score = 0;\nscore = score + 1;\nscore;\n// returns 1\n</code></pre>\n<p>Isso pode ser escrito de uma forma mais simples:</p>\n<pre><code class=\"language-js\">let score = 0;\nscore++;\nscore;\n// returns 1\n</code></pre>\n<p>O mesmo pode ser feito para diminuir o valor de uma variável. Por exemplo, num\nvideogame você pode precisar de uma variável chamada <code>lifePoints</code> que registra\nos \"pontos de vida\" de um jogador. O jogador parte com 100 pontos e cada vez que\num inimigo bate nele, perde 25 pontos. Cada vez que bebe um refrigerante\nrecupera 10 pontos.</p>\n<pre><code class=\"language-js\">let lifePoints = 100;\nlifePoints = lifePoints - 25;\nlifePoints\n// returns 75\n\nlifePoints = lifePoints + 10;\nlifePoints\n// returns 85\n</code></pre>\n<p>Isso pode ser escrito de forma reduzida, assim:</p>\n<pre><code class=\"language-js\">let lifePoints = 100;\nlifePoints -= 25;\nlifePoints\n// returns 75\n\nlifePoints += 10;\nlifePoints\n// returns 85\n</code></pre>\n<p>Existem outros operadores similares a <code>+=</code> e <code>-=</code>. Por exemplo, existem também\n<code>*=</code> e <code>/=</code>:</p>\n<pre><code class=\"language-js\">let balloons = 100;\nballoons *= 2;\nballoons\n// returns 200\n\nlet balloons = 100;\nballoons /= 4;\nballoons\n// returns 25\n</code></pre>\n<h2>O escopo de uma variável</h2>\n<p>O <em>escopo</em> de uma variável é o local onde ela pode ser encontrada. Por exemplo:</p>\n<pre><code class=\"language-js\">const foo = () => {\n  let x;\n}\n</code></pre>\n<p>Aqui, o <em>direct scope</em> (escopo direto) de <code>x</code> é a função <code>foo</code>. Esta variável\npoderá ser acessada apenas dentro do corpo da função <code>foo</code>, mas não fora dela.</p>\n<p>Normalmente, no JavaScript podíamos apenas criar um novo escopo quando criávamos\numa nova função. Mas desde a atualização do ES6 (ES2015) temos a <code>let</code> e a\n<code>const</code>, que introduziram o conceito de <em>block scope</em> no JavaScript.</p>\n<h3>Lexical scoping</h3>\n<p>As variáveis no JavaScript são <em>lexically scoped</em> (de escopo léxico), o que\nsignifica que a estrutura estática do programa determina o escopo da variável,\nque dizer que não é influenciada pelo local onde a função é chamada. Em palavras\nmais simples, significa que as variáveis declarada dentro de um <em>escopo</em> (uma\nfunção, ou um bloco indicado pelos caracteres <code>{}</code> no caso da <code>let</code> e <code>const</code>),\nnão são visíveis fora desse <em>escopo</em>.</p>\n<h3>Nested Scopes (escopos aninhados)</h3>\n<p>Se o escopo está aninhado dentro de um escopo direto de uma variável, a\nvariável será acessível a todos os escopos:</p>\n<pre><code class=\"language-js\">function foo(arg) {\n  function bar() {\n    console.log(`arg: ${arg}`);\n  }\n  bar();\n}\n\nconsole.log(foo('hello')); // arg: hello\n</code></pre>\n<p>O escopo direto de <code>arg</code> é <code>foo</code>, mas também é acessível no escopo aninhado\n<code>bar</code>. Com respeito ao aninhamento, <code>foo</code> é um <em>outer scope</em> (escopo externo) e\n<code>bar</code> é um <em>inner scope</em> (escopo interno).</p>\n<h3>Shadowing (sombra)</h3>\n<p>Sim, é possível declarar uma variável que tem o mesmo nome em um escopo interno\nde uma função, com isso o acesso a variável externa é bloqueado no escopo\ninterno e todo os escopos aninhados dentro dela. Mudanças nas variáveis internas\nnão afetam a variável externa, a qual é acessível fora do escopo interno.\nExemplo:</p>\n<pre><code class=\"language-js\">let x = 'global';\nfunction f() {\n  let x = 'local';\n  console.log(x); // local\n}\nf();\nconsole.log(x); // global\n</code></pre>\n<p>Dentro da função <code>f</code>, a variável <code>x</code> é \"sombreada\" pela variável local <code>x</code>.</p>\n<hr>\n<h2>Diferença entre contexto e alcance</h2>\n<p>Cada invocação de função tem um certo alcance com o contexto associado a ela.\nFundamentalmente, o alcance é um conceito associado a funções enquanto que o\ncontexto é associado ao objeto. Em outras palavras, o alcance se refere a\nacessibilidade de variável de uma função quando é chamada e é única para cada\ninvocação. Em contraste, o contexto é sempre o mesmo valor chamado de <code>this</code>\ncuja a referência é sempre o objecto que está executando o código.</p>\n<h3>Alcance de variáveis</h3>\n<p>As variáveis podem ser declaradas com <strong>alcance local</strong> ou <strong>alcance global</strong>, o\nqual estabelece a sua acessibilidade de diferentes alcances no tempo de\nexecução. Qualquer variável definida como global será acessível no tempo de\nexecução em qualquer alcance, desde que tenha sido declarado fora do corpo de um\nfunção.</p>\n<p>Em contraste, as variáveis locais existem somente dentro do corpo de uma função\nou bloco. O alcance local de uma variável é somente definida a partir do corpo\nde uma função ou bloco que a contenha.</p>\n<h2>Declaração de variáveis no escopo local com \"let\"\"</h2>\n<p>A \"palavra\" <code>let</code> declara uma variável de alcance local, a qual, opcionalmente,\npode  ser inicializada com algum valor e permite ser reatribuída (diferente de\n<code>const</code>).</p>\n<p>O alcance da <code>let</code> é local ao bloco, a declaração ou expressão onde se está\nusando. O que diferencia a palavra <code>let</code> da palavra <code>var</code>, a qual defini a\nvariável global ou local em uma função sem se importar com o escopo de bloco.</p>\n<p>Vejamos alguns exemplos:</p>\n<pre><code class=\"language-js\">if (x > y) {\n  let gamma = 12.7 + y;\n  i = gamma * x;\n}\n</code></pre>\n<p>No exemplo a cima, <code>gama</code> existe apenas dentro do escopo do <code>if</code>.</p>\n<pre><code class=\"language-js\">for (let i = 0; i &#x3C; students.length; i++) {\n  console.log(students[i].name);\n}\n</code></pre>\n<p>Podemos utilizar <code>let</code> para que a variável seja local ao escopo do laço <code>for</code>.\nSe em seu lugar usássemos <code>var</code>, a variável seria visível em toda a função\ndentro do laço.</p>\n<pre><code class=\"language-js\">(function () {\n  if (true) {\n    let x = 'Olá mundo';\n  }\n  console.log(x);\n  // Dá error, porque \"x\" foi definida dentro de \"if\"\n})();\n</code></pre>\n<p>No exemplo, <code>console.log(x)</code> não tem acesso a <code>let x = \"Olá mundo\"</code> e da erro\nporque <code>x</code> foi declarado dentro do laço <code>if</code>.</p>\n<p>No seguinte exemplo o console imprime <code>Olá Ju</code>, ja que a variável <code>x</code> no bloco\ndo <code>if</code> se mantém dentro do seu escopo.</p>\n<pre><code class=\"language-js\">(function () {\n  let x = 'Olá Ju';\n\n  if (true) {\n    let x = 'Olá Palomita';\n  }\n  console.log(x);\n  // Imprime Olá Ju\n})();\n</code></pre>\n<h2>Variáveis não reatribuídas com \"const\"</h2>\n<p>As variáveis somente de leitura são outra novidade do ECMAScript 6, com a\nintrodução da nova palavra reservada <code>const</code>. Qualquer variável declarada como\nconstante não poderá ser reatribuída.</p>\n<p>Vejamos o exemplo:</p>\n<pre><code class=\"language-js\">(function () {\n  const hello = 'hello world';\n  hello = 'Olá mundo';\n  // Acontecerá um ERROR, já que `hello` não pode ser reatribuído\n})();\n</code></pre>\n<p>Neste exemplo vemos que desde o momento que declaramos a constante <code>hello</code>, seu\nvalor foi blindado e o interpretado lançará um erro quanto tentar reatribuir um\nnovo valor.</p>\n<pre><code class=\"language-js\">(function () {\n  const PI;\n  PI = 3.15;\n  // Acontecerá um ERROR, já que tentamos alterar o valor de `PI`, mesmo ele não\n  // tendo valor\n})();\n</code></pre>\n<p>Mas, o que acontece quando o valor de uma variável é um objeto, ou array?</p>\n<pre><code class=\"language-js\">const user = {\n  name: 'Adriana',\n  surname: 'Arantes',\n  age: 60\n};\n\n/**\n * A seguinte sentença funciona, pois estamos modificando a propriedade do\n * objeto, e não o valor em si, que é a referência do objeto, a qual não é\n * alterada.\n **/\n\nuser.name = 'João';\n\nuser.age = 'trinta'; // alterar o tipo de uma propriedade também funciona\n\nconsole.log(user); // {name: 'João', surname: 'Arantes', age: 'trinta'}\n\n// Mas se atribuímos um novo valor para `user` vemos um erro\nuser = 'Caro Covarrubias'; // Erro, não é permitido\n</code></pre>"
            }
          }
        },
        {
          "prefix": "03",
          "slug": "comments",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Comentarios",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Aprender qué son los <em>comentarios</em> y su utilidad.</li>\n</ul>\n<hr>\n<h2>Comentarios</h2>\n<p>Muchas veces, por más descriptivo que escribas tu código, es necesario brindar\nmás información para que otras personas puedan entender fácilmente cómo funciona\ntu programa. Para añadir esa información sin afectar el flujo de tu código,\nexisten los <em>comentarios</em>.</p>\n<p>Se visualizan así:</p>\n<pre><code class=\"language-js\">// Esto es un comentario de una línea\n\n/*\n  Esto es un comentario de\n  múltiples\n  líneas\n*/\n</code></pre>\n<p>La computadora ignora los comentarios por completo. Los comentarios en\nJavaScript empiezan con <code>//</code>. Todo lo que sigue a las barras diagonales (en la\nmisma línea) es ignorado por el intérprete de JavaScript. Los comentarios de\nmúltiples líneas empiezan con <code>/*</code> y cierran con <code>*/</code>. Todo lo que está entre\neso es ignorado por el programa.</p>\n<p>De tal manera, los comentarios no tienen efecto alguno sobre cómo un programa se\nejecuta. Solo están allí para proporcionar contexto. Es una <strong>buena práctica</strong>\nincluir comentarios en el código para mejorar su legibilidad.</p>\n<h2>Comentarios como sugerencias o instrucciones</h2>\n<p>Muchos de los ejercicios y quizzes en este curso van a incluir comentarios para\ndarte sugerencias o instrucciones.</p>\n<p>Por ejemplo, es común ver algo como:</p>\n<pre><code class=\"language-js\">const firstName = // tu código aquí\nconsole.log(/* tu código aquí */);\n</code></pre>\n<p>La idea es que borres el comentario y utilices ese espacio para escribir tu\ncódigo. No te preocupes por borrar los comentarios. Eso sí, <strong>no</strong> borres otras\npartes del programa. Si lo haces, es muy probable que no te funcione muy bien.</p>\n<p>Ahora sí, continúa con los ejercicios y quizzes de esta lección. ¡Mucha suerte!</p>"
            },
            "pt": {
              "title": "Comentários",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Aprender o que são os <em>comentários</em> e sua utilidade.</li>\n</ul>\n<hr>\n<h2>Comentários</h2>\n<p>Muitas vezes, não importa quão descritivo você escreva seu código, é necessário\noferecer mais informação para que outras pessoas possam entender facilmente como\nfunciona o seu programa. Para adicionar essa informação sem afetar o fluxo do\nseu código, existem os <em>comentários</em>.</p>\n<p>Eles são assim:</p>\n<pre><code class=\"language-js\">// Isto é um comentário de uma linha\n\n/*\n  Isto é um comentário de\n  múltiplas\n  linhas\n*/\n</code></pre>\n<p>O computador ignora os comentários completamente. Os comentários no JavaScript\ncomeçam com <code>//</code>. Tudo o que segue às barras comuns (na mesma linha) é ignorado\npelo interpretador do JavaScript. Os comentários de múltiplas linhas começam com\n<code>/*</code> e acabam com <code>*/</code>. Tudo o que fica entre isso é ignorado pelo programa.</p>\n<p>Dessa forma, os comentários não têm efeito algum em como se executa o programa.\nSó estão aí para prover contexto. É uma <strong>boa prática</strong> incluir comentários no\ncódigo para melhorar sua legibilidade.</p>\n<h2>Comentários como sugestões ou instruções</h2>\n<p>Muitos dos exercícios e questionários neste curso vão incluir os comentários\npara oferecer sugestões ou instruções.</p>\n<p>Por exemplo, é normal ver algo tipo:</p>\n<pre><code class=\"language-js\">const firstName = // seu código aqui\nconsole.log(/* seu código aqui */);\n</code></pre>\n<p>A ideia é que você apague o comentário e utilize esse espaço para escrever seu\ncódigo. Não se preocupe em apagar os comentários. Aliás, <strong>não</strong> apague outras\npartes do programa. Se você faz isso, é muito provável que não funcione muito\nbem.</p>\n<p>Agora sim, continue com os exercícios e questionários desta lição. Boa sorte!</p>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "guided-exercises",
          "type": "practice",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Ejercicios Guiados",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Solidificar los conceptos de variables y tipos de datos resolviendo ejercicios\nprácticos.</li>\n<li>Darte una perspectiva de las cosas que puedes crear con lo que acabas de\naprender.</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Ahora que ya conoces ciertos conceptos base de la programación, es hora de que\nveas las cosas que puedes crear en la práctica.</p>\n<p>Los proyectos a crear son:</p>\n<ol>\n<li><strong>Edad en segundos</strong>: Crea una web que pida al usuario su edad en años,\nutilizando <code>prompt()</code>, y devuelva su edad <strong>en segundos</strong>, utilizando\n<code>document.write()</code>.</li>\n<li><strong>Convertidor de temperatura</strong>: Crea una página web que pida al usuario la\ntemperatura en grados Celsius (°C), utilizando <code>prompt()</code>, y devuelva, en la\nconsola, la temperatura en grados Farenheit (°F) utilizando <code>console.log()</code>.\nLa fórmula matemática para pasar de °C a °F es: <code>T(°F) = ( T(°C) × 1.8 ) + 32</code>.</li>\n<li><strong>Ganancias y pérdidas</strong>: Crea un programa que pide los ingresos, los costos\ny el % de impuestos, y calcula la ganancia después de impuestos. Debe\nimprimir el resultado en la web con el símbolo $ adelante.</li>\n<li><strong>Iniciales</strong>: Crea un programa que pide el nombre y apellido al usuario. El\nusuario debe ingresar dos palabras separadas por un espacio, por ejemplo:\n\"Ana Martinez\". El programa debe devolver las iniciales <strong>en mayúsculas</strong>.\nVeamos unos ejemplos: \"ana martinez\" y \"Ana Martinez\" devuelven las iniciales\n\"AM\". \"Michelle Seguil\" y \"michelle seguil\" devuelven \"MS\".</li>\n</ol>\n<hr>\n<h2>Solucionarios</h2>\n<p>A continuación, Michelle te explica cómo resolvió cada uno de los ejercicios\nanteriores.</p>\n<blockquote>\n<p>NOTA: En los siguientes videos Michelle hace uso de <code>var</code> en vez de <code>let</code> y\n<code>const</code> para declarar variables, así como otras <em>características</em> un poco\n<em>antiguas</em> de JavaScript. Estas son válidas y parte del lenguaje, aunque hoy\nen día preferiríamos usar <em>características/features</em> más modernos y apropiados\ncomo es el caso de <code>let</code> y <code>const</code>. En este caso estos videos se grabaron hace\nya un tiempo... ;-)</p>\n</blockquote>\n<h3>1. Edad en segundos</h3>\n<p><a href=\"https://www.youtube.com/watch?v=1IZT_7EfRMw\"><img src=\"https://i.ytimg.com/vi/1IZT_7EfRMw/0.jpg\" alt=\"Solution Age in Seconds\"></a></p>\n<h3>2. Convertidor de temperatura</h3>\n<p><a href=\"https://www.youtube.com/watch?v=Ix6VLiBcABw\"><img src=\"https://i.ytimg.com/vi/Ix6VLiBcABw/0.jpg\" alt=\"Solution Temperature converter\"></a></p>\n<h3>3. Ganancias y pérdidas</h3>\n<p><a href=\"https://www.youtube.com/watch?v=2WtBw8eC0us\"><img src=\"https://i.ytimg.com/vi/2WtBw8eC0us/0.jpg\" alt=\"Solution Earnings and loses\"></a></p>\n<h3>4. Iniciales</h3>\n<p><a href=\"https://www.youtube.com/watch?v=E5ozw3b6iM4\"><img src=\"https://i.ytimg.com/vi/E5ozw3b6iM4/0.jpg\" alt=\"Solution Initials\"></a></p>"
            },
            "pt": {
              "title": "Exercícios Livres",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Solidificar os conceitos de variáveis e tipos de dados resolvendo exercícios\npráticos.</li>\n<li>Dar uma perspectiva das coisas que você pode criar com o que você acaba de\naprender.</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Agora que você já conhece certos conceitos básicos da programação, é hora de\nvocê ver na prática as coisas que você consegue criar. Não é um teste , mas é\nsuper importante você praticar!! Os projetos a criar são:</p>\n<ol>\n<li><strong>Idade em segundos</strong>: Crie um site que peça ao usuário a idade dele em anos,\nutilizando <code>prompt()</code>, e devolva a idade <strong>em segundos</strong>, utilizando\n<code>document.write()</code>.</li>\n<li><strong>Conversor de temperatura</strong>:Crie um site que peça ao usuário a temperatura\nem graus Celsius (°C), utilizando <code>prompt()</code>, e devolva, no console, a\ntemperatura em graus Farenheit (°F) utilizando <code>console.log()</code>. A fórmula\nmatemática para converter de °C a °F é: <code>T(°F) = ( T(°C) × 1.8 ) + 32</code>.</li>\n<li><strong>Ganhos e perdas</strong>: Crie um programa que peça os ingressos, os custos e o %\nde impostos, e calcule o ganho depois de impostos. Deve imprimir o resultado\nno site com o símbolo $ na frente.</li>\n<li><strong>Iniciais</strong>: Crie um programa que peça o nome e sobrenome do usuário. O\nusuário deve introduzir duas palavras separadas por um espaço, por exemplo:\n\"Ana Martinez\". O programa deve devolver as iniciais <strong>em maiúsculas</strong>. Vamos\nver alguns exemplos: \"ana martinez\" e \"Ana Martinez\" devolvem as iniciais\n\"AM\". \"Michelle Seguil\" e \"michelle seguil\" devolvem \"MS\".</li>\n</ol>\n<hr>\n<h2>Soluções</h2>\n<p>A seguir, Thaissa te explica como resolveu cada um dos exercícios anteriores.</p>\n<blockquote>\n<p>NOTA: Nos vídeos a seguir, Thaissa usa <code>var</code> ao invés de <code>let</code> e <code>const</code> para\ndeclarar variáveis, bem como outros <em>recursos</em> um pouco antigos de JavaScript.\nEles são válidos e fazem parte da linguagem, mas hoje em dia preferimos usar\n<em>recursos/features</em> mais modernos e adequados como é o caso de <code>let</code> e\n<code>const</code>. Nesse caso, esses vídeos foram gravados já faz um tempo... ;-)</p>\n</blockquote>\n<h3>1.  Idade em segundos</h3>\n<p><a href=\"https://laboratoria.wistia.com/medias/a9x43umo91?wvideo=a9x43umo91\"><img src=\"https://embed-ssl.wistia.com/deliveries/9d6c875fd50f8b845f6f6e8ec6ca2d471c6a49ff.jpg?image_play_button_size=2x&#x26;image_crop_resized=960x540&#x26;image_play_button=1&#x26;image_play_button_color=f7b617e0\" alt=\"Solution Age in\nSeconds\"></a></p>\n<h3>2. Conversor de temperatura</h3>\n<p><a href=\"https://laboratoria.wistia.com/medias/ri4tobcdz5?wvideo=ri4tobcdz5\"><img src=\"https://embed-ssl.wistia.com/deliveries/326565ee59de640f72cba3b9b227ef62d0a1b15a.jpg?image_play_button_size=2x&#x26;image_crop_resized=960x540&#x26;image_play_button=1&#x26;image_play_button_color=f7b617e0\" alt=\"Solution Temperature\nconverter\"></a></p>\n<h3>3. Ganhos e perdas</h3>\n<p><a href=\"https://laboratoria.wistia.com/medias/r92tdew4i6?wvideo=r92tdew4i6\"><img src=\"https://embed-ssl.wistia.com/deliveries/6cb92e318311cf2c730164f665c3ea4c5e0e7749.jpg?image_play_button_size=2x&#x26;image_crop_resized=960x540&#x26;image_play_button=1&#x26;image_play_button_color=f7b617e0\" alt=\"Solution Earnings and\nloses\"></a></p>\n<h3>4. Iniciais</h3>\n<p><a href=\"https://laboratoria.wistia.com/medias/cn7vfs5x1e?wvideo=cn7vfs5x1e\"><img src=\"https://embed-ssl.wistia.com/deliveries/5bbc757fbad4eb09b79aa261a502e815c0a3c983.jpg?image_play_button_size=2x&#x26;image_crop_resized=960x540&#x26;image_play_button=1&#x26;image_play_button_color=f7b617e0\" alt=\"Solution\nInitials\"></a></p>"
            }
          },
          "challenges": []
        },
        {
          "prefix": "06",
          "slug": "exercises",
          "type": "practice",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Ejercicios",
              "body": ""
            },
            "pt": {
              "title": "Exercícios",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "coin-convert",
              "prefix": "01",
              "path": "topics/javascript/01-basics/06-exercises/01-coin-convert",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Conversor de Moneda",
                  "body": "<p>En este ejercicio nos concentraremos en asignar <em>valores</em> en <em>variables</em>. El\nejercicio ya incluye un <em>boilerplate</em> (<em>plantilla</em>), con una <em>función</em>, dentro\nde la cual tendrás que re-emplazar los <em>comentarios</em> <code>/* ??? */</code> por\n<em>expresiones</em> que produzcan el <em>valor</em> que queremos almacenar (<em>asignar</em>) en\nla <em>variable</em> correspondiente.</p>\n<p>El <em>boilerplate</em> (<em>plantilla</em>):</p>\n<pre><code class=\"language-js\">const coinConvert = (dollars) => {\n  // Asigna el monto equivalente en soles\n  const soles = /* ??? */;\n\n  // Asigna el monto equivalente en pesos mexicanos\n  const pesosMexicanos = /* ??? */;\n\n  // Asigna el monto equivalente en pesos chilenos\n  const pesosChilenos = /* ??? */;\n\n  return [soles, pesosMexicanos, pesosChilenos];\n};\n</code></pre>\n<p>La <em>función</em> del ejercicio se llama <code>coinConvert</code> y nos permitirá convertir una\ncantidad en dólares a 3 monedas diferentes (soles, pesos mexicanos y pesos\nchilenos).</p>\n<p>Esta <em>función</em> solo recibirá un <em>argumento</em> (<code>dollars</code>), que es un <em>número</em> que\nrepresenta una cantidad en dólares, y retornará un <em>arreglo</em> (<em>array</em>) con tres\nvalores: la cantidad en soles, pesos mexicanos y pesos chilenos. Por ahora no\nnos tenemos que preocupar sobre la <em>función</em> en sí o cómo retornar un <em>arreglo</em>,\nel <em>boilerplate</em>, ya se encarga de eso. Tú solo debes concentrarte en usar\n<code>dollars</code> junto con una operación para crear los valores que queremos asignar en\nlas variables <code>soles</code>, <code>pesosMexicanos</code> y <code>pesosChilenos</code>.</p>\n<p>Utiliza las siguientes tasas de cambio:</p>\n<pre><code class=\"language-text\">1 dólar = 3.25 soles peruanos\n1 dólar = 18 pesos mexicanos\n1 dólar = 660 pesos chilenos\n</code></pre>\n<p>¡Mucha suerte!</p>"
                },
                "pt": {
                  "title": "Conversor de Moeda",
                  "body": "<p>Neste exercício vamos nos concentrar em atribuir <em>valores</em> em <em>variáveis</em>. O\nexercício já inclui um <em>boilerplate</em> (<em>modelo</em>), com uma <em>função</em>, dentro da qual\nvocê terá que substituir os <em>comentário</em> <code>/* ??? */</code> por <em>expressões</em> que produzam\no <em>valor</em> que queremos armazenar (<em>atribuir</em>) na variável correspondente.</p>\n<p>O <em>boilerplate</em> (<em>modelo</em>):</p>\n<pre><code class=\"language-js\">const coinConvert = (dollars) => {\n  // Atribuir o valor equivalente em soles\n  const soles = /* ??? */;\n\n  // Atribuir o valor equivalente em pesos mexicanos\n  const pesosMexicanos = /* ??? */;\n\n  // Atribuir o valor equivalente em pesos chilenos\n  const pesosChilenos = /* ??? */;\n\n  return [soles, pesosMexicanos, pesosChilenos];\n};\n</code></pre>\n<p>A <em>função</em> do exercício se chama <code>coinConvert</code> e irá nos permitir converter uma\nquantidade de dólares em 3 moedas diferentes (soles, pesos mexicanos e pesos\nchilenos).</p>\n<p>Está <em>função</em> irá receber apenas um <em>argumento</em> (<code>dollars</code>), que é um <em>número</em>\nque representa um valor em dólares, e irá retornar um <em>array</em> com três valores: a\nquantidade em soles, pesos mexicanos e pesos chilenos. Por enquanto, não\nprecisamos nos preocupar com a <em>função</em> em si ou como retornar um <em>array</em>, o\n<em>boilerplate</em>, já está fazendo isso. Você deve se concentrar em usar a variável\n<code>dollars</code> junto com a operação para criar os valores que queremos atribuir nas\nvariáveis <code>soles</code>, <code>pesosMexicanos</code> e <code>pesosChilenos</code>.</p>\n<p>Utilize as seguintes taxas de câmbio:</p>\n<pre><code class=\"language-text\">1 dólar = 3.25 soles\n1 dólar = 18 pesos mexicanos\n1 dólar = 660 pesos chilenos\n</code></pre>\n<p>Boa sorte!</p>"
                }
              },
              "files": {
                "/boilerplate/coinConvert.js": "const coinConvert = (dollars) => {\n  const soles = /* ??? */;\n  const pesosMexicanos = /* ??? */;\n  const pesosChilenos = /* ??? */;\n\n  return [soles, pesosMexicanos, pesosChilenos];\n};\n\nmodule.exports = coinConvert;\n",
                "/solution/coinConvert.js": "const coinConvert = (dollars) => {\n  const soles = dollars * 3.25;\n  const pesosMexicanos = dollars * 18;\n  const pesosChilenos = dollars * 660;\n\n  return [soles, pesosMexicanos, pesosChilenos];\n};\n\nmodule.exports = coinConvert;\n",
                "/test/coinConvert.spec.js": "const Assert = require('chai').assert;\nconst coinConvert = require('../solution/coinConvert');\n\ndescribe('coinConvert()', () => {\n  it('debería retornar [162.5, 900, 33000], para $50', () => {\n    const dollars = 50;\n    const soles = dollars * 3.25;\n    const pesosMx = dollars * 18;\n    const pesosCl = dollars * 660;\n    Assert.deepEqual(coinConvert(dollars), [soles, pesosMx, pesosCl]);\n  });\n\n  it('debería retornar [325, 1800, 66000], para $100', () => {\n    const dollars = 100;\n    const soles = dollars * 3.25;\n    const pesosMx = dollars * 18;\n    const pesosCl = dollars * 660;\n    Assert.deepEqual(coinConvert(dollars), [soles, pesosMx, pesosCl]);\n  });\n\n  it('debería retornar [243.75, 1350, 49500], para  $85', () => {\n    const dollars = 85;\n    const soles = dollars * 3.25;\n    const pesosMx = dollars * 18;\n    const pesosCl = dollars * 660;\n    Assert.deepEqual(coinConvert(dollars), [soles, pesosMx, pesosCl]);\n  });\n});\n"
              }
            },
            {
              "slug": "restaurant-bill",
              "prefix": "02",
              "path": "topics/javascript/01-basics/06-exercises/02-restaurant-bill",
              "createdAt": "2024-02-08T16:56:33.609Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Cuenta de restaurante",
                  "body": "<p>Imagina que has salido a comer con tus cuatro mejores amigas.  La cuenta total\ndel consumo es de 50 dólares, pero a eso debes agregarle el 10% de Impuesto al\nValor Agregado (IVA). Quieres dividir la cuenta equitativamente entre las cinco.\nPara eso vamos a crear este programa.</p>\n<p>El ejercicio incluye un <em>boilerplate</em> (<em>plantilla</em>) que ya incluye una función\n(<code>restaurantBill</code>), la cual espera recibir un <em>argumento</em> (<code>bill</code>) con el monto\nde la cuenta antes de impuestos (un <em>número</em>), y espera que retornemos un\n<em>string</em> con la cantidad que le toca pagar a cada una ya teniendo en cuenta el\n10% de impuestos (e incluyendo el símbolo de dólar).</p>\n<p>El <em>boilerplate</em> (<em>plantilla</em>):</p>\n<pre><code class=\"language-js\">const restaurantBill = (bill) => {\n  const tax = /* ??? */\n\n  /* ??? */\n\n  return /* ??? */\n};\n</code></pre>\n<p>Sigue los pasos a continuación para completar la implementación de la <em>función</em>\n<code>restaurantBill</code>.</p>\n<ol>\n<li>Asigna el resultado de multiplicar <code>bill</code> por <code>10%</code> en la variable <code>tax</code>\n(impuesto en inglés). Tip: <code>10%</code> en decimal se escribe <code>0.1</code>.</li>\n<li>Crea una variable llamada <code>total</code> y asígnale el resultado de sumar <code>bill</code> más\n<code>tax</code>.</li>\n<li>Retorna el monto que cada una debe pagar (<code>total</code> divido entre 5), con el\nsímbolo <code>$</code> adelante (por ejemplo: <code>$11</code>). Tip: puedes usar concatenación de\n<em>strings</em> (o <em>string literals</em>) para crear un <em>string</em> con el número y el\nsímbolo <code>$</code> adelante.</li>\n</ol>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = restaurantBill(50);\nconsole.log(output); // --> '$11'\n</code></pre>\n<p>¡Mucha suerte!</p>"
                },
                "pt": {
                  "title": "Conta do restaurante",
                  "body": "<p>Imagine que você saiu para comer com as suas quatro melhores amigas. O valor\ntotal da conta foi de 50 reais, lembrando que você deve adicionar os 10% de\nimposta. Vocês querem dividir a conta igualmente entre as cinco. E para isso\nvocê vai criar um programa.</p>\n<p>O exercício inclui um <em>boilerplate</em> (<em>modelo</em>) que já inclui uma função\n(<code>restaurantBill</code>), a qual irá receber um <em>argumento</em> (<code>bill</code>) com o valor total\nda conta sem contar o imposto (um <em>número</em>), e se espera que o retorno seja uma\n<em>string</em> com a quantidade que deve ser paga por cada uma, já incluindo os 10% de\nimposto (e incluindo o símbolo de dólar).</p>\n<p>O <em>boilerplate</em> (<em>modelo</em>):</p>\n<pre><code class=\"language-js\">const restaurantBill = (bill) => {\n  const tax = /* ??? */\n\n  /* ??? */\n\n  return /* ??? */\n};\n</code></pre>\n<p>Siga as etapas abaixo para completar a implementação da função <em>função</em>\n<code>restaurantBill</code>.</p>\n<ol>\n<li>Atribua o resultado da multiplicação <code>bill</code> por <code>10%</code> na variável <code>tax</code>\n(imposto em inglês). Dica: <code>10%</code> em decimal se escreve <code>0.1</code>.</li>\n<li>Crie uma variável chamada <code>total</code> e atribua o resultado da soma de <code>bill</code>\nmais <code>tax</code>.</li>\n<li>Retorne o valor que cada uma deve pagar (<code>total</code> dividido por 5), com o\nsímbolo <code>$</code> na frente (exemplo: <code>$11</code>). Dica: pode usar concatenação de\n<em>strings</em> (ou <em>string literals</em>) para criar uma <em>string</em> com o número e o\nsímbolo <code>$</code> na frente.</li>\n</ol>\n<p>Exemplo:</p>\n<pre><code class=\"language-js\">const output = restaurantBill(50);\nconsole.log(output); // --> '$11'\n</code></pre>\n<p>Boa sorte!</p>"
                }
              },
              "files": {
                "/boilerplate/restaurantBill.js": "const restaurantBill = (bill) => {\n  const tax = /* ??? */\n\n  /* ??? */\n\n  return /* ??? */\n};\n\nmodule.exports = restaurantBill;\n",
                "/solution/restaurantBill.js": "const restaurantBill = (bill) => {\n  const tax = bill * 0.1;\n\n  const total = bill + tax;\n\n  return `$${total / 5}`;\n};\n\nmodule.exports = restaurantBill;\n",
                "/test/restaurantBill.spec.js": "const Assert = require('chai').assert;\nconst restaurantBill = require('../solution/restaurantBill');\n\ndescribe('restaurantBill()', () => {\n  it('debería regresar $11, para 50', () => {\n    const preTaxAmount = 50;\n    const tax = preTaxAmount * 0.1;\n    const total = `$${(preTaxAmount + tax) / 5}`;\n    Assert.deepEqual(restaurantBill(preTaxAmount), total);\n  });\n\n  it('debería regresar $22, para 100', () => {\n    const preTaxAmount = 100;\n    const tax = preTaxAmount * 0.1;\n    const total = `$${(preTaxAmount + tax) / 5}`;\n    Assert.deepEqual(restaurantBill(preTaxAmount), total);\n  });\n\n  it('debería regresar $18.7, para 85', () => {\n    const preTaxAmount = 85;\n    const tax = preTaxAmount * 0.1;\n    const total = `$${(preTaxAmount + tax) / 5}`;\n    Assert.deepEqual(restaurantBill(preTaxAmount), total);\n  });\n});\n"
              }
            }
          ]
        }
      ]
    },
    {
      "slug": "flow-control",
      "intl": {
        "es": {
          "title": "Control de Flujo"
        },
        "pt": {
          "title": "Controle de fluxo"
        }
      },
      "prefix": "02",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Opening",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<p>En esta unidad aprenderemos:</p>\n<ul>\n<li>Qué es el control de flujo de un programa y cuáles son las estructuras básicas\nde control de flujo</li>\n<li>Cómo funcionan y para qué sirven las <code>estructuras condicionales</code></li>\n<li>Cómo funcionan y para qué sirven las <code>estructuras repetitivas</code></li>\n<li>Qué son las <code>funciones</code>, cómo se utilizan y por qué son cruciales para la\nprogramación</li>\n</ul>\n<hr>\n<h2>Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>¿Por qué quisiéramos modificar el control de flujo de un programa?</li>\n<li>¿Cuáles son las formas de modificar el flujo de un programa? Dibuja una\nrepresentación de cada una</li>\n<li>¿Qué significa <code>else</code> de una sentencia <code>if...else</code>? Dame un ejemplo</li>\n<li>¿Cuál es la diferencia entre un <code>while</code> y un <code>do</code>?</li>\n<li>¿Cuáles son las 3 partes (sentencias) esenciales de un <code>for</code>? Dame un ejemplo</li>\n<li>¿Para qué utilizamos <code>break</code> y <code>continue</code> en un <code>for</code>? Dame un ejemplo</li>\n<li>Explica, con una analogía y en tus propias palabras, qué es una función.</li>\n<li>Dibuja el concepto de una función</li>\n<li>¿Por qué son importantes las funciones en la programación?</li>\n<li>¿Qué se entiende por <code>DRY</code>?</li>\n<li>¿Qué significa \"llamar\" a una función?</li>\n<li>¿Qué sería un \"input\" (entrada) para una función y qué sería el equivalente\ndel \"output\" (salida)?</li>\n<li>¿Qué significa el valor de <code>return</code> de una función?</li>\n<li>¿Qué sucede cuando una función tiene varios valores de <code>return</code>?</li>\n<li>¿Por qué podemos resolver problemas más complejos sabiendo\n<code>estructuras condicionales</code>, <code>estructuras repetitivas</code> y <code>funciones</code>? Dame un\nejemplo</li>\n</ul>"
            },
            "pt": {
              "title": "Opening",
              "body": "<h2>Objetivos de Aprendizado</h2>\n<p>Nesta unidade aprenderemos:</p>\n<ul>\n<li>O que é o controle de fluxo de um programa e quais são as estruturas básicas\nde controle de fluxo</li>\n<li>Como funcionam e para que servem as <code>estruturas condicionais</code></li>\n<li>Como funcionam e para que servem as <code>estruturas repetitivas</code></li>\n<li>O que são as <code>funções</code>, como se usam e por que são essenciais para a\nprogramação</li>\n</ul>\n<hr>\n<h2>Guia de perguntas e conceitos-chave</h2>\n<p>Quando começamos a estudar um tema novo, é útil ter uma idea dos conceitos mais\nimportantes do que vamos aprender e dos temas centrais que devemos prestar\nespecial atenção.</p>\n<p>A seguir te apresentamos uma série de perguntas que você deve ser capaz de\nresponder ao terminar esta unidade. Utilize estas perguntas como guia para\norientar os seus esforços de aprendizagem. Revisite este conteúdo constantemente\nà medida que avance, pois assim poderá validar se está avançando na direção\ncorreta. Isto te servirá como um \"checklist\" conforme você avança:</p>\n<ul>\n<li>Por que modificar o controle de fluxo de um programa?</li>\n<li>Quais são as formas de modificar o fluxo de um programa? Desenhe uma\nrepresentação de cada uma</li>\n<li>O que significa <code>else</code> de uma sentença <code>if...else</code>? Dê um exemplo</li>\n<li>Qual é a diferença entre um <code>while</code> e um <code>do</code>?</li>\n<li>Quais são as 3 partes (sentenças) essenciais de um <code>for</code>? Dê um exemplo</li>\n<li>Para que utilizamos <code>break</code> e <code>continue</code> em um <code>for</code>? Dê um exemplo</li>\n<li>Explique, com uma analogia e as suas próprias palavras, o que é uma função.\nDesenhe o conceito de uma função</li>\n<li>Por que são importantes as funções na programação?</li>\n<li>O que é <code>DRY</code>?</li>\n<li>O que significa \"chamar\" a uma função?</li>\n<li>O que seria um \"input\" (entrada) para uma função e o que seria o equivalente\nao \"output\" (saída)?</li>\n<li>Qual é a diferença entre um parâmetro e um argumento de uma função?</li>\n<li>O que significa o valor de <code>return</code> de uma função?</li>\n<li>O que acontece quando uma função tem vários valores de <code>return</code>?</li>\n<li>Por que podemos resolver problemas mais complexos sabendo <code>estruturas condicionais</code>,  <code>estruturas repetitivas</code> e <code>funções</code>? Dê um exemplo</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "conditionals-and-loops",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Estructuras condicionales y repetitivas",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender qué es el control de flujo de un programa</li>\n<li>Entender qué son <code>estructuras condicionales</code> y cómo afectan el flujo del\nprograma</li>\n<li>Entender qué son <code>estructuras repetitivas</code> y cómo afectan el flujo del\nprograma</li>\n</ul>\n<hr>\n<p>El texto a continuación se basa en gran medida, con ciertos ajustes, en el\ncapítulo 2 de <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn\nHaverbeke, 2014. Traducción en <a href=\"http://hectorip.github.io/Eloquent-JavaScript-ES-online/chapters/01_values.html\">Español</a>\ndisponible gracias a <a href=\"https://github.com/hectorip\">hectorip</a>, y del capítulo 6 de\n<a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for kids</a>,\nNick Morgan, 2015;</p>\n<h2>Control de Flujo</h2>\n<p>La razón por la cual creamos programas de computación es para <strong>resolver\nproblemas</strong>. Un programa, hemos visto, es simplemente un conjunto de\n\"instrucciones\" que las computadoras siguen. Ese conjunto de instrucciones\nresuelven un problema. Hasta ahora hemos aprendido a obtener, representar,\nmanipular y almacenar data en <code>variables</code>. Con esto, hemos podido crear\nprogramas que resuleven problemas muy sencillos. Esto es el caso, por ejempo,\ndel programa que hicimos para transformar la temperatura en Celsius (°C) a\nFarenheit (°F). Sin embargo, para crear programas más complejos, es necesario\nexpandir nuestro conocimiento sobre el <em>control de flujo de un programa</em> y las\nestructuras que existen para modificar este flujo.</p>\n<p>Para utilizar la terminología correcta de JavaScript, de ahora en adelante,\nsustituiremos la palabra \"instrucciones\" por la palabra \"sentencias\". Una\nsentencia JavaScript es el equivalente a una oración en un leguaje humano.\nEntendemos, por lo tanto, que un programa en JavaScript es una lista de\n\"sentencias JavaScript\"; es decir, un conjunto de oraciones que le dicen al\ncomputador qué hacer.</p>\n<h3>1. Flujo en línea recta</h3>\n<p>Cuando un programa contiene más de una sentencia, éstas son ejecutadas de arriba\nhacia abajo, una por una. Por ejemplo, el siguiente programa tiene tres\nsentencias: la primera le declara una variable llamada <code>name</code> con el valor del\nstring 'Michelle'; la segunda, imprime en la consola un mensaje personalizado de\nsaludo 'Hola Michelle'; y la tercera, imprime en la consola un mensaje que dice\n'Qué nombre tan largo tienes!'.</p>\n<pre><code class=\"language-js\">const name = 'Michelle';\nconsole.log('Hola ' + name);\nconsole.log('Qué nombre tan largo tienes!');\n// returns > Hola Michelle\n//           Qué nombre tan largo tienes!\n</code></pre>\n<p>Una representación trivial esquemática de un flujo de control recto sería:</p>\n<p><img src=\"http://eloquentjavascript.net/img/controlflow-straight.svg\" alt=\"Flujo recto\"></p>\n<h3>2. Flujo condicional</h3>\n<p>Ejecutar sentencias en línea recta no es la única opción que tenemos. Una\nalternativa es la <em>ejecución condicional</em>, en donde escogemos entre dos rutas\ndiferentes basados en un valor <code>Boolean</code>, así:</p>\n<p><img src=\"http://eloquentjavascript.net/img/controlflow-if.svg\" alt=\"Flujo condicional\"></p>\n<p>La ejecución condicional se escribe con el keyword <code>if</code> en JavaScript. La\ninstrucción <code>if</code> es la más simple de las estructuras de control de JavaScript.\nSe utiliza para ejecutar código <em>si y sólo si</em> una condición es verdadera. Un\ncondicional dice: <em>\"Si algo es verdad, haz esto\"</em>. Por ejemplo, si hiciste tu\ntarea (true), recibes un helado, pero si <strong>no</strong> hiciste tu tarea (false),\nno recibes el helado.</p>\n<p>Como muestra el ejemplo a continuación, una sentencia <code>if</code> tiene 2 partes\nprincipales: la condición y el cuerpo. La condición debe ser un valor <code>Boolean</code>\nque va entre paréntesis. El cuerpo consiste en una o más sentencias JavaScript\nque se ejecutarán si, y solo si, la condición es verdadera (<code>Boolean</code> igual a\n<code>true</code>).</p>\n<pre><code class=\"language-js\">if (condición) {\n  // Conjunto de sentencias a ejecutar\n}\n</code></pre>\n<p>Cuando necesitamos ejecutar múltiples sentencias, podemos encerrarlas en llaves\n({ y }). Las llaves agrupan las sentencias, haciéndolos valer por una sola. Una\nsecuencia de sentencias encerradas en llaves es llamada un <strong>bloque</strong> (de\ncódigo). Muchos programadores de JavaScript encierran cada cuerpo de un <code>if</code> (y\nen los bucles, como verás más adelante), en llaves. Lo hacen en nombre de la\nconsistencia y para evitar tener que añadir o quitar las llaves cuando el número\nde sentencias en el cuerpo cambie. Otros, valoran la brevedad y en el caso del\n<code>if</code> no utilizan las llaves. En este curso, siempre usaremos las llaves para\nayudarnos a organizar nuestro código.</p>\n<p>Volvamos al ejemplo anterior y agreguemos una condición antes de la sentencia\nque imprime el segundo mensaje:</p>\n<pre><code class=\"language-js\">const name = 'Michelle';\nconsole.log('Hola ' + name);\nif (name.length > 7) {\n  console.log('Qué nombre tan largo tienes!');\n}\n// imprime > Hola Michelle\n//           Qué nombre tan largo tienes!\n</code></pre>\n<p>Con esta modificación, antes de imprimir en la consola el segundo mensaje ('Qué\nnombre tan largo tienes!'), el programa verifica si la longitud del string\n<code>name</code> es mayor a 7. De ser así, se imprime el segundo mensaje. De no ser así,\nno se ejecuta esa sentencia. En este caso, dado que <em>Michelle</em> tiene 8\ncaracteres (letras), la condición es <code>true</code>. Por lo tanto, se imprime el segundo\nmensaje.</p>\n<p>Cambiemos un poco este ejemplo, modificando el valor de <code>name</code> a 'Ana'.</p>\n<pre><code class=\"language-js\">const name = 'Ana';\nconsole.log('Hola ' + name);\nif (name.length > 7) {\n  console.log('Qué nombre tan largo tienes!');\n}\n// returns > Hola Ana\n</code></pre>\n<p>En esta ocasión, la condición <strong>no</strong> es <code>true</code> (es <code>false</code>) porque la longitud\ndel nombre es 3, lo cual <strong>no</strong> es mayor a 7. Por lo tanto, el cuerpo del <code>if</code>\n<strong>no</strong> se ejecuta. De tal manera, únicamente se ejecuta el primer mensaje 'Hola\nAna'.</p>\n<h4><em>Sentencia <code>if... else</code></em></h4>\n<p>A menudo no sólo tendrás código que se ejecute cuando una condición sea\nverdadera, sino también que maneje el otro caso. Este camino alternativo es\nrepresentado por la segunda flecha en el diagrama de flujo. La palabra clave\n<code>else</code> puede ser usada, junto con <code>if</code>, para crear dos rutas de ejecución\nseparadas y alternativas.</p>\n<p>Agregemos una sentencia <code>else</code> a nuestro ejemplo:</p>\n<pre><code class=\"language-js\">const name = 'Ana';\nconsole.log('Hola ' + name);\nif (name.length > 7) {\n  console.log('Qué nombre tan largo tienes!');\n} else {\n  console.log('Tu nombre no es muy largo');\n}\n\n// returns > Hola Ana\n//           Tu nombre no es muy largo\n</code></pre>\n<p>Como ves, el resultado de este caso es similar al anterior, solo que si <code>name</code>\n<strong>no</strong> tiene una logitud mayor a 7, existe un \"mensaje alternativo\" que se\nejecuta.</p>\n<p>Como muestra el ejemplo a continuación, las sentencias <code>if ... else</code> son\nsimilares a las sentencias <code>if</code>, pero incluyen 2 cuerpos. Si la condición es\n<code>true</code>, se ejecutan las sentencias del primer cuerpo; de lo contrario, se\nejecutan las sentencias del segundo cuerpo.</p>\n<pre><code class=\"language-js\">if (condición) {\n  Sentencias a ejecutar si condición es VERDADERA\n} else {\n  Sentencias a ejecutar si condición es FALSA\n}\n</code></pre>\n<p>Si tenemos más de dos caminos a escoger, varios pares de <code>if...else</code> pueden ser\n\"encadenados\". Aquí hay un ejemplo:</p>\n<pre><code class=\"language-js\">const num = parseInt(prompt('Dame un número', '0'));\n\nif (num &#x3C; 10) {\n  alert('Diste un número Pequeño');\n} else if (num &#x3C; 100) {\n  alert('Diste un número Mediano');\n} else {\n  alert('Diste un número Grande');\n}\n</code></pre>\n<p>El programa primero revisará si <code>num</code> es menor que 10. Si lo es, escoge ese\ncamino, muestra 'Diste un número Pequeño' en un alert box y termina. Si no lo\nes, toma el camino del <code>else</code>, que en sí mismo contiene un segundo <code>if</code>. Si la\nsegunda condición (&#x3C; 100) se cumple, significa que el número está entre 10 y\n100, y se muestra 'Diste un número Mediano' en un alert box. Si no lo es, el\nsegundo y último <code>else</code> es escogido, mostrando 'Diste un número Grande'.</p>\n<p>El diagrama de flujo para este programa es algo así:</p>\n<p><img src=\"http://eloquentjavascript.net/img/controlflow-nested-if.svg\" alt=\"Flujo condicional\"></p>\n<p>Veamos otro ejemplo de la aplicación de la sentencia <code>if...else</code>. Esta vez, con\nun video de otra profesora estrella de Laboratoria, Alexandra :)</p>\n<p><a href=\"https://www.youtube.com/watch?v=-rNwUIEQJnc\"><img src=\"https://img.youtube.com/vi/-rNwUIEQJnc/0.jpg\" alt=\"ejercicio guiado if...else JS for Kids pg 94\"></a></p>\n<h4><em>Utilizando Switch</em></h4>\n<p>Es común ver código así:</p>\n<pre><code class=\"language-js\">if (variable == 'valor1') {\n  accion1();\n} else if (variable == 'valor2') {\n  accion2();\n} else if (variable == 'valor3') {\n  accion3();\n} else {\n  accionDefault();\n}\n</code></pre>\n<p>Existe una estructura llamada <code>switch</code> que está hecha para \"despachar\" de un\nmodo más directo. Desafortunadamente, la sintaxis que JavaScript usa para esto\n(que es heredada de la línea de lenguajes de programación de C/Java) es un poco\nincómoda; una cadena de sentencias <code>if</code> a menudo luce mejor. Aquí hay un\nejemplo:</p>\n<pre><code class=\"language-js\">switch (prompt('¿Cómo está el clima?')) {\n  case 'lluvioso':\n    console.log('Recuerda llevar un paraguas.');\n    break;\n  case 'soleado':\n    console.log('Viste ligero.');\n  case 'nublado':\n    console.log('Sal a la calle.');\n    break;\n  default:\n    console.log('Tipo de Clima desconocido.');\n    break;\n}\n</code></pre>\n<p>Puedes poner cualquier cantidad de etiquetas <code>case</code> dentro del bloque <code>switch</code>.\nEl programa saltará a la etiqueta que corresponda al valor que se le dio al\n<code>switch</code> o al default si no se encuentra valor que corresponda. Se empiezan a\nejecutar las sentencias desde ahí, incluso si están bajo otra etiqueta, hasta\nque se llegue a una sentencia <code>break</code> (que en español significa \"detener\").</p>\n<p>En algunos casos, como en el caso de 'soleado' en el ejemplo, esto puede ser\nusado para compartir código entre casos (recomienda salir a la calle tanto para\nclima soleado como para nublado). Pero cuidado: es fácil olvidar el break, lo\ncuál causará que el programa ejecute código que no quieres que se ejecute.</p>\n<p>A continuación Michelle te ayuda a entender este caso un poco mejor:</p>\n<p><a href=\"https://www.youtube.com//watch?v=Aa0JhU6KZXs\"><img src=\"https://img.youtube.com/vi/Aa0JhU6KZXs/0.jpg\" alt=\"ejemplo de Switch\"></a></p>\n<h3>3. Flujo repetitivo: Bucles</h3>\n<p>Otra forma de modificar el flujo de un programa es estructuras repetitivas,\ntambién llamadas bucles (\"loops\" en inglés). Tal como hemos visto, los\ncondicionales permiten ejecutar un conjunto de sentencias una vez si una\ncondición <em><strong>es</strong></em> verdadera. Los bucles, permiten ejecutar un código varias\nveces, dependiendo de si una condición <em><strong>sigue siendo</strong></em> verdadera.</p>\n<p>Piensa en un programa que imprima todos los números pares del 1 al 12. Una\nmanera de escribirlo sería como sigue:</p>\n<pre><code class=\"language-js\">console.log(0);\nconsole.log(2);\nconsole.log(4);\nconsole.log(6);\nconsole.log(8);\nconsole.log(10);\nconsole.log(12);\n// → 0\n// → 2\n//   … etcetera\n</code></pre>\n<p>Eso funciona, pero la idea de escribir un programa es trabajar menos, no más. Si\nnecesitamos todos los números menores que 1,000, lo anterior sería imposible de\ntrabajar. Lo que necesitamos es una forma de repetir algo de código. Esta forma\nde <strong>control de flujo</strong> es llamada bucle. El control de flujo por bucles nos\npermite regresar a cierto punto en el programa en el que estuvimos antes y\nrepetirlo con nuestro estado actual, tal como lo describe el siguiente diagrama:</p>\n<p><img src=\"http://eloquentjavascript.net/img/controlflow-loop.svg\" alt=\"Flujo bucle\"></p>\n<h4>Bucles <code>while</code></h4>\n<p>El bucle más sencillo es el bucle <code>while</code> (que significa \"mientras\" en español).\nUn bucle <code>while</code> ejecuta repetidamente una serie de sentencias hasta que una\ncondición particular deja de ser verdadera. Al escribir un bucle <code>while</code>, estás\ndiciendo: <em>\"Sigue haciendo esto mientras esta condición sea verdadera. Detente\ncuando la condición se vuelva falsa.\"</em></p>\n<p>Como muestra el ejemplo a continuación, una sentencia que comienza con el\nkeyword <code>while</code> crea un bucle. Después de <code>while</code> viene una expresión en\nparéntesis que representa la condición y después un conjunto de sentencias (muy\nparecido al caso del <code>if</code>). Sin embargo, a diferencia del <code>if</code>, el bucle ejecuta\nla sentencia mientras la condición produzca un valor que sea <code>true</code>. Por eso es\nmuy importante que el conjunto de sentencias incluya algo que <em>\"cambia\"</em> para\nque la condición eventualmente sea falsa. De lo contrario, terminarás con un\nciclo infinito que nunca se detendrá, y eso usualmente es malo.</p>\n<pre><code class=\"language-js\">while (condición) {\n  // Conjunto de sentencias, donde\n  // se incluye algo que \"cambia\" para\n  // que la condición eventualmente sea FALSA\n}\n</code></pre>\n<p>Regresemos al problema de imprimir todos los números pares del 1 al 12, y\ncreemos un programa que utilice un bucle <code>while</code>:</p>\n<pre><code class=\"language-js\">let number = 0;\nwhile (number &#x3C;= 12) {\n  console.log(number);\n  number = number + 2;\n}\n// → 0\n// → 2\n//   … etcetera hasta 12\n</code></pre>\n<p>En este caso, como queremos imprimir los números pares del 1 al 12, creamos una\nvariable <code>number</code> (es importante preguntarse <em>¿cuántas veces necesitamos\n<strong>crear</strong> la variable number?</em>), la inicializamos con el valor <code>0</code>, y la\nutilizamos en la condición. Queremos que el bloque dentro del <code>while</code> corra\nmientras el valor de <code>number</code> sea igual o menor a <code>12</code>. El cuerpo del <code>while</code>\nincluye dos sentencias: la primera, imprime el número (con <code>console.log</code>), y la\nsegunda incrementa <code>number</code> en <code>2</code> (porque queremos imprimir los pares\núnicamente). La variable <code>number</code> demuestra la forma en que una variable puede\ndar seguimiento al progreso de un programa. Cada vez que el bucle se repite,\n<code>number</code> se incrementa en <code>2</code>. Entonces, al principio de cada repetición, el\nvalor de la variable <code>number</code> es comparado con el número 12 para decidir si el\nprograma ha hecho todo el trabajo que tenía que hacer. Es importante que\nentendamos que si no modificamos el valor de <code>number</code> con la segunda sentencia,\nla condición (<code>number &#x3C;= 12</code>) siempre será <code>true</code> y tendremos un ciclo infinito\nque nunca se detendrá. Esto puede causar que tu computadora tenga problemas y se\ncongele.</p>\n<p>Si creas un bucle infinito en uno de los ejemplos, usualmente se te preguntará\nsi quieres detener el script después de unos cuantos segundos. Si eso falla,\ntendrás que cerrar la pestaña en la que estás trabajando, o, en otros\nnavegadores, cerrar el navegador entero para recuperarte.</p>\n<p>Veamos algunas variantes de este mismo problema para asegurarnos que entendemos\nbien cómo funciona el ciclo <code>while</code>:</p>\n<ul>\n<li>¿Cómo hacemos para imprimir los números <strong>pares</strong> del 1 al 100?: Modificamos\nla condición para que el bucle corra mientras <code>number</code> sea &#x3C;= 100.</li>\n</ul>\n<pre><code class=\"language-js\">let number = 0;\nwhile (number &#x3C;= 100) {\n  console.log(number);\n  number = number + 2;\n}\n// → 0\n// → 2\n//   … etcetera hasta 100\n</code></pre>\n<ul>\n<li>¿Cómo hacemos para imprimir los números <strong>impares</strong> del 1 al 12?:\nInicializamos el valor de <code>number</code> con el valor de 1 (en lugar de 0).</li>\n</ul>\n<pre><code class=\"language-js\">let number = 1;\nwhile (number &#x3C;= 12) {\n  console.log(number);\n  number = number + 2;\n}\n// → 1\n// → 3\n//   … etcetera hasta 11\n</code></pre>\n<ul>\n<li>¿Cómo hacemos para imprimir todos los números <strong>pares</strong> e <strong>impares</strong> del 1 al\n12?: En la segunda sentencia del while, incrementamos <code>number</code> en 1 (en lugar\nde 2) cada ciclo.</li>\n</ul>\n<pre><code class=\"language-js\">let number = 0;\nwhile (number &#x3C;= 12) {\n  console.log(number);\n  number = number + 1;\n}\n// → 0\n// → 1\n// → 2\n//   … etcetera hasta 12\n</code></pre>\n<h4>Bucles <code>do</code></h4>\n<p>El bucle <code>do</code> es una estructura de control similar al bucle <code>while</code>. Se\ndiferencia en sólo un punto: un bucle <code>do</code> siempre ejecuta su cuerpo <strong>por lo\nmenos una vez</strong> y empieza a verificar si debería parar sólo después de la\nprimera ejecución. Para reflejar esto, la condición aparece después del cuerpo\ndel bucle. Veamos un ejemplo:</p>\n<pre><code class=\"language-js\">do {\n  const yourName = prompt('¿Quién eres?');\n} while (!yourName);\n\nconsole.log('tu nombre es ' + yourName);\n</code></pre>\n<p>Este programa te obligará a introducir un nombre. Preguntará una y otra vez\nhasta que obtenga algo que no sea una cadena vacía. Aplicar el operador <code>!</code>\nconvierte un valor a <code>Boolean</code> negándolo y todas las cadenas excepto <code>''</code> se\nconvierten a <code>true</code>. Esto significa que el bucle continúa corriendo hasta que\ndes un nombre que no sea una cadena vacía.</p>\n<h4><em>Bucles <code>for</code></em></h4>\n<p>Muchos bucles siguen el patrón de los ejemplos previos del <code>while</code>. Primero, una\nvariable “contador” es creada para dar seguimiento al progreso del bucle. Luego\nviene el bucle <code>while</code>, cuya expresión condicional normalmente verifica si el\ncontador ha alcanzado cierto límite. El final del cuerpo del bucle, el contador\nes actualizado para dar seguimiento al progreso.</p>\n<p>Debido a que este patrón es tan común, JavaScript y otros lenguajes similares\nproveen una versión un poco más corta y más completa: el bucle <code>for</code>.</p>\n<pre><code class=\"language-js\">for (let number = 0; number &#x3C;= 12; number = number + 2) {\n  console.log(number);\n}\n// → 0\n// → 2\n//   … etc.\n</code></pre>\n<p>Este programa es exactamente equivalente al ejemplo previo de impresión de\nnúmeros pares. El único cambio es que todas las sentencias que están\nrelacionadas con el \"estado\" del bucle están agrupadas.</p>\n<p>Los paréntesis después del keyword <code>for</code> tienen que contener dos puntos y coma\n(<code>;</code>). La parte que está antes del primer punto y coma <em>inicializa</em> el bucle,\nnormalmente al definir una variable. La segunda parte es la expresión que\n<em>verifica</em> si el bucle tiene que continuar. La parte final <em>actualiza</em> el estado\ndel bucle antes de cada iteración. En la mayoría de los casos, esto es más corto\ny claro que una construcción con <code>while</code>.</p>\n<p>Aquí está un código que calcula 2^10 (2 exponencial 10), usando el bucle <code>for</code>:</p>\n<pre><code class=\"language-js\">let result = 1;\nfor (let counter = 0; counter &#x3C; 10; counter = counter + 1) {\n  result = result * 2;\n}\nconsole.log(result);\n// → 1024\n</code></pre>\n<p>La representación general del bucle <code>for</code> es la siguiente:</p>\n<pre><code class=\"language-js\">for (initial setup; condition; increment){\n  Bloque de código a ejecutar\n}\n</code></pre>\n<p>El <em>initial setup</em> (por ejemplo: let counter = 0) se ejecuta antes de que se\ninicie el bucle. Generalmente se usa para crear una variable que rastrea el\nnúmero de veces que se ha ejecutado el bucle. La <em>condition</em> (counter &#x3C; 10) se\ncomprueba antes de cada ejecución del cuerpo de bucle. Si la condición es\nverdadera, el cuerpo es ejecutado; si es falsa, el bucle se detiene. En este\ncaso, el bucle se detendrá una vez que counter ya no sea inferior a 10. El\n<em>increment</em> (counter = counter + 1) se ejecuta después de cada ejecución del\ncuerpo de bucle. Generalmente se utiliza para actualizar la variable de bucle.\nEn nuestro ejemplo, lo usamos para agregar 1 a counter cada vez que se ejecuta\nel bucle.</p>\n<p>A continuación Alexandra te ayuda a entender el flujo de un bucle <code>for</code> que\nimprime el texto 'Hola mundo!' varias veces:</p>\n<p><a href=\"https://www.youtube.com/watch?v=lKwx1RAxTfo\"><img src=\"https://img.youtube.com/vi/lKwx1RAxTfo/0.jpg\" alt=\"bucle for\"></a></p>\n<h4><em>Forzando la salida de un bucle</em></h4>\n<p>Hacer que la condición del bucle produzca <em>false</em> no es la única forma de que un\nbucle termine. Podemos usar la sentencia especial <code>break</code>, utilizada en\n<code>switch</code>, que tiene el efecto de salir inmediatamente del bucle que la esté\nencerrando.</p>\n<p>El siguiente programa ilustra el uso de la sentencia <code>break</code> para salir de un\nbucle. Queremos hacer un programa que encuentre el primer número que es más\ngrande o igual que 20 y divisible por 7.</p>\n<pre><code class=\"language-js\">for (let current = 20; ; current++) {\n  if (current % 7 == 0)\n    break;\n}\nconsole.log(current);\n// → 21\n</code></pre>\n<p>Usar el operador de sobrante o módulo (%) es una forma fácil de probar si un\nnúmero es divisible por otro. Si lo es, el sobrante de la división es cero.\nTambién recuerda que <code>current++</code> es lo mismo que <code>current = current + 1</code>.</p>\n<p>El <code>for</code> en este ejemplo no tiene la parte que verifica si el bucle debe\nterminar. Esto significa que el loop nunca terminará hasta que la sentencia\n<code>break</code> que está adentro sea ejecutada.</p>\n<p>Como, hemos visto, si dejaras afuera esa sentencia <code>break</code> o accidentalmente\nescribieras una condición que siempre produzca <code>true</code>, tu programa se quedaría\natorado en un bucle infinito.</p>\n<p>La palabra clave <code>continue</code> es similar a <code>break</code> en que influencia el progreso\ndel bucle. Cuando se encuentra <code>continue</code> en el cuerpo de un bucle, el control\nsale del curpo del bucle inmediatamente y continúa en la próxima iteración del\nbucle.</p>\n<p>A continuación Michelle te ayuda explica, con un ejemplo, las aplicaciones de\n<code>break</code> y <code>continue</code> dentro de un <code>for</code>:\n<a href=\"https://www.youtube.com/watch?v=C5rIORzHOgg\"><img src=\"https://img.youtube.com/vi/C5rIORzHOgg/0.jpg\" alt=\"ejemplo de break y continue\"></a></p>\n<h4><em>Diferencias entre <code>for</code> y <code>while</code></em></h4>\n<p>Puntualmente, se usa el <code>for</code> cuando sabes <em>por adelantado</em> cuantas repeticiones\nvas a realizar y el <code>while</code> cuando no lo sabes.</p>\n<p>Si decimos, \"gira el ventilador 10 veces\", de ante mano sabes que vamos a girar\nel ventilador 10 veces, por tal, el <code>for</code> seria buena idea.</p>\n<p>Si decimos: \"mientras haga calor gira el ventilador\". En realidad no sabemos de\nante mano cuantas veces vamos a girar el ventilador por que no sabemos cuanto\ntiempo tendremos calor, por ende, usar un <code>while</code> sería buena idea.</p>"
            },
            "pt": {
              "title": "Estruturas condicionais e repetitivas",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender o que é o controle de fluxo de um programa</li>\n<li>Entender o que são <code>estruturas condicionais</code> e como eles afetam o fluxo do\nprograma</li>\n<li>Entender o que são <code>estruturas repetitivas</code> e como afetam o fluxo do programa</li>\n</ul>\n<hr>\n<p>O texto a seguir se baseia em grande medida, com alguns ajustes, ao capítulo 2\ndo <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn Haverbeke,\n2014. Tradução em\n<a href=\"hhttps://github.com/braziljs/eloquente-javascript/blob/master/chapters/01-valores-tipos-operadores.md\">Português</a>,\ne ao capítulo 6 do <a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for\nkids</a>,\nNick Morgan, 2015;</p>\n<h2>Controle de Fluxo</h2>\n<p>A razão pela qual criamos programas de computador é para <strong>resolver problemas</strong>.\nUm programa, como vimos, é simplemente um conjunto de \"instruções\" que os\ncomputadores seguem. Esse conjunto de instruções resolve um problema. Até agora,\naprendemos a obter, representar, manipular e armazenar dados em <code>variáveis</code>. Com\nisso, conseguimos criar programas que resolvem problemas muito simples. Este é o\ncaso, por exemplo, do programa que fizemos para transformar a temperatura de\ngraus Celsius (°C) para Farenheit (°F). No entanto, para criar programas mais\ncomplexos, é necessário expandir nosso conhecimento sobre o <em>controle de fluxo\nde um programa</em> e as estruturas existentes para modificar esse fluxo.</p>\n<p>Para usar a terminologia correta de JavaScript, a partir de agora,\nsubstituiremos a palavra \"instruções\" pela palavra \"sentenças\". Uma instrução\nJavaScript é o equivalente a uma sentença em linguagem humana. Entendemos,\nportanto, que um programa em JavaScript é uma lista de \"instruções JavaScript\",\nisto é, um conjunto de sentenças que informa ao computador o que fazer.</p>\n<h3>1. Fluxo em linha reta</h3>\n<p>Quando um programa contém mais de uma frase, elas são executadas de cima para\nbaixo, uma por uma. Por exemplo, o programa a seguir tem três sentenças: a\nprimeira declara uma variável chamada <code>name</code> com o valor do string 'Samanta'; a\nsegunda exibe no terminal uma mensagem de saudação personalizada: \"Olá\nSamanta\"; e a terceira exibe \"Que nome longo você tem!\".</p>\n<pre><code class=\"language-js\">const name = 'Samanta';\nconsole.log('Olá ' + name);\nconsole.log('Que nome lindo você tem!');\n// returns Olá Samanta\n//         Que nome lindo você tem!\n</code></pre>\n<p>Uma representação trivial esquemática de um fluxo de controle direto seria:</p>\n<p><img src=\"https://camo.githubusercontent.com/a46047c5ecd947fd9919f87767fdbadc8fdbadc2/687474703a2f2f656c6f7175656e746a6176617363726970742e6e65742f696d672f636f6e74726f6c666c6f772d73747261696768742e737667\" alt=\"Fluxo\nreto\"></p>\n<h3>2. Fluxo condicional</h3>\n<p>A execução de frases em linha reta não é a única opção que temos. Uma\nalternativa é a execução condicional, em que escolhemos entre duas rotas\ndiferentes com base em um valor <code>Boolean</code>, assim:</p>\n<p><img src=\"https://camo.githubusercontent.com/a3c015252a2f151939cd11f52953a91e561a907a/687474703a2f2f656c6f7175656e746a6176617363726970742e6e65742f696d672f636f6e74726f6c666c6f772d69662e737667\" alt=\"Fluxo\ncondicional\"></p>\n<p>A execução condicional é escrita com a palavra-chave <code>if</code> en JavaScript. A\ninstrução <code>if</code> é a mais simples das estruturas de controle dessa linguagem. Ela\né usada para executar código se, e somente se, uma condição for verdadeira. Uma\ncondicional diz: \"Se algo é verdade, faça isso\". Por exemplo, se você fez sua\nlição de casa, recebe um sorvete, mas se você não fez sua lição, não o recebe.</p>\n<p>Como o exemplo abaixo mostra, uma sentença <code>if</code> em duas partes principais: a\ncondição e o corpo. A condição deve ser um valor <code>Boolean</code> entre parênteses. O\ncorpo consiste em uma ou mais instruções JavaScript que serão executadas se, e\nsomente se, a condição for verdadeira (<code>Boolean</code> igual a <code>true</code>).</p>\n<pre><code class=\"language-js\">if (condição) {\n  // Conjunto de sentenças a executar\n}\n</code></pre>\n<p>Quando precisamos executar várias instruções, podemos colocá-las entre chaves\n({ e }). As chaves agrupam as sentenças, tornando-as apenas uma. Uma sequência\nde sentenças entre chaves é chamada de <strong>bloco</strong> (de código). Muitos\nprogramadores JavaScript incluem chaves em todo corpo de  <code>if</code> (e nos loops,\ncomo você verá mais adiante). Eles fazem isso em nome da consistência e para não\nter que adicionar ou remover as chaves quando o número de sentenças no corpo\nmudar. Outros, valorizam a brevidade e no caso do <code>if</code> não utilizam as chaves.\nNeste curso, sempre usaremos as chaves para nos ajudar a organizar nosso código.</p>\n<p>Vamos voltar ao exemplo anterior e adicionar uma condição antes da frase que\nimprime a segunda mensagem:</p>\n<pre><code class=\"language-js\">const name = 'Samanta';\nconsole.log('Olá ' + name);\nif(name.length > 6) {\n  console.log('Que nome grande você tem!');\n}\n// returns Olá Samanta\n//         Que nome grande você tem!\n</code></pre>\n<p>Com esta modificação, antes de imprimir no terminal a segunda mensagem ('Que\nnome longo você tem!'), o programa verifica se o tamanho da string <code>name</code> é\nmaior que 6. Se sim, a segunda mensagem é impressa. Caso contrário, essa\nsentença não é executada. Neste caso, como Samanta tem 7 caracteres, a condição\né <code>true</code>. Portanto, a segunda mensagem é impressa.</p>\n<p>Vamos mudar um pouco este exemplo, modificando o valor de <code>name</code> para 'Ana'.</p>\n<pre><code class=\"language-js\">const name = 'Ana';\nconsole.log('Olá ' + name);\nif (name.length > 6) {\n  console.log('Que nome grande você tem!');\n}\n// returns Olá Ana\n</code></pre>\n<p>Nesta ocasião, a condição <strong>não</strong> é <code>true</code> (é <code>false</code>) porque o comprimento do\nnome é 3, que <strong>não</strong> é maior que 6. Portanto, o corpo do <code>if</code> <strong>não</strong> se\nexecuta. Desta forma, apenas a primeira mensagem 'Olá Ana' é executada.</p>\n<h4><em>Sentença <code>if... else</code></em></h4>\n<p>Muitas vezes, você não só terá o código que é executado quando uma condição é\nverdadeira, mas também quando acontece o outro caso. Esse caminho alternativo é\nrepresentado pela segunda seta no diagrama de fluxo. A palavra-chave <code>else</code> pode\nser usada, junto com <code>if</code>, para criar dois caminhos de execução separados e\nalternativos.</p>\n<p>Adicionemos uma sentença <code>else</code> ao nosso exemplo:</p>\n<pre><code class=\"language-js\">const name = 'Ana';\nconsole.log('Olá ' + name);\nif (name.length > 6) {\n  console.log('Que nome grande você tem!');\n} else {\n  console.log('Não nome não é muito grande');\n}\n// returns Olá Ana\n//         Não nome não é muito grande\n</code></pre>\n<p>Como você pode ver, o resultado deste caso é similar ao anterior, mas se <code>name</code>\n<strong>não</strong> tiver um comprimento maior que 6, existe uma \"mensagem alternativa\" que\né executada.</p>\n<p>Como o exemplo abaixo mostra, as sentenças <code>if ... else</code> são semelhantes à\nsentenças <code>if</code>, mas incluem dois corpos. Se a condição é <code>true</code>, as sentenças do\nprimeiro corpo são executadas; caso contrário, as sentenças do segundo corpo são\nexecutadas.</p>\n<pre><code class=\"language-js\">if (condição) {\n  Sentenças para execução se a condição for VERDADEIRA\n} else {\n  Sentenças para execução se a condição for FALSA\n}\n</code></pre>\n<p>Se tivermos mais de dois caminhos para escolher, vários pares if... else podem\nser \"encadeados\". Aqui está um exemplo:</p>\n<pre><code class=\"language-js\">const num = parseInt(prompt('Digite um número', '0'));\n\nif (num &#x3C; 10){\n  alert('Você digitou um número pequeno');\n}\nelse if (num &#x3C; 100){\n  alert('Você digitou um número médio');\n}\nelse {\n  alert('Você digitou um número grande');\n}\n</code></pre>\n<p>O programa primeiro verificará se <code>num</code> é menor que 10. Se for, ele escolhe esse\ncaminho, mostra \"Você digitou um número pequeno\" em uma caixa de alerta e\ntermina. Se não for, toma o caminho do  <code>else</code>, que em si mesmo contém um\nsegundo <code>if</code>. Se a segunda condição (&#x3C; 100) for atendida, significa que o número\nestá entre 10 e 100, e \"Você digitou um número médio\" é exibido em uma caixa de\nalerta. Se não for, o segundo e último <code>else</code> é escolhido, mostrando \"Você\ndigitou um número grande\".</p>\n<p>O fluxograma deste programa é algo assim:</p>\n<p><img src=\"https://camo.githubusercontent.com/7da7c495c1528a60105d941be0181490fbffbc81/687474703a2f2f656c6f7175656e746a6176617363726970742e6e65742f696d672f636f6e74726f6c666c6f772d6e65737465642d69662e737667\" alt=\"Flujo\ncondicional\"></p>\n<p>Vamos ver outro exemplo de como usar <code>if...else</code>. Dessa vez com um vídeo da Paloma:</p>\n<p><a href=\"https://www.youtube.com/watch?v=wQ_s9sso9b0\"><img src=\"https://img.youtube.com/vi/wQ_s9sso9b0/0.jpg\" alt=\"if ...\nelse\"></a></p>\n<h4><em>Utilizando Switch</em></h4>\n<p>É comum ver o código assim:</p>\n<pre><code class=\"language-js\">if (variable == 'valor1') {\n  accion1();\n}\nelse if (variable == 'valor2') {\n  accion2();\n}\nelse if (variable == 'valor3') {\n  accion3();\n}\nelse {\n  accionDefault();\n}\n</code></pre>\n<p>Existe uma estrutura chamada <code>switch</code> que serve para \"decidir\" de maneira mais\ndireta. Infelizmente, a sintaxe que o JavaScript usa para isso (que é herdada da\nlinha da linguagem de programação C/Java) é um pouco estranha. Uma sequência de\nfrases <code>if</code> geralmente parece melhor. Aqui está um exemplo:</p>\n<pre><code class=\"language-js\">switch (prompt('Como está o clima?')) {\n  case 'chuvoso':\n    console.log('Lembre-se de levar um guarda-chuva.');\n    break;\n  case 'ensolarado':\n    console.log('Vista roupas leves.');\n  case 'nublado':\n    console.log('Saia para a rua.');\n    break;\n  default:\n    console.log('Tipo de tempo desconhecido.');\n    break;\n}\n</code></pre>\n<p>Você pode colocar qualquer número de etiquetas <code>case</code> dentro do bloco <code>switch</code>.\nO programa irá pular para o rótulo correspondente ao valor que foi dado ao\n<code>switch</code> ou ao default se não houver nenhum valor igual. Daí, eles começam a\nexecutar as sentenças, incluindo os abaixo de outro rótulo, até que uma sentença\n<code>break</code> seja alcançada (o que em português significa \"pare\").</p>\n<p>Em alguns casos, como no caso de \"ensolarado\" no exemplo, é possível\ncompartilhar o código entre os casos (é recomendado ir ao ar livre tanto para\ntempo ensolarado quanto nublado). Mas cuidado: é fácil esquecer o break, o que\nfará com que o programa execute um código que você não deseja executar.</p>\n<p>A seguir o Daniel te ajudará entender este caso um pouco melhor:</p>\n<p><a href=\"https://www.youtube.com/watch?v=CbBTrBwzQfQ\"><img src=\"https://img.youtube.com/vi/CbBTrBwzQfQ/0.jpg\" alt=\"Switch\"></a></p>\n<h3>3. Fluxo repetitivo: Loops</h3>\n<p>Outra forma de modificar o fluxo de um programa é por meio de estruturas\nrepetitivas, também chamadas \"loops\" em inglês. Como já estamos vendo, as\ncondicionais permitem executar um conjunto de sentenças uma vez se uma condição\n<em><strong>é</strong></em> verdadeira. Os loops permitem executar um código várias vezes,\ndependendo se uma condição <em><strong>continua sendo</strong></em> verdadeira.</p>\n<p>Imagine um programa que imprima todos os números pares do 1 ao 12. Uma maneira\nde escrevê-lo seria assim:</p>\n<pre><code class=\"language-js\">console.log(0);\nconsole.log(2);\nconsole.log(4);\nconsole.log(6);\nconsole.log(8);\nconsole.log(10);\nconsole.log(12);\n// → 0\n// → 2\n//   … etcetera\n</code></pre>\n<p>Isso funciona, mas a ideia de escrever um programa é trabalhar menos, e não\nmais. Se necessitamos todos os números menores que 1,000, o modo anterior seria\nimpossível de trabalhar. O que necessitamos é uma forma de repetir partes de\ncódigo. Esta forma de <strong>controle de fluxo</strong> é chamada loop. O controle de fluxo\npor loops nos permite voltar a certo ponto no programa em que estivemos antes e\nrepetí-lo com nosso estado atual, como descreve o seguinte diagrama:</p>\n<p><img src=\"https://camo.githubusercontent.com/48a2fb7be5218c417decdc954fe2e9bf7dc3a3a2/687474703a2f2f656c6f7175656e746a6176617363726970742e6e65742f696d672f636f6e74726f6c666c6f772d6c6f6f702e737667\" alt=\"Flujo\nbucle\"></p>\n<h4>Loops <code>while</code></h4>\n<p>O loop mais simples é o loop <code>while</code> (que significa \"enquanto\" em português). Um\nloop <code>while</code> executa repetidamente uma série de sentenças até que uma condição\nparticular deixe de ser verdadeira. Ao escrever um loop <code>while</code>, você está\ndizendo: <em>\"Continue fazendo isto enquanto esta condição seja verdadeira. Pare\nquando a condição se tornar falsa.\"</em></p>\n<p>Como revela o exemplo a seguir, uma sentença que começa com a keyword <code>while</code>\ncria um loop. Depois de <code>while</code> vem uma expressão em parênteses que representa a\ncondição e depois um conjunto de sentenças (muito parecido ao caso do <code>if</code>).\nPorém, diferentemente do <code>if</code>, o loop executa a sentença enquanto a condição\nproduza um valor que seja <code>true</code>. Por isso é muito importante que o conjunto de\nsentenças inclua algo que <em>\"muda\"</em> para que a condição eventualmente seja falsa.\nDo contrário, criaria um ciclo infinito que nunca termina, e isto usualmente é\nruim.</p>\n<pre><code class=\"language-js\">while (condição) {\n  // Conjunto de sentenças, onde\n  // se inclui algo que \"muda\" para\n  // que a condição eventualmente seja FALSA\n}\n</code></pre>\n<p>Vamos voltar agora ao problema de imprimir todos os números pares do 1 ao 12, e\ncriar um programa que utilize um loop <code>while</code>:</p>\n<pre><code class=\"language-js\">let number = 0;\nwhile (number &#x3C;= 12) {\n  console.log(number);\n  number = number + 2;\n}\n// → 0\n// → 2\n//   … etcetera até 12\n</code></pre>\n<p>Neste caso, como queremos imprimir os números pares do 1 ao 12, criamos uma\nvariável <code>number</code>, inicializamos com o valor 0, e a utilizamos na condição.\nQueremos que o bloco dentro do <code>while</code> funcione enquanto o valor de <code>number</code>\nseja igual ou menor a 12. O corpo do <code>while</code> inclui duas sentenças: a primeira\nimprime o número (com console.log), e a segunda incrementa <code>number</code> em 2 (porque\nqueremos imprimir os pares unicamente). A variável <code>number</code> demonstra a forma em\nque uma variável pode dar seguimento ao progresso de um programa. Cada vez que o\nloop se repete, <code>number</code> se incrementa em 2. Então, no início de cada repetição,\no valor da variável <code>number</code> é comparado com o número 12 para decidir se o\nprograma fez todo o trabalho que deveria fazer. É importante que entendamos que\nse não modificamos o valor de <code>number</code> com a segunda sentença, a condição\n(number &#x3C;=12) sempre será <code>true</code> e teremos um ciclo infinito que nunca se\ndeterá. Isto pode causar que o seu computador tenha problemas e trave.</p>\n<p>Se você cria um loop infinito em um dos exemplos, usualmente será perguntado se\nvocê quer deter o script depois de alguns segundos. Se isso falha, você terá que\nfechar a aba na qual está trabalhando, ou, em outros navegadores, fechar o\nnavegador inteiro para se recuperar.</p>\n<p>Vejamos algumas variantes deste mesmo problema para assegurar que entendemos bem\ncomo funciona o ciclo <code>while</code>:</p>\n<ul>\n<li>Como fazemos para imprimir os números <strong>pares</strong> do 1 ao 100?: Modificamos a\n condição para que o loop aconteça enquanto <code>number</code> seja &#x3C;= 100.</li>\n</ul>\n<pre><code class=\"language-js\">let number = 0;\nwhile (number &#x3C;= 100) {\n  console.log(number);\n  number = number + 2;\n}\n// → 0\n// → 2\n//   … etcetera até 100\n</code></pre>\n<ul>\n<li>Como fazemos para imprimir os números <strong>ímpares</strong> do 1 a 12?: Iniciamos o\n valor de <code>number</code> com o valor de 1 (ao invés de 0).</li>\n</ul>\n<pre><code class=\"language-js\">let number = 1;\nwhile (number &#x3C;= 12) {\n  console.log(number);\n  number = number + 2;\n}\n// → 1\n// → 3\n//   … etcetera até 11\n</code></pre>\n<ul>\n<li>Como fazemos para imprimir todos os números <strong>pares</strong> e <strong>ímpares</strong> do 1 ao\n 12?: Na segunda sentença do while, incrementamos <code>number</code> em 1 (no lugar de\n 2) a cada ciclo.</li>\n</ul>\n<pre><code class=\"language-js\">let number = 0;\nwhile (number &#x3C;= 12) {\n  console.log(number);\n  number = number + 1;\n}\n// → 0\n// → 1\n// → 2\n//   … etcetera até 12\n</code></pre>\n<h4>Loops <code>do</code></h4>\n<p>O loop <code>do</code> é uma estrutura de controle similar ao loop <code>while</code>. A diferença\nestá em um só ponto: um loop <code>do</code> sempre executa seu corpo <strong>pelo menos uma\nvez</strong> e começa a verificar se deveria parar somente depois da primeira execução.\nPara refletir isto, a condição aparece depois do corpo do loop. Vejamos um\nexemplo:</p>\n<pre><code class=\"language-js\">let yourName;\ndo {\n yourName = prompt('Qual é seu nome?');\n} while (!yourName);\n\nconsole.log('seu nome é ' + yourName);\n</code></pre>\n<p>Este programa te obrigará a introduzir um nome. Perguntará uma e outra vez até\nque obtenha algo que não seja uma cadeia vazia. Aplicar o operador <code>!</code> converte\num valor a <code>Boolean</code> negando-o e todas as cadeias exceto <code>''</code> se convertem a\n<code>true</code>. Isto significa que ele continua rodando até que você dê um nome que não\nseja uma cadeia vazia.</p>\n<h4><em>Loop <code>for</code></em></h4>\n<p>Muitos loops seguem um padrão dos exemplos prévios do <code>while</code>. Primeiro, uma\nvariável “contador” é criada para dar seguimento ao progresso do loop. Logo\ndepois vem o loop <code>while</code>, cuja expressão condicional normalmente verifica se o\ncontador alcançou certo limite. Ao final do corpo do loop, o contador é\natualizado para dar seguimento ao progresso.</p>\n<p>Devido ao fato de que este padrão é muito comum, JavaScript e outras linguagens\nsimilares proporcionam uma versão um pouco mais curta e mais completa: o loop\n<code>for</code>.</p>\n<pre><code class=\"language-js\">for (let number = 0; number &#x3C;= 12; number = number + 2){\n  console.log(number);\n}\n// → 0\n// → 2\n//   … etc.\n</code></pre>\n<p>Este programa é exatamente equivalente ao exemplo prévio de impressão de números\npares. A única mudança é que todas as sentenças que estão relacionadas com o\n\"estado\" do ciclo estão agrupadas.</p>\n<p>Os parênteses depois do keyword <code>for</code> devem conter ponto e vírgula (<code>;</code>). A\nparte que está antes do primeiro ponto e vírgula <em>inicia</em> o loop, normalmente ao\ndefinir uma variável. A segunda parte é a expressão que <em>verifica</em> se o loop tem\nque continuar. A parte final <em>atualiza</em> o estado do loop antes de cada iteração.\nNa maioria dos casos, isto é mais curto e claro que uma construção com <code>while</code>.</p>\n<p>A seguir mostramos um código que calcula 2^10 (2 exponencial 10), usando o loop\n<code>for</code>:</p>\n<pre><code class=\"language-js\">let result = 1;\nfor (let counter = 0; counter &#x3C; 10; counter = counter + 1){\n  result = result * 2\n}\nconsole.log(result);\n// → 1024\n</code></pre>\n<p>A representação geral do loop <code>for</code> é a seguinte:</p>\n<pre><code class=\"language-js\">for (initial setup; condition; increment){\n  Bloco de código a executar\n}\n</code></pre>\n<p>O <em>initial setup</em> (por exemplo: <code>let counter = 0</code>) se executa antes de que se\ninicie o loop. Geralmente se usa para criar uma variável que rastreia o número\nde vezes que foi executado o loop. A <em>condition</em> (counter &#x3C; 10) se comprova\nantes de cada execução do corpo do loop. Se a condição é verdadeira, o corpo é\nexecutado; se é falsa, o loop se detém. Neste caso, o loop se deterá uma vez que\ncounter já não seja inferior a 10. O <em>increment</em> (counter = counter + 1) se\nexecuta depois de cada execução do corpo do loop. Geralmente se utiliza para\natualizar a variável do loop. No nosso exemplo, utilizamos para agregar 1 a\ncounter cada vez que se executa o loop.</p>\n<p>A seguir Paloma te ajudará a entender o fluxo do loop for:</p>\n<p><a href=\"https://www.youtube.com/watch?v=6iZEpRhzDKI\"><img src=\"https://img.youtube.com/vi/6iZEpRhzDKI/0.jpg\" alt=\"For\"></a></p>\n<h4><em>Forçando a saída de um loop</em></h4>\n<p>Fazer com que a condição do loop produza <em>false</em> não é a única forma para que um\nloop termine. Podemos usar a sentença especial <code>break</code>, utilizada en <code>switch</code>,\nque tem o efeito de sair inmediatamente do loop que o esta fechando.</p>\n<p>O programa a seguir ilustra o uso da sentença <code>break</code> para sair de um loop.\nQueremos fazer um programa que encontre o primeiro número que é maior ou igual a\n20 e divisível por 7.</p>\n<pre><code class=\"language-js\">for (let current = 20; current++) {\n  if (current % 7 == 0)\n    break;\n}\nconsole.log(current);\n// → 21\n</code></pre>\n<p>Usar o operador de resto ou módulo (%) é uma forma fácil de provar se o número é\ndivisível por outro. Se for, o resto da divisão é zero. Também lembre-se que\n<code>current++</code> é o mesmo que <code>current = current + 1</code>.</p>\n<p>O <code>for</code> neste exemplo não tem a parte que verifica se o loop deve terminar. Isto\nsignifica que o loop nunca terminará até que a sentença <code>break</code> que está dentro\nseja executada.</p>\n<p>Como já estamos aprendendo, se você deixasse fora essa sentença <code>break</code> ou\nacidentalmente escrevesse uma condição que sempre produza <code>true</code>, o seu programa\nse ficaria travado em um loop infinito.</p>\n<p>A palavra chave <code>continue</code> é parecida ao <code>break</code> pois influencia o progresso do\nloop. Quando se encontra <code>continue</code> no corpo de um loop, o controle sai do corpo\ndo loop imediatamente e continua na próxima iteração do loop.</p>\n<p>A seguir Rafael te explicará, com um exemplo, as aplicações de <code>break</code> and\n<code>continue</code> dentro de um for:</p>\n<p><a href=\"https://www.youtube.com/watch?v=1B6pwKRDWgE\"><img src=\"https://img.youtube.com/vi/1B6pwKRDWgE/0.jpg\" alt=\"Break and\nContinue\"></a></p>\n<h4><em>Diferenças entre <code>for</code> e <code>while</code></em></h4>\n<p>Pontualmente, se usa o <code>for</code> quando se save quantas repetições vão ser\nrealizadas e o <code>while</code> quando não se sabe.</p>\n<p>Se dissermos, \"gire o ventilador 10 vezes\", você já sabe que vamos girar o\nventilador 10 vezes, então seria uma boa ideal usar o <code>for</code>.</p>\n<p>Se dissermos, \"enquanto estiver calor gire o ventilador\". Não sabemos quantas\nvezes vamos girar o ventilador até ficar frio, então usar o <code>while</code> nesse caso é\nmelhor.</p>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "loops",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Bucles (Loops)",
              "body": "<h2>Mecanismos que pueden ser usados con ciclos/bucles</h2>\n<p>Los siguientes mecanismos pueden ser usados con ciclos:</p>\n<h3><code>break [label]</code></h3>\n<p>Sale de un ciclo.</p>\n<h3><code>continue [label]</code></h3>\n<p>Detiene la iteración actual e inmediatamente ejecuta la siguiente.</p>\n<h3><code>Labels</code></h3>\n<p>Un <code>label</code>(etiqueta) es un identificador seguido por <code>:</code>. Al inicio de un ciclo,\nun label te permite hacer <code>break</code> o <code>continue</code> incluso si está dentro anidado de\notro ciclo anidado. Cuando está al inicio de un bloque, te permite salir del\nmismo con la sentencia <code>break</code>. En ambos casos, el nombre del label se convierte\nen un argumento de <code>break</code> o <code>continue</code>. Aquí un ejemplo de <code>break</code>:</p>\n<pre><code class=\"language-js\">const findEvenNumber = arr => {\n  loop: { // label\n    for (let i = 0, l = arr.length; i &#x3C; l; i++) {\n      let element = arr[i];\n      if (element % 2 === 0) {\n        console.log(`Found: ${element}`);\n        break loop;\n      }\n    }\n    console.log('No even number found.');\n  }\n  console.log('DONE');\n};\n</code></pre>\n<h2>Tipos de bucles (loops)</h2>\n<h3>while</h3>\n<p>Un ciclo while:</p>\n<pre><code class=\"language-js\">while (condition) {\n  // statement\n}\n</code></pre>\n<p>Ejecuta <code>statement</code> tantas veces como la condición se cumpla. Si la condición es\nsiempre <code>true</code>, entonces entra en un <code>infinite loop</code> (ciclo infinito).</p>\n<pre><code class=\"language-js\">// infinite loop\nwhile (1 === 1) { }\n</code></pre>\n<p>En el siguiente ejemplo, eliminamos todos los elementos del arreglo y los\nmostramos en la consola:</p>\n<pre><code class=\"language-js\">const arr = ['a', 'b', 'c'];\n\nwhile (arr.length > 0) {\n  console.log(arr.shift());\n}\n\n/*\n *\n * La salida de este código será:\n * a\n * b\n * c\n *\n */\n</code></pre>\n<h3>do-while</h3>\n<p>Un ciclo do-while:</p>\n<pre><code class=\"language-js\">do {\n  // statements\n} while (condition);\n</code></pre>\n<p>Ejecuta los <code>statements</code> al menos una vez y luego tantas veces como se cumpla la\ncondición. Por ejemplo:</p>\n<pre><code class=\"language-js\">const pattern = /^[0-9]+$/;\nlet line;\ndo {\n  line = prompt('Enter a number:');\n} while(!pattern.test(line));\n</code></pre>\n<h3>for</h3>\n<p>En un ciclo for:</p>\n<pre><code class=\"language-js\">for ([init]; [condition]; [post_iteration]) {\n  // statements\n}\n</code></pre>\n<p><code>init</code> es ejecuta una vez antes que inicie el ciclo, que ejecuta <code>statements</code>\ntantas veces como <code>condition</code> sea <code>true</code>. Puedes usar <code>let</code> para declarar\nvariables, pero el scope de dicha variable solo será dentro del cliclo.\n<code>post_iteration</code> se ejecuta luego de cada iteración. Por ejemplo:</p>\n<pre><code class=\"language-js\">const arr = ['a', 'b', 'c'];\n\nfor (let i = 0, l = arr.length; i &#x3C; l; i++) {\n  console.log(arr[i]);\n}\n\n/*\n *\n * El resultado de este código es:\n * a\n * b\n * c\n *\n */\n</code></pre>"
            },
            "pt": {
              "title": "Laços (Loops)",
              "body": "<h2>Mecanismos que podem ser usados como laços</h2>\n<p>Os seguintes mecanismos podem ser usados como laços:</p>\n<h3><code>break [label]</code></h3>\n<p>Sai do laço.</p>\n<h3><code>continue [label]</code></h3>\n<p>Para a iteração atual e imediatamente executa a seguinte.</p>\n<h3><code>Labels</code></h3>\n<p>Uma <code>label</code> (etiqueta) é um identificador seguido por <code>:</code>. No início de um laço,\numa label pode fazer <code>break</code> ou <code>continue</code> inclusive se está dentro de um outro\nlaço aninhado. Quanto está no início do bloco, te permite sair do mesmo com a\npalavra <code>break</code>. Em ambos os casos, o nome da <em>label</em> se converte em um\nargumento de <code>break</code> ou <code>continue</code>. Aqui um exemplo de <code>break</code>:</p>\n<pre><code class=\"language-js\">const findEvenNumber = arr => {\n  loop: { // label\n    for (let i = 0, l = arr.length; i &#x3C; l; i++) {\n      let element = arr[i];\n      if (element % 2 === 0) {\n        console.log(`Found: ${element}`);\n        break loop;\n      }\n    }\n    console.log('No even number found.');\n  }\n  console.log('DONE');\n};\n</code></pre>\n<h2>Tipos de laços (loops)</h2>\n<h3>while</h3>\n<p>Um laço <code>while</code>:</p>\n<pre><code class=\"language-js\">while (condition) {\n  // statement\n}\n</code></pre>\n<p>Executa <code>statement</code> até que a condição não seja mais satisfeita. Se a condição é\nsempre <code>true</code>, então entra em um <code>infinite loop</code> (laço infinito).</p>\n<pre><code class=\"language-js\">// infinite loop\nwhile (1 === 1) { }\n</code></pre>\n<p>No próximo exemplo, eliminamos todos os elemento do <code>array</code> e os mostramos no\nconsole:</p>\n<pre><code class=\"language-js\">const arr = ['a', 'b', 'c'];\n\nwhile (arr.length > 0) {\n  console.log(arr.shift());\n}\n\n/*\n *\n * A saída do código será:\n * a\n * b\n * c\n *\n */\n</code></pre>\n<h3>do-while</h3>\n<p>Um laço <code>do-while</code>:</p>\n<pre><code class=\"language-js\">do {\n  // statements\n} while (condition);\n</code></pre>\n<p>Executa os <code>statements</code> pelo menos uma vez e continua enquanto a condição for\nsatisfeita. Por exemplo:</p>\n<pre><code class=\"language-js\">const pattern = /^[0-9]+$/;\nlet line;\ndo {\n  line = prompt('Enter a number:');\n} while(!pattern.test(line));\n</code></pre>\n<h3>for</h3>\n<p>Um laço <code>for</code>:</p>\n<pre><code class=\"language-js\">for ([init]; [condition]; [post_iteration]) {\n  // statements\n}\n</code></pre>\n<p><code>init</code> é executado uma vez antes de iniciar o laço, que depois executa\n<code>statements</code> enquanto a <code>condition</code> retorne <code>true</code>. Pode usar <code>let</code> para\ndeclarar variáveis, mas o escopo dela será apenas dentro do laço.\n<code>post_iteration</code> é executado logo após cada interação. Exemplo:</p>\n<pre><code class=\"language-js\">const arr = ['a', 'b', 'c'];\n\nfor (let i = 0, l = arr.length; i &#x3C; l; i++) {\n  console.log(arr[i]);\n}\n\n/*\n *\n * O resultado será esse:\n * a\n * b\n * c\n *\n */\n</code></pre>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "practical-cases",
          "type": "read",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Casos prácticos",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender, a través de casos prácticos, cómo aplicar los conceptos de\n<code>estructuras condicionales</code> y <code>estructuras repetitivas</code> para la resolución de\nproblemas</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Al igual que hemos hecho antes, es hora de aplicar los conceptos aprendidos para\nresolver problemas.</p>\n<p>A continuación tendrás varios problemas que debemos resolver. Intenta\nresolverlos primero por tu cuenta. Más abajo encontrarás las soluciones de\nMichelle. Después de haberlo intentado, compara tus soluciones con las de\nMichelle.</p>\n<h3>1. FizzBuzz</h3>\n<p>Escribe un programa que use <code>console.log</code> para imprimir todos los números del 1\nal 100, con dos excepciones:</p>\n<ul>\n<li>Para números divisibles por 3, imprime \"Fizz\" en vez del número</li>\n<li>Para números divisibles por 5 (pero no por 3), imprime \"Buzz\".</li>\n</ul>\n<p>Cuando tengas eso funcionando, modifica tu programa para imprimir \"FizzBuzz\"\npara los números que sean divisibles tanto por 3 como por 5 (y que siga\nimprimiendo \"Fizz\" o \"Buzz\" para números divisibles por sólo uno de ellos).</p>\n<h3>2. Tablero de Ajedrez</h3>\n<p>Crea un programa que cree un <code>string</code> que represente una cuadrícula de 8x8,\nusando el salto de línea como separador. En cada posición de la cuadrícula debe\nhaber un espacio o un carácter \"#\". Los caracteres deberían formar un tablero de\najedrez.</p>\n<p>Pasar ese <code>string</code> a console.log debería mostrar algo como esto:</p>\n<pre><code class=\"language-js\"> # # # #\n# # # #\n # # # #\n# # # #\n # # # #\n# # # #\n # # # #\n# # # #\n</code></pre>\n<p>Cuando tengas un programa que genere este patrón, define una variable <code>size</code> = 8\ny cambia el programa de tal manera que trabaje para cualquier tamaño, que sea\nproporcionado por un <code>prompt()</code> produciendo una cuadrícula del ancho y alto\ndado.</p>\n<h2>Solucionarios</h2>\n<p>A continuación, Michelle te explica cómo resolvió cada uno de los ejercicios\nanteriores.</p>\n<h3>1. FizzBuzz: Solucionario</h3>\n<p><a href=\"https://www.youtube.com/watch?v=jmKiCMKM33A\"><img src=\"https://img.youtube.com/vi/jmKiCMKM33A/0.jpg\" alt=\"FizzBuzz Solution\"></a></p>\n<h3>2. Tablero de Ajedrez: Solucionario</h3>\n<p><a href=\"https://www.youtube.com/watch?v=ckaXH2IhUrw\"><img src=\"https://img.youtube.com/vi/ckaXH2IhUrw/0.jpg\" alt=\"Tablero\"></a></p>"
            },
            "pt": {
              "title": "Casos práticos",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender através de casos prácticos como aplicar os conceitos de <code>estruturas condicionais</code> e <code>estruturas repetitivas</code> para a resolução de problemas</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Como fizemos antes, é hora de aplicar os conceitos aprendidos para resolver\nproblemas.</p>\n<h3>1. FizzBuzz</h3>\n<p>Escreva um programa que use <code>console.log</code> para imprimir todos os números de 1 a\n100, com duas exceções:</p>\n<ul>\n<li>Para números divisíveis por 3, imprima \"Fizz\" ao invés de número</li>\n<li>Para números divisíveis por 5 (mas não por 3), imprima \"Buzz\".</li>\n</ul>\n<p>Quando isto esteja funcionando, modifique o seu programa para imprimir\n\"FizzBuzz\" para os números que sejam divisíveis tanto por 3 como por 5 (e que\ncontinue imprimindo \"Fizz\" ou \"Buzz\" para números divisíveis por somente um\ndeles).</p>\n<h3>2. Tabuleiro de Xadrez</h3>\n<p>Elabore um programa que crie um <code>string</code> que represente um quadrado de 8x8,\npulando uma linha como separador. Em cada posição do quadrado deve haver um\nespaço ou um caracter \"#\". Os caracteres devem formar um tabuleiro de xadrez.</p>\n<p>Passar este <code>string</code> a console.log deve mostrar algo assim:</p>\n<pre><code class=\"language-js\"> # # # #\n# # # #\n # # # #\n# # # #\n # # # #\n# # # #\n # # # #\n# # # #\n</code></pre>\n<p>Quando você tiver um programa que gere este padrão, defina uma variável <code>size</code> =\n8 e mude o programa de tal forma que trabalhe para qualquer tamanho, que seja\nproporcionado por um <code>prompt()</code> produzindo um quadrado com as medidas indicadas.</p>\n<h2>Gabaritos</h2>\n<p>A seguir, o Rafael irá te explicar como ele resolveu cada um dos exercícios\nanteriores.</p>\n<h3>1. FizzBuzz: Gabarito</h3>\n<p><a href=\"https://www.youtube.com/watch?v=AwweNciBXZo\"><img src=\"https://img.youtube.com/vi/AwweNciBXZo/0.jpg\" alt=\"FizzBuzz\"></a></p>\n<h3>2. Tabuleiro de Xadrez: Gabarito</h3>\n<p><a href=\"https://www.youtube.com/watch?v=Ji_fnG3IYbE\"><img src=\"https://img.youtube.com/vi/Ji_fnG3IYbE/0.jpg\" alt=\"Tabuleiro\"></a></p>"
            }
          }
        },
        {
          "prefix": "03",
          "slug": "functions",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Funciones",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Conocer el concepto de <em>Don't Repeat Yourself (DRY)</em></li>\n<li>Entender qué son las funciones y cómo afectan el control de flujo de un\nprograma</li>\n<li>Conocer la estructura de las funciones en JavaScript</li>\n<li>Entender cómo pasarle argumentos a una función</li>\n<li>Entender el concepto de <code>return</code> de las funciones</li>\n</ul>\n<hr>\n<p>El texto a continuación se basa en gran medida, con ciertos ajustes, en los\ncapítulos 2 y 3 de <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn\nHaverbeke, 2014. Traducción en <a href=\"http://hectorip.github.io/Eloquent-JavaScript-ES-online/chapters/01_values.html\">Español</a>\ndisponible gracias a <a href=\"https://github.com/hectorip\">hectorip</a>, y del capítulo 8 de\n<a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for kids</a>,\nNick Morgan, 2015;</p>\n<h2>DRY</h2>\n<p>En la programación existe un concepto que escucharás más de una vez. Dice así:\n<em>\"Don't Repeat Yourself\"</em>, y es comunmente conocido como <code>DRY</code>. En español\nsignifica <em>\"no te repitas\"</em>. Si estás copiando y pegando pedazos de código, o si\ntienes sentencias de código similares a lo largo de tu programa, significa que\nte estás repitiendo. Ya hemos visto este concepto en práctica con el uso de\n<code>estructuras repetitivas</code> (bucles): en lugar de tener un mismo bloque de código\nrepetido, puedes sustituirlo por un <code>for</code> o un <code>while</code>. Con las funciones puedes\nalcanzar el mismo objetivo. Veamos qué son las <code>funciones</code>, cómo usarlas y por\nqué son importantes.</p>\n<h2>¿Qué es una función?</h2>\n<p>Una función es una forma de agrupar código para que pueda ser reutilizado. Las\nfunciones nos permiten ejecutar la misma pieza de código en varios lugares de un\nprograma sin tener que copiar y pegar el código repetidamente. Dicho de otra\nmanera, una función es un <strong>pedazo de programa envuelto en un valor</strong>. Ese valor\npuede ser \"llamado\" varias veces, en diferentes lugares de tu programa, para que\nejecute el código que tiene dentro.</p>\n<p>A lo largo de este curso hemos venido utilizando funciones, solo que las venimos\nllamando <em>\"comandos\"</em>. Los comandos como <code>alert()</code>, <code>prompt()</code> y <code>console.log()</code>\nson realmente funciones.</p>\n<h2>Funciones en JavaScript</h2>\n<p>Las funciones son el pan de cada día en la programación con JavaScript.</p>\n<p>La aplicación más obvia de las funciones es la de definir un nuevo vocabulario.\nCrear nuevas palabras en un lenguaje humano común (como el español o el inglés)\nes típicamente algo de mal gusto. Sin embargo, en la programación es\nindispensable.</p>\n<p>Un adulto promedio tiene unas 20,000 palabras en su vocabulario. Pocos lenguajes\nde programación tienen 20,000 comandos incorporados. Y el vocabulario que <em>sí</em>\nestá disponible tiende a ser definido de forma más precisa, y por ende menos\nflexible, que en un lenguaje humano. En consecuencia, usualmente <em>tenemos</em> que\nañadir algo de nuestro propio vocabulario para evitar repetirnos demasiado.</p>\n<p>Agrupando fragmentos de código en una función con un <strong>nombre fácil de\nentender</strong> (dado que será parte del vocabulario que estás construyendo) podemos\nestructurar mejor nuestro código. Esto porque nos enfocamos en organizar las\nfunciones, en lugar de cada línea de código que las componen. Al dividir nuestro\ncódigo en piezas más pequeñas - y por ende - más manejables, podemos tener una\nmirada más completa de lo que estamos haciendo. Nos permite elevarnos a un nivel\nsuperior de abstracción. Como dicen el refrán: podemos visualizar el bosque\ncompleto, viendo más allá de los árboles.</p>\n<h2>Definiendo una función</h2>\n<p>La definición de una función es simplemente una definición regular de una\nvariable, pero donde el valor dado a la variable es una función. Por ejemplo, el\nsiguiente código define la variable <code>square</code> para referirse a la <em>función</em> que\nproduce el cuadrado de un número dado:</p>\n<pre><code class=\"language-js\">const square = function (num) {\n  return num * num;\n};\n</code></pre>\n<p>La misma función usando la síntaxis de <em>función flecha</em> (arrow function):</p>\n<pre><code class=\"language-js\">const square = num => num * num;\n</code></pre>\n<p>Una función es creada por una expresión que empieza con el keyword <code>function</code>,\no alternativamente usando la síntaxis de <em>función flecha</em>. Las funciones tienen\nun conjunto de <em>parámetros</em> (en el ejemplo anterior solo tenemos <strong>un</strong>\nparámetro: <code>num</code>) y un <em>cuerpo</em>, que contiene las sentencias a ser ejecutadas.\nLos parámetros sirven para \"pasarle\" valores a la función y por ende, cambiar su\ncomportamiento según los valores brindados. Cuando declaramos una función usando\nel <em>keyword</em> <code>function</code> el cuerpo de la función tiene que estar siempre\nencerrado en llaves, incluso cuando consista de una sola instrucción (como en el\nejemplo previo), mientras que en las funciones flecha podemos hacer <em>retorno\nimplícito</em> cuando el cuerpo consta de solo una expresión (que será\nimplícitamente el valor de retorno).</p>\n<h2>Llamando una función</h2>\n<p>Para correr el código dentro de una función, necesitamos <em>\"invocar, llamar, o\naplicar\"</em> la función. Esto se hace escribiendo el nombre de la función\ninmediatamente seguido por unos paréntesis <code>()</code>. Dentro de los paréntesis se\nincluye lo que le quieres \"pasar\" a la función para usar como parámetro. Los\nvalores que se pasan a la función para usar como parámetros son llamados\n<em>argumentos</em>.</p>\n<p>Agregando al ejemplo anterior un llamado a la función <code>square</code> pasando como\nargumento el valor <code>12</code> vemos que nos devuelve <code>144</code> (es decir, 12 al cuadrado).</p>\n<pre><code class=\"language-js\">const square = function (num) {\n  return num * num;\n};\n\nsquare(12);\n// → 144\n</code></pre>\n<h2>El valor de retorno</h2>\n<p>Así como los argumentos son los valores de \"entrada\" (input) que utiliza una\nfunción al ser llamada, el valor de retorno es el valor de salida (output) que\ndevuelve la función (el <code>144</code> del ejemplo anterior), y que puede ser utilizado\nen cualquier lugar del programa. Si una función no especifica el valor de\nretorno, entonces, la función retorna <code>undefined</code>.</p>\n<p>El valor de retorno se especifica con el <em>keyword</em> <code>return</code>. En el ejemplo\nanterior, se especifica que el valor de retorno es el parámetro multiplicado por\nsí mismo; es decir, el parámetro al cuadrado. El keyword <code>return</code> sin una\nexpresión después de él, también hará que la función devuelva <code>undefined</code>.</p>\n<p>Agreguemos una sentencia adicional al ejemplo anterior en la que se utilice el\nvalor de retorno de la función <code>square</code>:</p>\n<pre><code class=\"language-js\">const square = function (num) {\n  return num * num;\n};\n\nconsole.log('El cuadrado de 12 es ' + square(12));\n// → El cuadrado de 12 es 144\n</code></pre>\n<p>Con esta modificación sucede lo siguiente: el valor de retorno que se obtiene al\nllamar (o invocar) la función <code>square</code> con el valor <code>12</code> de argumento es: <code>144</code>.\nÉste se concatena con el texto <code>'El cuadrado de 12 es '</code> para formar\n<code>'El cuadrado de 12 es 144'</code>; lo cual, a su vez, se pasa como argumento a la\nfunción <code>console.log</code> para que lo imprima en la consola.</p>\n<h2>Múltiples parámetros</h2>\n<p>Una función puede tener varios parámetros o puede no tener ninguno. En el\nsiguiente ejemplo <code>makeNoise</code> no tiene parámetros, mientras que <code>power</code> tiene\ndos:</p>\n<pre><code class=\"language-js\">const makeNoise = function () {\n  console.log('Pling!');\n};\n\nmakeNoise();\n// → Pling!\n\nconst power = function (base, exponent) {\n  let result = 1;\n  for (let count = 0; count &#x3C; exponent; count++) {\n    result *= base;\n  }\n  return result;\n};\n\nconsole.log(power(2, 10));\n// → 1024\n</code></pre>\n<p>A continuación Michelle te explica funciones con un ejemplo del libro JavaScript\nfor Kids.</p>\n<p><a href=\"https://www.youtube.com/watch?v=Y0NgsjdumS8\"><img src=\"https://img.youtube.com/vi/Y0NgsjdumS8/0.jpg\" alt=\"ejercicio guiado JS for Kids pg 128 funcion de imprimir caras\"></a></p>\n<h2>Saliendo de una función con <code>return</code></h2>\n<p>Cuando el intérprete JavaScript se topa con un <code>return</code> dentro de una función,\ninmediatamente salta fuera de la función actual y pasa el valor retornado al\ncódigo que la llamó. Es decir, cualquier sentencia que coloquemos <strong>después</strong>\ndel <code>return</code> en una función, <strong>no</strong> será ejecutada.</p>\n<p>Una forma común de utilizar <code>return</code> es para salir de la función de manera\ntemprana si alguno de los argumentos brindados no son válidos; es decir, si no\nson el tipo de argumentos que la función necesita para funcionar correctamente.\nPor ejemplo, la siguiente función devuelve una cadena que indica el quinto\ncaracter de tu nombre. Si el nombre pasado a la función tiene menos de cinco\ncaracteres, la función utiliza <code>return</code> para dejar la función inmediatamente.\nEsto significa que la declaración de devolución al final, que te dice la quinta\nletra de tu nombre, nunca se ejecuta.</p>\n<pre><code class=\"language-js\">const fifthLetter = function (name) {\n  if (name.length &#x3C; 5) {\n    return;\n  }\n  return 'La quinta letra de tu nombre es ' + name[4] + '.';\n};\n</code></pre>\n<h2>Funciones y control de flujo</h2>\n<p>Las funciones también afectan el control de flujo de nuestro programa. Con\nfunciones podemos crear estructuras repetitivas (con algo que se llama\n<code>recursividad</code>) y estructuras condicionales (con, por ejemplo, múltiples valores\nde <code>return</code>). De hecho, las funciones son tan versátiles para armar la\nestructura de un programa que existe todo un <em>paradigma de programación</em> basado\nen funciones. Es decir, existe toda una manera de pensar en la programación\nbasada en funciones. Esto se llama el <strong>paradigma de programación funcional</strong>.\nMás adelante estudiaremos a mayor profundidad funciones y el paradigma de\nprogramación funcional. Por ahora, lo importante es entender que las funciones\nson una forma de agrupar código para que pueda ser reutilizado.</p>\n<p>Veamos un ejemplo de crear una estructura condicional con funciones:</p>\n<h2>Utilizando múltiples <code>return</code> en lugar de <code>if... else</code></h2>\n<p>Podemos usar varios <code>return</code> dentro de diferentes sentencias <code>if</code> en el cuerpo\nde una función para que la función devuelva un valor diferente, dependiendo del\nargumento brindado. Por ejemplo, digamos que estás escribiendo un juego que\notorga medallas a los jugadores basándose en su puntuación. Una puntuación menor\na 3 es una medalla de bronce, una puntuación de 7 o más es oro, y lo que está en\nel medio es plata. Podrías utilizar una función como <code>medalForScore</code> para\nevaluar una puntuación y devolver el tipo de medalla, como se muestra aquí:</p>\n<pre><code class=\"language-js\">const medalForScore = function (score) {\n  if (score &#x3C; 3) {\n    return 'Bronze';\n  }\n  if (score &#x3C; 7) {\n    return 'Silver';\n  }\n  return 'Gold';\n};\n</code></pre>\n<p>Aunque estamos comprobando múltiples condiciones, no necesitamos usar sentencias\n<code>if ... else</code> encadenadas. Utilizamos las sentencias <code>if ... else</code> para\ngarantizar que sólo una de las sentencias se ejecute. Sin embargo, cuando cada\nuna de las opciones tiene su propia sentencia de <code>return</code>,  garantizamos que se\nejecute sólo una de las opciones --- porque, recuerda, <strong>las funciones sólo\npueden devolver una vez</strong>.</p>"
            },
            "pt": {
              "title": "Funções",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Conhecer o conceito de <em>Don't Repeat Yourself (DRY)</em></li>\n<li>Entender o que são as funções e como afetam o controle de fluxo de um programa</li>\n<li>Conhecer a estrutura das funções em JavaScript</li>\n<li>Entender como transmitir argumentos a uma função</li>\n<li>Entender o conceito de <code>return</code> das funções</li>\n</ul>\n<hr>\n<p>O texto a seguir se baseia em grande medida, com alguns ajustes, ao capítulo 2 e\n3do <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn Haverbeke,\n2014. Tradução em\n<a href=\"https://github.com/braziljs/eloquente-javascript/blob/master/chapters/01-valores-tipos-operadores.md\">Português</a>.</p>\n<h2>DRY</h2>\n<p>Na programação, existe um conceito que você escutará mais de uma vez. Ele diz o\nseguinte: <em>\"Don't Repeat Yourself\"</em>, e é comumente conhecido como <code>DRY</code>. Em\nportuguês significa <em>\"não se repita\"</em>. Se você estiver copiando e colando\npedaços de código, ou se tiver sentenças de código similares ao longo do seu\nprograma, significa que você está se repetindo. Já vimos este conceito em\nprática com o uso de <code>estruturas repetitivas</code> (loop): ao invés de ter um mesmo\nbloco de código repetido, você pode sustituí-lo por um <code>for</code> ou um <code>while</code>. Com\nas funções você pode alcançar o mesmo objetivo. Vejamos quais são as <code>funções</code>,\ncomo usá-las e por que são importantes.</p>\n<h2>O que é uma função?</h2>\n<p>Uma função é uma forma de agrupar código para que ele possa ser reutilizado. As\nfunções nos permitem executar a mesma peça de código em vários lugares de um\nprograma sem ter que copiar e colar o código repetidamente. Dito de outra\nmaneira, uma função é um <strong>pedaço de programa embrulhado em um valor</strong>. Esse\nvalor pode ser \"chamado\" várias vezes, em diferentes lugares do teu programa,\npara que execute o código que está ali dentro.</p>\n<p>Ao longo deste curso temos utilizado funções, porém temos chamado de\n<em>\"comandos\"</em>. Os comandos como <code>alert()</code>, <code>prompt()</code> e <code>console.log()</code> são de\nfato funções.</p>\n<h2>Funções em JavaScript</h2>\n<p>As funções são o pão de cada dia na programação com JavaScript.</p>\n<p>A aplicação mais óbvia das funções é a de definir um novo vocabulário. Criar\nnovas palavras em uma linguagem humana comum (como o português, inglês ou o\nespanhol) é tipicamente algo de mal gosto. Contudo, na programação isto é\nindispensável.</p>\n<p>Um adulto médio possui umas 20.000 palavras em seu vocabulário. Poucas\nlinguagens de programação possuem 20.000 comandos incorporados. E o vocabulário\nque está disponível na programação tende a ser definido de forma mais precisa, e\nportanto menos flexível que em uma linguagem humana. Como consequência,\nusualmente <em>precisamos</em> agregar algo do nosso próprio vocabulário para evitar\nmuitas repetições.</p>\n<p>Agrupando fragmentos de código em uma função com um <strong>nome fácil de entender</strong>\n(dado que será parte do vocabulário que você está construindo) podemos\nestruturar melhor nosso código. Isto porque nos enfocamos em organizar as\nfunções, ao invés de cada linha de código que as compõem. Ao dividir nosso\ncódigo em peças menores e portanto mais fáceis de lidar, podemos ter uma visão\nmais completa do que estamos fazendo. Nos permite elevar-nos a um nível superior\nde abstração. Como diz o ditado: podemos visualizar a floresta completa, vendo\nalém das árvores.</p>\n<h2>Definindo uma função</h2>\n<p>A definição de uma função é simplesmente uma definição regular de uma variável,\nmas onde o valor dado à variável é uma função. Por exemplo, o código a seguir\ndefine a variável <code>square</code> para se referir à <em>função</em> que produz o quadrado de\num número dado:</p>\n<pre><code class=\"language-js\">const square = function (num) {\n  return num * num;\n};\n</code></pre>\n<p>A mesma função usando a sintaxe de <em>função flecha</em> (arrow function):</p>\n<pre><code class=\"language-js\">const square = num => num * num;\n</code></pre>\n<p>Uma função é criada por uma expressão que começa com o keyword <code>function</code>, ou\npode ser usando a sintaxe de <em>arrow function</em>. As funções possuem um conjunto de\n<em>parâmetros</em> (no exemplo anterior só temos <strong>um</strong> parâmetro: <code>num</code>) e um\n<em>corpo</em>, que contêm as sentenças a serem executadas. Os parâmetros servem para\n\"transmitir\" valores à função e, assim, mudar seu comportamento segundo os\nvalores oferecidos. O corpo da função, usando a <em>keyword</em> <code>function</code>, precisa\nestar sempre fechado em chaves, inclusive quando houver uma única instrução\n(como no exemplo anterior), enquanto funções usando <em>arrow function</em> podemos\nfazer o retorno implícito quando o corpo possui apenas uma expressão. (que será\nimplícitamente o valor do retorno).</p>\n<h2>Chamando uma função</h2>\n<p>Para rodar o código dentro de uma função, necessitamos <em>\"invocar, chamar, ou\naplicar\"</em> a função. Isto se faz escrevendo o nome da função imediatamente\nseguido por parênteses <code>()</code>. Dentro dos parênteses se inclui o que você quer\n\"transmitir\" à função para usar como parâmetro. Os valores que se transmitem à\nfunção para usar como parâmetros são chamados <em>argumentos</em>.</p>\n<p>Agregando ao exemplo anterior um chamado à função <code>square</code> transmitindo-lhe como\nargumento o valor <code>12</code> vemos que nos devolve <code>144</code> (ou seja, 12 ao quadrado).</p>\n<pre><code class=\"language-js\">const square = function (num) {\n  return num * num;\n};\n\nsquare(12);\n// → 144\n</code></pre>\n<h2>O valor de retorno</h2>\n<p>Assim como os argumentos são os valores de \"entrada\" (input) que utiliza uma\nfunção ao ser chamada, o valor de retorno é o valor de saída (output) que\ndevolve a função (o <code>144</code> do exemplo anterior), e que pode ser utilizado em\nqualquer lugar do programa. Se uma função não especifica o valor de retorno,\nentão a função retorna <code>undefined</code>.</p>\n<p>O valor de retorno se especifica com o <em>keyword</em> <code>return</code>. No exemplo anterior,\nse especifica que o valor de retorno é o parâmetro multiplicado por si mesmo;\nisto é, o parâmetro ao quadrado. O keyword <code>return</code> sem uma expressão depois\ndele também fará com que a função devolva <code>undefined</code>.</p>\n<p>Adicionemos uma outra sentença ao exemplo anterior na qual se utilize o valor de\nretorno da função <code>square</code>:</p>\n<pre><code class=\"language-js\">const square = function (num) {\n  return num * num;\n};\n\nconsole.log('El cuadrado de 12 es ' + square(12));\n// → El cuadrado de 12 es 144\n</code></pre>\n<p>Com esta mudança acontece o seguinte: o valor de retorno que se obtém ao chamar\n(ou invocar) a função <code>square</code> com o valor <code>12</code> de argumento é: <code>144</code>. Este se\nconcatena com o texto <code>'O quadrado de 12 é '</code> para formar <code>'O quadrado de 12 é 144'</code>; o qual, por sua vez, se transmite como argumento à função <code>console.log</code>\npara que o imprima no painel de comando.</p>\n<h2>Múltiplos parâmetros</h2>\n<p>Uma função pode ter vários parâmetros ou pode não ter nenhum. No seguinte\nexemplo, <code>makeNoise</code> não tem parâmetros, enquanto <code>power</code> tem dois:</p>\n<pre><code class=\"language-js\">const makeNoise = function () {\n  console.log('Pling!');\n};\n\nmakeNoise();\n// → Pling!\n\nconst power = function (base, exponent) {\n  let result = 1;\n  for (let count = 0; count &#x3C; exponent; count++) {\n    result *= base;\n  }\n  return result;\n};\n\nconsole.log(power(2, 10));\n// → 1024\n</code></pre>\n<p>A seguir Daniel te explica mais sobre funções:\n<a href=\"https://www.youtube.com/watch?v=68743wkEjiw\"><img src=\"https://img.youtube.com/vi/68743wkEjiw/0.jpg\" alt=\"Funções\"></a></p>\n<h2>Saindo de uma função com <code>return</code></h2>\n<p>Quando o intérprete JavaScript observa um <code>return</code> dentro de uma função,\nimediatamente pula fora da função atual e passa o valor retornado ao código que\na chamou. Isto é, qualquer sentença que coloquemos <strong>depois</strong> do <code>return</code> em uma\nfunção, <strong>não</strong> será executada.</p>\n<p>Uma forma comum de utilizar <code>return</code> é para sair da função antecipadamente caso\nalgum dos argumentos brindados não seja válido; isto é, se não forem o tipo de\nargumentos que a função necessita para funcionar corretamente. Por exemplo, a\nseguinte função devolve uma cadeia que indica o quinto caracter do seu nome. Se\no nome transmitido à função tem menos de cinco caracteres, a função utiliza\n<code>return</code> para deixar a função imediatamente. Isto significa que a declaração de\ndevolução ao final, que te diz a quinta letra do seu nome, nunca se executa.</p>\n<pre><code class=\"language-js\">const fifthLetter = function (name) {\n  if (name.length &#x3C; 5) {\n    return;\n  }\n  return 'A quinta letra do seu nome é' + name[4] + '.';\n};\n</code></pre>\n<h2>Funções e controle de fluxo</h2>\n<p>A funções também afetam o controle de fluxo do nosso programa. Com funções\npodemos criar estruturas repetitivas (com algo que se chama <code>recursividade</code>) e\nestruturas condicionais (com, por exemplo, múltiplos valores de <code>return</code>). De\nfato, as funções são tão versáteis para armar a estrutura de um programa que\nexiste todo um <em>paradigma de programação</em> baseado em funções. Isto é, existe uma\nmaneira de pensar na programação que está baseada em funções. Isto se chama o\n<strong>paradigma de programação funcional</strong>. Mais adiante estudaremos com mais\nprofundidade funções e o paradigma de programação funcional. Por enquanto, o\nimportante é entender que as funções são uma forma de agrupar código para que\npossa ser reutilizado.</p>\n<h2>Utilizando múltiplos <code>return</code> no lugar de <code>if... else</code></h2>\n<p>Podemos usar vários <code>return</code> dentro de diferentes sentenças <code>if</code> no corpo de uma\nfunção para que a função devolva um valor diferente, dependendo do argumento\noferecido. Por exemplo, digamos que você está escrevendo um jogo que dá medalhas\naos jogadores conforme a sua pontuação. Uma pontuação menor a 3 é uma medalha de\nbronze, uma pontuação de 7 ou mais é ouro, e o que está no meio é prata. Você\npoderia utilizar uma função como <code>medalForScore</code> para avaliar uma pontuação e\ndar o tipo de medalha, como se mostra aqui:</p>\n<pre><code class=\"language-js\">const medalForScore = function (score) {\n  if (score &#x3C; 3) {\n    return 'Bronze';\n  }\n  if (score &#x3C; 7) {\n    return 'Silver';\n  }\n  return 'Gold';\n};\n</code></pre>\n<p>Embora estejamos comprovando múltiplas condições, não necessitamos usar\nsentenças <code>if ... else</code> encadeadas. Utilizamos as sentenças <code>if ... else</code> para\ngarantir que somente uma das sentenças se execute. Quando cada uma das opções\npossui sua própria sentença de <code>return</code>,  garantimos que se execute somente uma\ndas opções --- porque, lembre-se, <strong>as funções só podem devolver uma vez</strong>.</p>"
            }
          }
        },
        {
          "prefix": "05",
          "slug": "guided-exercises",
          "type": "practice",
          "duration": 120,
          "intl": {
            "es": {
              "title": "Ejercicios Guiados",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Practicar codeando junto a tu equipo de profes, resolviendo problemas de\nestructuras condicionales, repetitivas y funciones</li>\n<li>Practicar, practicar y practicar</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>A continuación tienes más problemas de práctica. Estos problemas serán\nresueltos, paso a paso, por tu equipo de profes en una clase presencial.</p>\n<p>Te sugerimos que intentes resolver los ejercicios por tu cuenta (o en equipo)\n<strong>antes</strong> de la sesión presencial. Así, ya vienes con dudas específicas y\nestarás familiarizada con los retos. Quizás, puedas tú presentar tu solución\nante el resto de la clase y así ayduar al resto de tus compañeras :)</p>\n<h3>1. Funciones matemáticas</h3>\n<p>Crea dos funciones, <code>add</code> y <code>multiply</code>. Cada una debe tomar dos argumentos. La\nfunción <code>add</code> debe sumar sus argumentos y devolver el resultado. La funcion\n<code>multiply</code> debe multiplicar sus argumentos. Usando solamente estas dos\nfunciones, resuelva este simple problema matemático: 36325 * (9824 + 777).</p>\n<h3>2. Ordenando comida</h3>\n<p>Imagina que estás pidiendo comida en un restaurante. Tu plato favorito es\n<code>ceviche</code>, así que lo elegirías si está en el menú. Si no hay <code>ceviche</code>,\nelegirías <code>tacos al pastor</code>. Si eso no está, te irías por <code>empanada chilena</code>.\nEn el caso raro que ninguna de esas opciones esté disponible, te irías por una\n<code>hamburguesa</code>. Escribe una función, que de acuerdo a la disponibilidad de los\nplatos en el menú, decidas qué ordenar.</p>\n<h3>3. Edades y etapas</h3>\n<p>Crea una web que pida, por medio de un <code>prompt()</code>, la edad de una persona, en\naños. Dependiendo del número brindado, la web debe dar un mensaje que clasifica\na la persona en: <code>toddler</code>, <code>preschooler</code>, <code>gradeschooler</code>, <code>teenager</code>,\n<code>young adult</code> and <code>adult</code>, según el criterio de esta\n<a href=\"https://www.healthychildren.org/English/ages-stages/Pages/default.aspx\">página</a>.</p>\n<p>Si la persona ingresa un dato que <strong>no</strong> es un número entero (por ejemplo: un\n<code>string</code>, un número decimal, un cero, o un campo vacío), la web debe dar un\nmensaje de error. Revisa este <a href=\"https://stackoverflow.com/questions/3885817/how-do-i-check-that-a-number-is-float-or-integer\">link</a>\nque tiene un par de tips interesantes relacionados a este proyecto.</p>\n<h3>4. Contando caracteres y espacios</h3>\n<p>Crea una web que pida, por medio de un <code>prompt()</code>, una frase al usuario. La web\ndebe presentar un mensaje que diga: el número de caracteres y de espacios que\ncomponen el <code>string</code> ingresado. En la consola, debe aparecer cada caracter\nimpreso en una línea separada, en mayúscula. Si el usuario ingresa un campo\nvacío, la web debe dar un mensaje de error.</p>\n<p>Arma tu archivo JavaScript para que tenga 3 funciones:</p>\n<ul>\n<li>Una función que imprima todos los caracteres de un <code>string</code>, cada uno en una\nlínea separada, en mayúscula.</li>\n<li>Una función que cuente el número de caracteres de un <code>string</code> (¡sin utilizar\n<code>.length</code>!)</li>\n<li>Una función que cuente el número de espacios de un <code>string</code></li>\n</ul>"
            },
            "pt": {
              "title": "Exercícios Livres",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Praticar codeando junto com a sua equipe de mentores, resolvendo problemas de\nestruturas condicionais, repetitivas e funções</li>\n<li>Praticar, praticar e praticar</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Aqui estão alguns exercícios para você praticar, sugerimos que tenta resolver\neles sozinha ou em grupo. Assim, você ficará familiarizada com os desafios. E se\nquiser pode apresentar a sua solução para a sala e ajudar as suas companheiras\n😁</p>\n<h3>1. Funções matemáticas</h3>\n<p>Crie duas funções, <code>add</code> e <code>multiply</code>. Cada uma deve tomar dois argumentos. A\nfunção <code>add</code> deve somar seus argumentos e devolver o resultado. A função\n<code>multiply</code> deve multiplicar seus argumentos. Usando somente estas duas funções,\nresolva este simples problema matemático: 36325 * (9824 + 777).</p>\n<h3>2. Organizando comida</h3>\n<p>Imagine que você está pedindo comida em um restaurante. O seu prato favorito é\n<code>ceviche</code> e por isso você o escolheria se houvesse no menú. Se não houver\n<code>ceviche</code>, escolheria <code>tacos al pastor</code>. Se este último não houver, você então\npediria <code>empanada chilena</code>. No caso raro que nenhuma destas opções esteja\ndisponível, você iria por um <code>hamburguer</code>. Escreva uma função, que de acordo com\na disponibilidade dos pratos no menú, você decida o que pedir.</p>\n<h3>3. Idades e etapas</h3>\n<p>Crie uma web que peça, por meio de um <code>prompt()</code>, a idade de uma pessoa, em\nanos. Dependendo do número oferecido, a web deve dar uma mensagem que classifica\na pessoa em: <code>toddler</code>, <code>preschooler</code>, <code>gradeschooler</code>, <code>teenager</code>, <code>young adult</code> e <code>adult</code>, segundo o critério desta\n<a href=\"https://www.healthychildren.org/English/ages-stages/Pages/default.aspx\">página</a>.</p>\n<p>Se a pessoa coloca um dado que <strong>não</strong> é um número inteiro (por exemplo: um\n<code>string</code>, um número decimal, um zero, ou um campo vazio), a web deve dar uma\nmensagem de erro. Revise este\n<a href=\"https://stackoverflow.com/questions/3885817/how-do-i-check-that-a-number-is-float-or-integer\">link</a>\nque possui dicas interessantes relacionadas a este projeto.</p>\n<h3>4. Contando caracteres e espaços</h3>\n<p>Crie uma web que peça, por meio de um <code>prompt()</code>, uma frase ao usuário. A web\ndeve apresentar uma mensagem que diga: o número de caracteres e de espaços que\ncompõem o <code>string</code> inserido. No painel, deve aparecer cada caracter impresso em\numa linha separada, em maiúscula. Se o usuário insere um campo vazio, a web deve\ndar uma mensagem de erro.</p>\n<p>Arme seu arquivo JavaScript para que tenha 3 funções:</p>\n<ul>\n<li>Uma função que imprima todos os caracteres de um <code>string</code>, cada um em uma\nlinha separada, em maiúscula.</li>\n<li>Una função que conte o número de caracteres de um <code>string</code> (sem utilizar\n<code>.length</code>!)</li>\n<li>Uma função que conte o número de espaços de um <code>string</code></li>\n</ul>"
            }
          },
          "challenges": []
        },
        {
          "prefix": "06",
          "slug": "code-challenges",
          "type": "practice",
          "duration": 120,
          "intl": {
            "es": {
              "title": "Retos de Código",
              "body": ""
            },
            "pt": {
              "title": "Desafios de Código",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "power-of-two",
              "prefix": "01",
              "path": "topics/javascript/02-flow-control/06-code-challenges/01-power-of-two",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Potencia de 2",
                  "body": "<p>Calcula la potencia de 2 elevado a un número específico. Debes de usar un loop\n(no <code>Math.pow()</code>).</p>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = powerOfTwo(10);\n\nconsole.log(ouput); // -> 1024\n</code></pre>"
                },
                "pt": {
                  "title": "Potência de 2",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Calcule a potência de 2 elevado a um número específico.\nDeve usar um loop (não usar <code>Math.pow()</code>).</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-js\">const output = powerOfTwo(10);\n\nconsole.log(ouput); // -> 1024\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/powerOfTwo.js": "const powerOfTwo = (number) => {\n\n};\n\nmodule.exports = powerOfTwo;\n",
                "/solution/.eslintrc": "{\n  \"rules\": {\n    \"no-param-reassign\": \"off\"\n  }\n}\n",
                "/solution/powerOfTwo.js": "const powerOfTwo = (number) => {\n  let result = 1;\n\n  while (number > 0) {\n    result *= 2;\n    number -= 1;\n  }\n\n  return result;\n};\n\nmodule.exports = powerOfTwo;\n",
                "/test/powerOfTwo.spec.js": "const Assert = require('chai').assert;\nconst powerOfTwo = require('../solution/powerOfTwo');\n\ndescribe('powerOfTwo()', () => {\n  it('debería regresar la potencia de 2 elevado al número ingresado cuando es positivo', () => {\n    const output = powerOfTwo(10);\n    Assert.deepEqual(output, 1024);\n  });\n\n  it('debería regresar 1 cuando el número ingresado es 0', () => {\n    const output = powerOfTwo(0);\n    Assert.deepEqual(output, 1);\n  });\n\n  it('debería regresar 1 cuando el número ingresado es negativo', () => {\n    const output = powerOfTwo(-5);\n    Assert.deepEqual(output, 1);\n  });\n});\n"
              }
            },
            {
              "slug": "reverse",
              "prefix": "02",
              "path": "topics/javascript/02-flow-control/06-code-challenges/02-reverse",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Invertir un arreglo",
                  "body": "<p>Usar estructuras de control para invertir un arreglo de números. Como entrada\nrecibirás un arreglo de números u objetos y como salida se espera un arreglo con\nel orden invertido de los elementos.</p>\n<blockquote>\n<p>No es válido usar <code>arr.reverse()</code>.</p>\n</blockquote>\n<p>Ejemplo:</p>\n<pre><code class=\"language-javascript\">const output = reverse([1, 2, 3, 4]);\n\nconsole.log(ouput); // -> [4, 3, 2, 1]\n</code></pre>"
                },
                "pt": {
                  "title": "Inverter uma array",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Use estruturas de controle para inverter uma array de inteiros.\nComo entrada receberá uma array de números ou objetos e como\nsaída é esperada uma array com a ordem dos elementos invertida.</p>\n<blockquote>\n<p>Não é válido utilizar <code>arr.reverse()</code>.</p>\n</blockquote>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = reverse([1, 2, 3, 4]);\n\nconsole.log(ouput); // -> [4, 3, 2, 1]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/reverse.js": "const reverse = (array) => {\n\n};\n\nmodule.exports = reverse;\n",
                "/solution/reverse.js": "const reverse = (array) => {\n  const result = [];\n\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    result.push(array[i]);\n  }\n\n  return result;\n};\n\nmodule.exports = reverse;\n",
                "/test/reverse.spec.js": "const Assert = require('chai').assert;\nconst reverse = require('../solution/reverse');\n\ndescribe('reverse()', () => {\n  it('debería regresar el arreglo invertido cuando es un arreglo de números', () => {\n    const output = reverse([1, 2, 3, 4]);\n    Assert.deepEqual(output, [4, 3, 2, 1]);\n  });\n\n  it('debería regresar el arreglo invertido cuando es un arreglo de caracteres', () => {\n    const output = reverse(['j', 'a', 'v', 'a', 's', 'c', 'r', 'i', 'p', 't']);\n    Assert.deepEqual(output, ['t', 'p', 'i', 'r', 'c', 's', 'a', 'v', 'a', 'j']);\n  });\n\n  it('debería regresar el arreglo invertido cuando es un arreglo de objetos', () => {\n    const output = reverse([{ country: 'Chile' }, { country: 'México' }, { country: 'Perú' }]);\n    Assert.deepEqual(output, [{ country: 'Perú' }, { country: 'México' }, { country: 'Chile' }]);\n  });\n\n  it('debería regresar el arreglo vacío cuando es un arreglo vacío', () => {\n    const output = reverse([]);\n    Assert.deepEqual(output, []);\n  });\n});\n"
              }
            },
            {
              "slug": "count-vowels",
              "prefix": "03",
              "path": "topics/javascript/02-flow-control/06-code-challenges/03-count-vowels",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Contar vocales",
                  "body": "<p>Crea una función que cuente el número de vocales de un <code>string</code>. Sigue los pasos\na continuación para que completes el programa.</p>\n<ol>\n<li>Implementar la función <code>countVowels(str)</code> que retorne el número de vocales.</li>\n<li>Iniciar un contador en <code>counter = 0</code></li>\n<li>Iterar los caracteres de string, si el elemento actual es una vocal entonces\nincrementar el contador <code>counter</code>.</li>\n<li>Retornar <code>counter</code>, el cual contiene el número de vocales.</li>\n</ol>"
                },
                "pt": {
                  "title": "Contar vogais",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Crie uma função que conte o número de vogais em uma <code>string</code>.\nSiga os passos a seguir para completar o programa.</p>\n<ol>\n<li>Implementar a função <code>countVowels(str)</code> que retorne o número de vogais.</li>\n<li>Iniciar um contador em <code>counter = 0</code></li>\n<li>Iterar os caracteres da string; se o elemento atual é uma vogal\nentão incrementar o contador <code>counter</code>.</li>\n<li>Retornar <code>counter</code>, que contém o número de vogais.</li>\n</ol>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/countVowels.js": "const countVowels = (str) => {\n\n\n};\n\nmodule.exports = countVowels;\n",
                "/solution/countVowels.js": "const countVowels = (str) => {\n  const vowels = 'aeiou';\n  const lowercased = str.toLowerCase();\n  let counter = 0;\n\n  for (let i = 0; i < lowercased.length; i += 1) {\n    for (let j = 0; j < vowels.length; j += 1) {\n      if (lowercased[i] === vowels[j]) {\n        counter += 1;\n      }\n    }\n  }\n\n  return counter;\n};\n\nmodule.exports = countVowels;\n",
                "/test/countVowels.spec.js": "const Assert = require('chai').assert;\nconst countVowels = require('../solution/countVowels');\n\ndescribe('countVowels(string)', () => {\n  it('debería retornar cuantas vocales hay en un string', () => {\n    Assert.deepEqual(countVowels('murcielago'), 5);\n    Assert.deepEqual(countVowels('sol'), 1);\n    Assert.deepEqual(countVowels('abecedario'), 6);\n  });\n\n  it('debería retornar 0 si el string está vacío', () => {\n    Assert.deepEqual(countVowels(''), 0);\n  });\n});\n"
              }
            },
            {
              "slug": "even-or-odd",
              "prefix": "04",
              "path": "topics/javascript/02-flow-control/06-code-challenges/04-even-or-odd",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Función par/impar",
                  "body": "<p>Crea una función que compruebe si un número es par o impar.</p>\n<p>Sigue los pasos a continuación para que completes el programa.</p>\n<ol>\n<li>Implementa una función <code>comprobar(n)</code>. Nota: Puedes usar el operador modulo:\n<code>%</code>.</li>\n<li>Si el número es par retornar <code>0</code>.</li>\n<li>Si el número es impar  retornar <code>1</code>.</li>\n</ol>"
                },
                "pt": {
                  "title": "Funcão par/impar",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Crie uma função que verifique se um número é par ou ímpar.\nSiga os passos a seguir para completar o programa.</p>\n<ol>\n<li>Declare uma função <code>comprobar(n)</code>. Nota: pode utilizar o\noperador de módulo: <code>%</code>.</li>\n<li>Se o número é par, retornar <code>0</code>.</li>\n<li>Se o número é ímpar, retornar <code>1</code>.</li>\n</ol>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/evenOrOdd.js": "const evenOrOdd = (n) => {\n\n};\n\nmodule.exports = evenOrOdd;\n",
                "/solution/evenOrOdd.js": "module.exports = n => ((n % 2 === 0) ? 0 : 1);\n",
                "/test/evenOrOdd.spec.js": "const Assert = require('chai').assert;\nconst evenOrOdd = require('../solution/evenOrOdd');\n\ndescribe('evenOrOdd(n)', () => {\n  it('debería retornar si el número que se pasa como parámetro es par o impar', () => {\n    Assert.deepEqual(evenOrOdd(5), 1);\n    Assert.deepEqual(evenOrOdd(66), 0);\n    Assert.deepEqual(evenOrOdd(20), 0);\n    Assert.deepEqual(evenOrOdd(35), 1);\n  });\n});\n"
              }
            },
            {
              "slug": "max",
              "prefix": "05",
              "path": "topics/javascript/02-flow-control/06-code-challenges/05-max",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Número mayor que otro",
                  "body": "<p>Implementa una función que determine si un número es mayor a otro.</p>\n<p>Sigue los pasos a continuación para que completes el programa:</p>\n<ol>\n<li>Retornar el numero mayor entre A, B y C</li>\n</ol>\n<p>Input: A = 10, B = 30, C = 5\nOutput: 30</p>"
                },
                "pt": {
                  "title": "Número maior que outro",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Implementa uma função que determine se um número é maior que outro.</p>\n<p>Siga os passos a seguir para completar o programa:</p>\n<ol>\n<li>Retornar o maior número entre A, B e C</li>\n</ol>\n<p>Input: A = 10, B = 30, C = 5\nOutput: 30</p>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/max.js": "const max = (A, B, C) => {\n\n\n};\n\nmodule.exports = max;\n",
                "/solution/max.js": "const max = (A, B, C) => {\n  let maximo = A;\n\n  if (A > B) {\n    if (A > C) {\n      maximo = A;\n    } else {\n      maximo = C;\n    }\n  } else if (B > C) {\n    maximo = B;\n  } else {\n    maximo = C;\n  }\n\n  return maximo;\n};\n\nmodule.exports = max;\n",
                "/test/max.spec.js": "const Assert = require('chai').assert;\nconst max = require('../solution/max');\n\ndescribe('max()', () => {\n  it('debería retornar el número que sea mayor', () => {\n    Assert.deepEqual(max(5, 6, 7), 7);\n    Assert.deepEqual(max(66, 4, 6), 66);\n    Assert.deepEqual(max(20, 25, 10), 25);\n  });\n});\n"
              }
            },
            {
              "slug": "is-prime",
              "prefix": "06",
              "path": "topics/javascript/02-flow-control/06-code-challenges/06-is-prime",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Determinar si un número es primo",
                  "body": "<p>Crea una función que determine si un número es primo. En matemáticas, un número\nprimo es un número natural mayor que 1 que tiene únicamente dos divisores\ndistintos: él mismo y el 1.</p>\n<p>Tips:</p>\n<ol>\n<li>Utilizar el operador  modulo (<code>%</code>) para determinar si un número es divisor de\notro.</li>\n</ol>"
                },
                "pt": {
                  "title": "Determinar se um número é primo",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Crie uma função que determine se um número é primo. Em matemática,\num número primo é um número natural maior que 1 que é divisível\nsomente por ele mesmo e 1.</p>\n<p>Tips:</p>\n<ol>\n<li>Utilizar o operador módulo (<code>%</code>) para determinar se um número é\ndivisível por outro.</li>\n</ol>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/isPrime.js": "const isPrime = (n) => {\n\n\n};\n\nmodule.exports = isPrime;\n",
                "/solution/isPrime.js": "const isPrime = (n) => {\n  if (n === 1) {\n    return true;\n  }\n\n  for (let i = 2; i < n; i += 1) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n\nmodule.exports = isPrime;\n",
                "/test/isPrime.spec.js": "const Assert = require('chai').assert;\nconst isPrime = require('../solution/isPrime');\n\ndescribe('isPrime(n)', () => {\n  it('debería retornar si el número que se da como parámetro es primo o no', () => {\n    Assert.deepEqual(isPrime(5), true);\n    Assert.deepEqual(isPrime(6), false);\n    Assert.deepEqual(isPrime(23), true);\n    Assert.deepEqual(isPrime(35), false);\n  });\n});\n"
              }
            },
            {
              "slug": "can-drive-and-vote",
              "prefix": "07",
              "path": "topics/javascript/02-flow-control/06-code-challenges/07-can-drive-and-vote",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Puedes conducir y votar?",
                  "body": "<p>Crea una función que determine si una persona puede manejar (16 años o más) y\nvotar (18 años o más)</p>\n<p>Sigue los pasos a continuación para que completes el programa:</p>\n<ol>\n<li>Implementar la función comprobar.</li>\n<li>Si cumple con la condición  (16 años o más) y votar (18 años o más)\nentonces retornar true; en caso contrario retornar false.</li>\n</ol>"
                },
                "pt": {
                  "title": "Pode dirigir e votar?",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Crie uma função que determine se uma pessoa pode dirigir nos EUA (16 anos ou mais)\ne votar (18 anos ou mais).</p>\n<p>Siga os passos a seguir para completar o programa:</p>\n<ol>\n<li>Implemente a função <code>comprobar</code></li>\n<li>Se o valor cumpre a condição dirigir (16 anos ou mais)\ne votar (18 anos ou mais), então retorna <code>true</code>; caso\ncontrário, retornar <code>false</code></li>\n</ol>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/canDriveAndVote.js": "const canDriveAndVote = (edad) => {\n\n\n};\n\nmodule.exports = canDriveAndVote;\n",
                "/solution/canDriveAndVote.js": "const canDriveAndVote = (edad) => {\n  if (edad >= 16 && edad >= 18) {\n    return true;\n  }\n\n  return false;\n};\n\nmodule.exports = canDriveAndVote;\n",
                "/test/canDriveAndVote.spec.js": "const Assert = require('chai').assert;\nconst canDriveAndVote = require('../solution/canDriveAndVote');\n\ndescribe('canDriveAndVote()', () => {\n  it('debería retornar true si cumple con ambas condiciones (16 años o más y 18 años o más), en caso contrario retornar false', () => {\n    Assert.deepEqual(canDriveAndVote(25), true);\n    Assert.deepEqual(canDriveAndVote(12), false);\n    Assert.deepEqual(canDriveAndVote(16), false);\n  });\n});\n"
              }
            },
            {
              "slug": "are-odd",
              "prefix": "08",
              "path": "topics/javascript/02-flow-control/06-code-challenges/08-are-odd",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Determinar si dos números son pares",
                  "body": "<p>Implementa una función que determine si dos número son pares.</p>\n<p>Sigue los pasos a continuación para que completes el programa:</p>\n<ol>\n<li>Si <code>n</code> y <code>m</code> son pares retornar <code>true</code>; en caso contrario retornar <code>false</code>.</li>\n</ol>\n<p>Tip: Usar el operador modulo (<code>%</code>)</p>"
                },
                "pt": {
                  "title": "Determinar se dois números são pares",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Implemente uma função que determina se dois números são pares.</p>\n<p>Siga os passos a seguir para completar o programa:</p>\n<ol>\n<li>Se <code>n</code> e <code>m</code> são pares retornar <code>true</code>; caso contrário retornar <code>false</code>.</li>\n</ol>\n<p>Dica: Usar o operador módulo (<code>%</code>)</p>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/areOdd.js": "const areOdd = (n, m) => {\n\n\n};\n\nmodule.exports = areOdd;\n",
                "/solution/areOdd.js": "const areOdd = (n, m) => {\n  if (n % 2 === 0 && m % 2 === 0) {\n    return true;\n  }\n\n  return false;\n};\n\nmodule.exports = areOdd;\n",
                "/test/areOdd.spec.js": "const Assert = require('chai').assert;\nconst areOdd = require('../solution/areOdd');\n\ndescribe('areOdd()', () => {\n  it('debería retornar true si ambos números son pares', () => {\n    Assert.deepEqual(areOdd(22, 10), true);\n    Assert.deepEqual(areOdd(12, 5), false);\n    Assert.deepEqual(areOdd(16, 8), true);\n    Assert.deepEqual(areOdd(33, 15), false);\n  });\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "08",
          "slug": "closing",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Cierre",
              "body": "<h2>Respondamos las preguntas del opening</h2>\n<ul>\n<li>¿Por qué quisiéramos modificar el control de flujo de un programa?</li>\n<li>¿Cuáles son las formas de modificar el flujo de un programa? Dibuja una\nrepresentación de cada una</li>\n<li>¿Qué significa <code>else</code> de una sentencia <code>if...else</code>? Dame un ejemplo</li>\n<li>¿Cuál es la diferencia entre un <code>while</code> y un <code>do</code>?</li>\n<li>¿Cuáles son las 3 partes (sentencias) esenciales de un <code>for</code>? Dame un ejemplo</li>\n<li>¿Para qué utilizamos <code>break</code> y <code>continue</code> en un <code>for</code>? Dame un ejemplo</li>\n<li>Explica, con una analogía y en tus propias palabras, qué es un <code>function</code> (una\nfunción). Dibuja el concepto de una función</li>\n<li>¿Por qué son importantes las funciones en la programación?</li>\n<li>¿Qué se entiende por <code>DRY</code>?</li>\n<li>¿Qué significa \"llamar\" a una función?</li>\n<li>¿Qué sería un \"input\" (entrada) para una función y qué sería el equivalente\ndel \"output\" (salida)?</li>\n<li>¿Cuál es la diferencia entre un parámetro y un argumento de una función?</li>\n<li>¿Qué significa el valor de <code>return</code> de una función?</li>\n<li>¿Qué sucede cuando una función tiene varios valores de <code>return</code>?</li>\n<li>¿Por qué podemos resolver problemas más complejos sabiendo\n<code>estructuras condicionales</code>,  <code>estructuras repetitivas</code> y <code>funciones</code>? Dame un\nejemplo</li>\n</ul>"
            },
            "pt": {
              "title": "Fechamento",
              "body": "<h2>Respondamos às perguntas do opening</h2>\n<ul>\n<li>Por que modificar o controle de fluxo de um programa?</li>\n<li>Quais são as formas de modificar o fluxo de um programa? Desenhe uma\nrepresentação de cada uma</li>\n<li>O que significa <code>else</code> de uma sentença <code>if...else</code>? De um exemplo</li>\n<li>Qual a diferença entre um <code>while</code> e um <code>do</code>?</li>\n<li>Quais são as 3 partes (sentenças) essenciais de um <code>for</code>? De um exemplo</li>\n<li>Para que utilizamos <code>break</code> e <code>continue</code> em um <code>for</code>? De um exemplo</li>\n<li>Explique, com uma analogia e com as suas próprias palavras, o que é uma\n<code>function</code> (uma função). Desenhe o conceito de uma função</li>\n<li>Por que são importantes as funções na programação?</li>\n<li>O que se entende por <code>DRY</code>?</li>\n<li>O que significa \"chamar\" a uma função?</li>\n<li>O que seria um \"input\" (entrada) para uma função e o que seria o equivalente\nao \"output\" (saída)?</li>\n<li>Qual a diferença entre um parâmetro e um argumento de una função?</li>\n<li>O que significa o valor de <code>return</code> de uma função?</li>\n<li>O que acontece quando uma função tem vários valores de <code>return</code>?</li>\n<li>Por que podemos resolver problemas mais complexos sabendo <code>estruturas condicionais</code>, <code>estruturas repetitivas</code> e <code>funções</code>? De um exemplo</li>\n</ul>"
            }
          }
        }
      ]
    },
    {
      "slug": "functions",
      "intl": {
        "es": {
          "title": "Funciones"
        },
        "pt": {
          "title": "Funções"
        }
      },
      "prefix": "03",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Apertura",
              "body": "<p>En esta unidad, veremos en profundidad el tema de funciones, aprovechando que\nJavaScript está fuertemente influenciado por la programación funcional desde su\ndiseño, y nos ofrece características importantes como asignar funciones a una\nvariable, pasar como parámetro de otra función, cambiar el scope de variables,\nasignar como valor de una propiedad de un objeto, etc.</p>\n<p>Las funciones son bloques de construcción de aplicaciones que engloban múltiples\nsentencias de código. Son particularmente importantes en JavaScript porque\nsoporta características como <em>first-class functions</em>, <em>functions as objects</em>,\n<em>runtime function definition</em> y más que veremos en esta unidad.</p>\n<p>A continuación, se listan algunos principios que te ayudarán a escribir mejores\nfunciones:</p>\n<ul>\n<li>\n<p><strong>Don't Repeat Yourself (DRY)</strong>: Es muy común que a lo largo del desarrollo de\nuna solución nos encontremos con un patrón que se va repitiendo a lo largo de\nnuestro código. Una vez identificado un patrón, es tiempo de escribir una\nfunción, objeto o módulo que encapsule dicho patrón para que sea fácilmente\nreusable. Esto ayuda también a que si encontramos algún bug o quisiéramos\nagregar funcionalidad, solo se tendría que hacer en un lugar. Además,\nescribiendo una función reusable te obliga a aislar el patrón del problema, lo\ncual ayuda a tener funcionalidad relacionada de manera agrupada.</p>\n</li>\n<li>\n<p><strong>Do One Thing (DOT)</strong>: Cada función debe hacer solo una cosa y hacerlo lo\nmejor posible. Siguiendo este principio hará tu función más reusable, legible y\nfácil de depurar.</p>\n</li>\n<li>\n<p><strong>Keep It Simple Stupid (KISS)</strong>: Si bien las funciones deben de hacer solo\nuna cosa, es mejor hacerlo súper claro manteniendo la sencillez y no agregando\ncomplejidad innecesaria para llevar a cabo una solución. Esto no quiere decir\nque la solución no sea óptima, sino que pueda ser legible para poder mantenerla\na lo largo del tiempo.</p>\n</li>\n<li>\n<p><strong>Less Is More</strong>: Para alcanzar la mayor legibilidad posible y reducir la\ntentación de hacer más de una cosa, las funciones deben ser tan cortas como sea\nposible. Si la función se vuelve muy extensa, es bueno considerar separarlo en\nsubtareas y datos a lo largo de funciones y objetos.</p>\n</li>\n</ul>"
            },
            "pt": {
              "title": "Opening",
              "body": "<p>Nesta unidade veremos com maior profundidade o tema de funções, aproveitando que\no Javascript é fortemente influenciado pela programação funcional desde seu\ndesenho inicial e que nos oferece características importante para atribuir\nfunções a uma variável, passar como parâmetro à outra função, mudar o escopo de\nvariáveis, atribuir como valor de um objeto, etc.</p>\n<p>As funções são blocos de construção de aplicações que englobam múltiplas\nsequências de código. São particularmente importantes no Javascript porque\nsuportam características como <em>first-class functions</em>, <em>functions as objects</em>,\n<em>runtime function definition</em> e mais que veremos nesta unidade.</p>\n<p>Listamos alguns princípios que te vão te ajudar a escrever funções melhores:</p>\n<ul>\n<li>\n<p><strong>Don't Repeat Yourself (DRY)</strong>: É muito comum que ao longo do desenvolvimento\nde uma solução encontremos um padrão que se repete ao longo de nosso código.\nUma vez identificado um padrão, é hora de escrever uma função, objeto ou\nmódulo que encapsule o padrão encontrado para que seja reutilizado facilmente.\nIsso ajuda também se encontrarmos algum <em>bug</em> ou quisermos adicionar alguma\nfuncionalidade, só precisaremos fazer em um lugar. Além disso, escrevendo uma\nfunção reutilizável obriga você a analisar o padrão do problema, o que ajudar\nter a funcionalidade relacionada de maneira agrupada.</p>\n</li>\n<li>\n<p><strong>Do One Thing (DOT)</strong>: Cada função deve fazer somente uma coisa e fazê-la o\nmelhor possível. Seguindo este princípio, você escreverá funções mais\nreutilizáveis, legíveis e fáceis de depurar.</p>\n</li>\n<li>\n<p><strong>Keep It Simple Stupid (KISS)</strong>: Se as funções devem fazer somente uma coisa,\né melhor fazê-la claramente mantendo a simplicidade e não adicionando\ncomplexidade desnecessária para resolver um problema. Isto não quer dizer que\na solução seja ótima, mas que pode ser legível para poder dar manutenção ao\nlongo do tempo.</p>\n</li>\n<li>\n<p><strong>Less Is More</strong>: Para alcançar a maior legibilidade possível e reduzir a\ntentação de fazer mais de uma coisa, as funções devem ser tão pequenas quanto\npossível. Se a função se torna muito longa, é melhor considerar separá-la em\nsubtarefas e dados ao longo de funções e objetos.</p>\n</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "classic",
          "type": "read",
          "duration": 20,
          "intl": {
            "es": {
              "title": "Funciones clásicas",
              "body": "<h2>Definiendo una función</h2>\n<p>La definición de una función es simplemente la definición de una variable\nregular donde el valor dado a dicha variable resulta ser una función. Por\nejemplo, el siguiente código define la variable <code>square</code> para referirse a la\nfunción que devuelve el cuadrado de un número dado:</p>\n<pre><code class=\"language-js\">const square = function (x) {\n  return x * x;\n};\n\nconsole.log(square(12)); // => 144\n</code></pre>\n<hr>\n<p>Funciones son valores que pueden ser llamados. Una manera de definir una función\nes llamada una <code>function declaration</code> o <code>declaración de función</code>. Por ejemplo,\nel siguiente código define una función <code>id</code> que tiene un simple parámetro <code>x</code>:</p>\n<pre><code class=\"language-js\">function id(x) {\n  return x;\n}\n</code></pre>\n<p>La sentencia <code>return</code> retorna un valor de la función <code>id</code>. Puedes llamar una\nfunción a través de su nombre, seguido de sus <code>argumentos</code> entre paréntesis:</p>\n<pre><code class=\"language-js\">id('hello'); // => 'hello'\n</code></pre>\n<p>Si no se retorna nada de la función <code>undefined</code> es retornado (implícitamente):</p>\n<pre><code class=\"language-js\">function f() {}\nf(); // => undefined\n</code></pre>\n<p>Esta sección mostró solo una manera de definir y llamar una función. Otras\nformas serán mostradas luego.</p>\n<h2>Los 3 roles de funciones en JavaScript</h2>\n<p>Una vez definida una función, esta puede desarrollar diversos roles:</p>\n<h3>Nonmethod function (función normal)</h3>\n<p>Puedes llamar a una función directamente como visto hace un momento. Acá un\nejemplo de invocación:</p>\n<pre><code class=\"language-js\">id('hello');\n</code></pre>\n<p>Por convención, los nombres de estas funciones <em>normales</em> empiezan con minúscula\nsiguiendo el estilo <strong>lowerCamelCase</strong>.</p>\n<h3>Constructor</h3>\n<p>Puedes invocar una función a través del operador <code>new</code>. Es usado para la\ncreación de objetos. Aquí un ejemplo de invocación:</p>\n<pre><code class=\"language-js\">new Date();\n</code></pre>\n<p>Por convención, los nombres de los constructores empiezan con mayúscula,\nsiguiendo el estilo <strong>UpperCamelCase</strong>.</p>\n<h3>Método</h3>\n<p>Puedes almacenar una función en una propiedad de un objeto, lo que lo convierte\nen un <em>método</em>. Aquí un ejemplo de como invocar un método definido en un objeto\n<code>obj</code>:</p>\n<pre><code class=\"language-js\">obj.method();\n</code></pre>\n<p>Por convención, los nombres de los métodos siguen el estilo de las funciones\nnormales (<em>lowerCamelCase</em>).</p>\n<h2>Terminología: \"Parámetro\" vs. \"Argumento\"</h2>\n<p>Los términos <code>parámetro</code> y <code>argumento</code> son a menudo usados para referirse a lo\nmismo ya que se logra enteder a lo que se refiere. Sin embargo, a continuación\nse muestra una regla para diferenciarlos:</p>\n<ul>\n<li>\n<p><strong>Parámetros</strong> son usados para definir una función. En el siguiente ejemplo,\n<code>param1</code> y <code>param2</code> son parámetros:</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n  // ...\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Argumentos</strong> son usados para invocar una función. En el siguiente ejemplo,\n<code>3</code> y <code>7</code> son argumentos:</p>\n<pre><code class=\"language-js\">foo(3, 7);\n</code></pre>\n</li>\n</ul>\n<h2>Definición de Funciones</h2>\n<p>En esta sección veremos 3 formas de crear una función:</p>\n<ul>\n<li>Mediante un <em>function expression</em> (función como expresión).</li>\n<li>Mediante un <em>function declaration</em> (declaración de una función).</li>\n<li>Mediante el constructor <code>Function()</code>.</li>\n</ul>\n<p>Todas las funciones son objetos, instancias de <code>Function</code>:</p>\n<pre><code class=\"language-js\">function id(x) {\n  return x;\n}\n\nconsole.log(id instanceof Function); // => true\n</code></pre>\n<p>Por lo tanto, las funciones obtienen sus métodos de <code>Function.prototype</code>.</p>\n<h3>Function Expressions</h3>\n<p>Un <em>function expression</em> produce un valor - un objeto de función. Por ejemplo:</p>\n<pre><code class=\"language-js\">const add = function (x, y) {\n  return x + y;\n};\n\nconsole.log(add(2, 3)); // => 5\n</code></pre>\n<p>El código anterior asigna el resultado de una función como expresión a la\nvariable <code>add</code> y puede ser llamado a través de esta variable. En este tipo de\nfunción se puede asignar una función a una variable, pasar como parámetro de\notra función y más. Debido a que este tipo de funciones no tienen un nombre,\npueden ser llamadas <em>anonymous function expressions</em> (funciones anónimas).</p>\n<h4>Named Function Expressions</h4>\n<p>Se puede poner nombre a una función como expresión. Los <em>named function\nexpressions</em> (funciones como expresión con nombre) permiten a la función poder\nreferirse a si misma, su utilidad se ve reflejada cuando se desea aplicar\nrecursividad por ejemplo:</p>\n<pre><code class=\"language-js\">const factorial = function fact(number) {\n  if (number &#x3C;= 1) {\n    return 1;\n  }\n  return number * fact(number - 1);\n};\n\nconsole.log(factorial(3)); // => 6\n</code></pre>\n<p><strong>Nota:</strong> Los nombres de las funciones como expresión con nombre solo son\naccesibles dentro de la función:</p>\n<pre><code class=\"language-js\">const repeat = function me(n, str) {\n  return n > 0 ? str + me(n - 1, str) : '';\n};\n\nconsole.log(repeat(3, 'Yeah')); // => YeahYeahYeah\nconsole.log(me); // => ReferenceError: me is not defined\n</code></pre>\n<h3>Function Declarations</h3>\n<p>La siguiente es una declaración de función:</p>\n<pre><code class=\"language-js\">function add(x, y) {\n  return x + y;\n}\n</code></pre>\n<p>El código anterior se parece al de una función como expresión, pero es una\nsentencia. De cierta forma, es equivalente al siguiente código:</p>\n<pre><code class=\"language-js\">const add = function (x, y) {\n  return x + y;\n};\n</code></pre>\n<p>En otras palabras, un <em>function declaration</em> consiste de la palabra clave\nreservada <em>function</em>, una lista de parámetros para la función, encerrados en\nparéntesis y separados por comas, y la sentencia JavaScript que define la\nfunción, encerrada por llaves.</p>\n<h3>Function Constructor</h3>\n<p>El constructor <code>Function()</code> evalua código JavaScript almacenado en strings. Por\nejemplo, el siguiente código es equivalente a los ejemplos anteriores:</p>\n<pre><code class=\"language-js\">const add = new Function('x', 'y', 'return x + y');\n</code></pre>\n<p>Sin embargo, esta forma de definir una función es lenta y deja código en strings\n(inaccesible a herramientas, por ejemplo, al depurar con <em>Dev Tools</em>). Por lo\ntanto es mejor usar un <em>function expression</em> o un <em>function declaration</em> si es\nposible.</p>\n<h2>Hoisting</h2>\n<p><strong>Hoisting</strong> significa \"mover al inicio del ámbito\". <em>Function declarations</em> son\nelevadas (<em>hoisted</em>) completamente, mientras las declaraciones de variables solo\nparcialmente.</p>\n<p><em>Function declarations</em> son completamente elevadas, esto permite llamar a una\nfunción antes de que se hayan declarado:</p>\n<pre><code class=\"language-js\">welcome(); // => 'Welcome to Laboratoria'\nfunction welcome() { // esta función es elevada - hoisting\n  console.log('Welcome to Laboratoria');\n}\n</code></pre>\n<p>La razón por la cual el código anterior funciona es que el motor de JavaScript\nmueve la declaración de la función <code>welcome</code> al inicio del scope. Termina\nejecutándose como si estuviera escrito de la siguiente manera:</p>\n<pre><code class=\"language-js\">function welcome() { // esta función es elevada - hoisting\n  console.log('Welcome to Laboratoria');\n}\nwelcome(); // => 'Welcome to Laboratoria'\n</code></pre>\n<p>Las declaraciones de variables son elevadas también, pero solo las declaraciones\nmás no las asignaciones. Por lo tanto, definir una función como expresión\nasignándola a una variable termina en un error en el ejemplo anterior:</p>\n<pre><code class=\"language-js\">welcome(); // TypeError: undefined is not a function\nconst welcome = function welcome() {\n  console.log('Welcome to Laboratoria');\n};\n</code></pre>\n<p>Solo las declaraciones son elevadas. El motor de JavaScript ejecuta el código\nanterior como si estuviese escrito de la siguiente manera:</p>\n<pre><code class=\"language-js\">let welcome; // undefined\nwelcome(); // TypeError: undefined is not a function\nwelcome = function welcome() {\n  console.log('Welcome to Laboratoria');\n};\n</code></pre>"
            },
            "pt": {
              "title": "Funções clásicas",
              "body": "<h2>Declarando uma função</h2>\n<p>A declaração de uma função é simplesmente a declaração de uma variável comum na\nqual o valor dado a tal variável resulta ser uma função. Por exemplo, o código a\nseguir define a variável <code>square</code> para fazer referência à função que retorna o\nquadrado de um dado número:</p>\n<pre><code class=\"language-js\">  const square = function(x) {\n    return x * x;\n  };\n\n  console.log(square(12)); // 144\n</code></pre>\n<hr>\n<p>Funções são valores que podem ser chamados (invocados). Uma maneira de definir\numa função é chamada uma <code>function declaration</code> ou <code>declaração de função</code>. Por\nexemplo, o código a seguir define uma função <code>id</code> que possui um parâmetro\nsimples <code>x</code>:</p>\n<pre><code class=\"language-js\">function id(x) {\n  return x;\n}\n</code></pre>\n<p>A instrução <code>return</code> retorna um valor da função <code>id</code>. Você pode chamar uma\nfunção por meio de seu nome, seguida de seus <code>argumentos</code> entre parênteses:</p>\n<pre><code class=\"language-js\">id('hello'); // 'hello'\n</code></pre>\n<p>Se nada é retornado pela função, <code>undefined</code> é retornado (implicitamente):</p>\n<pre><code class=\"language-js\">function f() { }\nf(); //undefined\n</code></pre>\n<p>Esta seção mostrou somente uma maneira de definir e chamar uma função. Outras\nformas serão mostradas em breve.</p>\n<h2>Os 3 papéis das funções em JavaScript</h2>\n<p>Uma vez definida uma função, ela pode realizar vários papéis:</p>\n<h3>Nonmethod function (função normal)</h3>\n<p>Você pode chamar uma função diretamente como vimos até o momento. Aqui um\nexemplo de chamada:</p>\n<pre><code class=\"language-js\">id('hello');\n</code></pre>\n<p>Por convenção, os nomes destas funções <em>normais</em> começam com letra minúscula\nseguindo o estilo <strong>lowerCamelCase</strong>.</p>\n<h3>Construtor</h3>\n<p>Você pode invocar uma função por meio do operador <code>new</code>. Ele é utilizado para\ncriação de objetos. Aqui um exemplo de invocação:</p>\n<pre><code class=\"language-js\">new Date();\n</code></pre>\n<p>Por convenção, os nomes dos construtores começam com letra maiúscula, seguindo o\nestilo <strong>UpperCamelCase</strong>.</p>\n<h3>Método</h3>\n<p>Você pode armazenar uma função em uma propriedade de um objeto, o que o converte\nem um <em>método</em>. Aqui um exemplo de como invocar um método definido em um objeto\n<code>obj</code>:</p>\n<pre><code class=\"language-js\">obj.method();\n</code></pre>\n<p>Por convenção, os nomes dos métodos seguem o estilo das funções normais\n(<em>lowerCamelCase</em>).</p>\n<h2>Terminologia: \"Parâmetro\" vs. \"Argumento\"</h2>\n<p>Os termos <code>parâmetro</code> e <code>argumento</code> são frequentemente usados para se referirem\nà mesma coisa já que é possível entender ao que se referem. Contudo, a seguir\nmostramos uma regra para diferenciá-los.</p>\n<ul>\n<li>\n<p><strong>Parâmetros</strong> são utilizados para definir uma função: No exemplo a seguir,\n<code>param1</code> e <code>param2</code> são parâmetros:</p>\n<pre><code class=\"language-js\">function foo(param1, param2) {\n  // ...\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Argumentos</strong> são utilizados para invocar uma função. No exemplo a seguir,\n<code>3</code> e <code>7</code> são argumentos:</p>\n<pre><code class=\"language-js\">foo(3, 7);\n</code></pre>\n</li>\n</ul>\n<h2>Criação de Funções</h2>\n<p>Nesta seção veremos 3 maneiras de criar uma função:</p>\n<ul>\n<li>Por meio de uma <em>function expression</em> (função como expressão).</li>\n<li>Por meio de uma <em>function declaration</em> (declaração de uma função).</li>\n<li>Por meio do construtor <code>Function()</code>.</li>\n</ul>\n<p>Todas as funções são objetos, instâncias de <code>Function</code>:</p>\n<pre><code class=\"language-js\">function id(x) {\n  return x;\n}\n\nconsole.log(id instanceof Function); // true\n</code></pre>\n<p>Para tal, as funções obtêm seus métodos de <code>Function.prototype</code>.</p>\n<h3>Function Expressions</h3>\n<p>Uma <em>function expression</em> produz um valor - um objeto de função. Por exemplo:</p>\n<pre><code class=\"language-js\">const add = function(x, y) {\n  return x + y;\n};\n\nconsole.log(add(2, 3)); // 5\n</code></pre>\n<p>O código anterior atribui o resultado de uma função como expressão para a\nvariável <code>add</code> e pode ser chamada por meio desta variável. Neste tipo de função\né possível atribuir uma função a uma variável, passar como parâmetros de outra\nfunção e outras coisas mais. Devido a este tipo de função não possuir um nome,\npodem ser chamadas de <em>anonymous function expressions</em> (funções anônimas).</p>\n<h4>Named Function Expressions</h4>\n<p>É possível nomear uma função como uma expressão. As <em>named function expressions</em>\n(funções que se expressam por nome) permitem à função fazer referências a si\nmesma. Vemos refletida sua utilidade quando desejamos aplicar recursividade. Por\nexemplo:</p>\n<pre><code class=\"language-js\">const factorial = function fact(number) {\n  if (number &#x3C;= 1) {\n    return 1;\n  }\n  return number * fact(number - 1);\n};\n\nconsole.log(factorial(3)); // 6\n</code></pre>\n<p><strong>Nota:</strong> Os nomes das funções como expressão com nome só são acessíveis dentro\nda função:</p>\n<pre><code class=\"language-js\">const repeat = function me(n, str) {\n  return n > 0 ? str + me(n-1, str) : '';\n};\n\nconsole.log(repeat(3, 'Yeah')); // YeahYeahYeah\nconsole.log(me); // ReferenceError: me is not defined\n</code></pre>\n<h3>Function Declarations</h3>\n<p>A seguir temos uma declaração de função:</p>\n<pre><code class=\"language-js\">function add(x, y) {\n  return x + y;\n}\n</code></pre>\n<p>O código anterior é parecido com o de uma função como expressão, mas é uma\ninstrução. De certa maneira, é equivalente ao código a seguir:</p>\n<pre><code class=\"language-js\">const add = function(x, y) {\n  return x + y;\n};\n</code></pre>\n<p>Em outras palavras, uma <em>function declaration</em> consiste na palavra chave\nreservada <em>function</em>, uma lista de parâmetros para a função, delimitados por\nparênteses e vírgulas, e a sentença JavaScript que define a função, delimitada\npor chaves.</p>\n<h3>Function Constructor</h3>\n<p>O construtor <code>Function()</code> avalia código JavaScript armazenado em strings. Por\nexemplo, o código a seguir é equivalente aos dos exemplos anteriores:</p>\n<pre><code class=\"language-js\">const add = new Function('x', 'y', 'return x + y');\n</code></pre>\n<p>No entanto, esta maneira de definir uma função é lenta e deixa o código entre\nstrings (ficam inacessíveis a ferramentas, por exemplo, de depuração com <em>Dev\nTools</em>). Portanto é melhor utilizar <em>function expression</em> ou uma <em>function\ndeclaration</em> se for possível.</p>\n<h2>Hoisting</h2>\n<p><strong>Hoisting</strong> significa \"elevar para o início do escopo\". <em>Function declarations</em>\nsão elevadas (<em>hoisted</em>) completamente, enquanto as declarações de variáveis só\nparcialmente.</p>\n<p><em>Function declarations</em> são completamente elevadas. Isso permite chamar uma\nfunção antes de sua declaração:</p>\n<pre><code class=\"language-js\">welcome(); // 'Welcome to Laboratoria'\nfunction welcome() { // esta função é elevada - hoisting\n  console.log('Welcome to Laboratoria');\n}\n</code></pre>\n<p>A razão pela qual o código anterior funciona é que o motor de JavaScript move a\ndeclaração da função <code>welcome</code> para o início do escopo. Ele acaba executando\ncomo se estivesse escrito da seguinte maneira:</p>\n<pre><code class=\"language-js\">function welcome() { // esta função é elevada - hoisting\n  console.log('Welcome to Laboratoria');\n}\nwelcome(); // 'Welcome to Laboratoria'\n</code></pre>\n<p>As declarações de variáveis são elevadas também, mas somente as declarações mas\nnão as atribuições. Portanto, definir uma função como expressão atribuindo a uma\nvariável acaba em um erro no exemplo anterior:</p>\n<pre><code class=\"language-js\">welcome(); // TypeError: undefined is not a function\nconst welcome = function welcome() {\n  console.log('Welcome to Laboratoria');\n};\n</code></pre>\n<p>Somente as declarações são elevadas. O motor de JavaScript executa o código\nanterior como se estivesse escrito da seguinte maneira:</p>\n<pre><code class=\"language-js\">const welcome; // undefined\nwelcome(); // TypeError: undefined is not a function\nwelcome = function welcome() {\n  console.log('Welcome to Laboratoria');\n};\n</code></pre>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "arrow",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Arrow Functions",
              "body": "<h2>Diferencias entre arrow functions y funciones clásicas</h2>\n<p>Una de las novedades más interesantes de ES6 son las denominadas <strong>funciones\nflecha</strong>, o <em>arrow functions</em>. Las funciones flecha son, como su\nnombre indica, definidas mediante una nueva sintaxis que utiliza una \"flecha\"\n(<code>=></code>). Las funciones flecha se comportan de forma sensiblemente distinta a las\nfunciones tradicionales de JavaScript, a continuación alguna de sus diferencias:</p>\n<ul>\n<li><strong>No pueden llamarse con <code>new</code></strong>: Al no tener un método constructor, no pueden\nser utilizadas como constructores. Las funciones flecha lanzarán un error\ncuando se utilicen con <code>new</code>.</li>\n<li><strong>No hay prototipo</strong>: Al no disponer de constructor, tampoco es necesario un\nprototipo. Por lo tanto, no existirá la propiedad <code>prototype</code> en una función\nflecha.</li>\n<li><strong>No crean un nuevo contexto</strong>. El valor de <code>this</code>, <code>super</code>, <code>arguments</code> y\n<code>new.target</code> dentro de la función será el mismo que el de la función\ntradicional (<em>non-arrow</em>) más cercana.</li>\n<li><strong>No puedes cambiar <code>this</code></strong>: El valor de <code>this</code> dentro de la función flecha\npermanece inmutable a lo largo de todo el ciclo de vida de la función.</li>\n<li><strong>No hay objeto <code>arguments</code></strong>: Tan solo es posible proporcionarle parámetros a\nuna función flecha mediante parámetros nombrados y <em>rest parameters</em>.</li>\n<li><strong>No es posible duplicar parámetros con el mismo nombre</strong>: Tanto en modo\nestricto como no estricto, a diferencia de las funciones clásicas, que no lo\npermiten tan solo en modo estricto.</li>\n</ul>\n<h2>Sintáxis</h2>\n<p>El ejemplo más simple de <em>arrow function</em> es el siguiente, aunque veremos en los\nejemplos siguientes que existen diversas variaciones.</p>\n<pre><code class=\"language-js\">const echo = text => text;\n</code></pre>\n<p>Esta función sería equivalente a la siguiente:</p>\n<pre><code class=\"language-js\">const echo = function (text) {\n  return text;\n};\n</code></pre>\n<p>En ambos casos, la ejecución de la función daría la siguiente salida:</p>\n<pre><code class=\"language-js\">console.log(echo('Hola Mundo!')); // => Hola Mundo!\n</code></pre>\n<p>Como con cualquier función, podemos pasar tantos argumentos como queramos a la\nfunción:</p>\n<pre><code class=\"language-js\">const sum = (a, b) => a + b;\nconsole.log(sum(1, 1)); // => 2\n</code></pre>\n<p>O ninguno, claro:</p>\n<pre><code class=\"language-js\">const greet = () => 'Hola, forastero!';\nconsole.log(greet()); // => Hola, forastero!\n</code></pre>\n<p>Si queremos realizar operaciones más complicadas, podemos hacerlo con llaves y\ndefiniendo un valor de retorno:</p>\n<pre><code class=\"language-js\">const resize = ({x, y}, ratio) => {\n  return {\n    x: x * ratio,\n    y: y * ratio\n  };\n};\n\nconsole.log(resize({ x: 5, y: 15 }, 100)); // => { x: 500, y: 1500 }\n</code></pre>\n<p>Una función flecha no crea un nuevo contexto. Una de las mayores fuentes de\nerrores en JavaScript venía dada por la creación de distintos contextos en una\nfunción dependiendo de quien las esté ejecutando. Tomemos el siguiente ejemplo:</p>\n<pre><code class=\"language-js\">const randomWinner = function (drivers) {\n  const winner = Math.floor(Math.random() * (0 - drivers.length) + drivers.length);\n  return drivers[winner];\n};\n\nconst F1Race = {\n  drivers: [\n    'Alonso',\n    'Vettel',\n    'Button',\n    'Massa'\n  ],\n  init: function () {\n    console.log('Los siguientes pilotos van a comenzar la carrera:', this.drivers);\n    setTimeout((function () {\n      console.log('El ganador es', randomWinner(this.drivers));\n    }), 1000);\n  }\n};\n\nF1Race.init();\n</code></pre>\n<p><code>F1Race</code> es un objeto que lanza una carrera de Fórmula 1 mediante su función\n<code>init()</code>. Al cabo de un segundo, se ejecutará la función <code>randomWinner()</code>, que a\npartir de un array de conductores, seleccionará uno al azar.</p>\n<p>Cuando ejecutamos la función <code>init()</code>, el programa escribe por consola lo\nsiguiente:</p>\n<pre><code class=\"language-text\">Los siguientes pilotos van a comenzar la carrera: [ 'Alonso', 'Vettel', 'Button', 'Massa']\n</code></pre>\n<p>Esto es posible ya que la función <code>init</code> tiene como contexto el propio objeto\n<code>F1Race</code>. Sin embargo, la función da error tras un segundo, mientras intenta\ncalcular el ganador de forma aleatoria. ¿Cómo es posible?</p>\n<p>El motivo es que la función de callback que se le pasa a <code>setTimeout</code> crea un\nnuevo contexto, en el que no existe el array drivers.</p>\n<p>En ES5 podíamos solucionar este problema utilizando <code>bind(this)</code> para asignar\nel contexto de la función de callback al del objeto que la contiene, de la\nsiguiente forma:</p>\n<pre><code class=\"language-js\">init: function () {\n  console.log('Los siguientes pilotos van a comenzar la carrera:', this.drivers);\n  setTimeout((function () {\n    console.log('El ganador es', randomWinner(this.drivers));\n  }).bind(this), 1000);\n}\n</code></pre>\n<p>Con ES2015, podemos solucionar este contratiempo utilizando arrow functions de\nuna forma mucho más elegante, ya que al no crear un nuevo contexto, <code>this</code>\nsiempre vendrá determinado por la función que lo contiene:</p>\n<pre><code class=\"language-js\">init: function () {\n  console.log('Los siguientes pilotos van a comenzar la carrera:', this.drivers);\n  setTimeout(() => console.log('El ganador es', randomWinner(this.drivers)), 1000);\n}\n</code></pre>"
            },
            "pt": {
              "title": "Arrow Functions",
              "body": "<h2>Diferenças entre <em>arrow functions</em> e funções clássicas</h2>\n<p>Uma das novidades mais interessantes de ES6 são as denominadas <strong>funções seta</strong>,\nou <em>arrow functions</em>. As funções setas são, como seu nome indica, definidas por\nmeio de uma nova sintaxe que utiliza uma \"seta\" (<code>=></code>). As funções seta se\ncomportam de maneira sensivelmente diferente das funções tradicionais de\nJavaScript. A seguir, algumas de suas diferenças:</p>\n<ul>\n<li><strong>Não podem ser chamadas com <code>new</code></strong>: Como não possuem um método construtor,\nnão podem ser executadas como construtores. As funções seta dispararão um erro\nse forem utilizadas com <code>new</code>.</li>\n<li><strong>Não há protótipo</strong>: Como não possuem construtor, tampouco é necessário um\nprotótipo. Logo, não existirá a propriedade <code>prototype</code> e uma função seta.</li>\n<li><strong>Não criam um novo contexto</strong>. O valor de <code>this</code>, <code>super</code>, <code>arguments</code> e\n<code>new.target</code> dentro da função será o mesmo que na função tradicional\n(<em>non-arrow</em>) mais próxima.</li>\n<li><strong>Não pode trocar <code>this</code></strong>: O valor de <code>this</code> dentro da função seta permanece\nimutável ao longo de todo o ciclo de vida da função.</li>\n<li><strong>Não existe objeto <code>arguments</code></strong>: Somente é possível atribuir parâmetros a\numa função seta mediante parâmetros nomeados e <em>rest parameters</em>.</li>\n<li><strong>Não é possível duplicar parâmetros com o mesmo nome</strong>: Tanto no modo estrito\ncomo no não estrito, diferente das funções clássicas, que não permitem somente\no modo estrito.</li>\n</ul>\n<h3>Sintaxe</h3>\n<p>O exemplo mais simples de uma *<em>arrow functions</em> é o a seguir, embora vejamos\nnos exemplos seguintes que podem existir diversas variações.</p>\n<pre><code class=\"language-js\">const echo = text => text;\n</code></pre>\n<p>Esta função seria equivalente a seguinte:</p>\n<pre><code class=\"language-js\">const echo = function(text) {\n  return text;\n};\n</code></pre>\n<p>Nos dois casos, a execução da função daria a seguinte saída:</p>\n<pre><code class=\"language-js\">console.log(echo('Olá Mundo!')); // Olá Mundo!\n</code></pre>\n<p>Como com qualquer função, podemos passar tantos argumentos quanto quisermos para\na função:</p>\n<pre><code class=\"language-js\">const sum = (a, b) => a + b;\nconsole.log(sum(1, 1)); // 2\n</code></pre>\n<p>Ou nenhum, claro:</p>\n<pre><code class=\"language-js\">const greet = () => 'Olá, estrangeiro!';\nconsole.log(greet()); // Olá, estrangeiro!\n</code></pre>\n<p>Se quisermos realizar operações mais complicadas, podemos usar chaves e definir\num valor de retorno:</p>\n<pre><code class=\"language-js\">const resize = ({x, y}, ratio) => {\n  return {\n    x: x * ratio,\n    y: y * ratio\n  };\n};\n\nconsole.log(resize({x: 5, y: 15}, 100)); // { x: 500, y: 1500 }\n</code></pre>\n<p>Uma função seta não cria um novo contexto. Uma de suas maiores fontes de erros\nem JavaScript acontecia pela criação de diferentes contextos em uma função\ndependendo de quem a executa. Vejamos o exemplo a seguir:</p>\n<pre><code class=\"language-js\">const randomWinner = function(drivers) {\n  const winner = Math.floor(Math.random() * (0 - drivers.length) + drivers.length);\n  return drivers[winner];\n};\n\nconst F1Race = {\n  drivers: [\n    'Alonso',\n    'Vettel',\n    'Button',\n    'Massa'\n  ],\n  init: function() {\n    console.log('Os seguintes pilotos começarão a corrida:', this.drivers);\n    setTimeout((function() {\n      console.log('O ganhador é ', randomWinner(this.drivers));\n    }), 1000);\n  }\n};\n\nF1Race.init();\n</code></pre>\n<p><code>F1Race</code> é um objeto que inicia uma corrida de Fórmula 1 por meio de sua função\n<code>init()</code>. Após um segundo, será executada a função <code>randowWinner()</code>, que a\npartir de um array de pilotos, escolherá um aleatoriamente.</p>\n<p>Quando executamos a função <code>init()</code>, o programa escreve no console o seguinte:</p>\n<pre><code class=\"language-text\">Os seguintes pilotos começarão a corrida: [ 'Alonso', 'Vettel', 'Button', 'Massa']\n</code></pre>\n<p>Isso é possível já que a função <code>init</code> tem como contexto o próprio objeto\n<code>F1Race</code>. Contudo, a função dá erro após um segundo, enquanto tenta calcular o\nganhador de maneira aleatória. Como isso é possível?</p>\n<p>O motivo é que a função de <em>callback</em> que é passada ao <code>setTimetout</code> cria um\nnovo contexto, no qual não existe o array de pilotos.</p>\n<p>No ES5 podíamos solucionar esse problema utilizando <code>bind(this)</code> para atribuir o\ncontexto de uma função de <em>callback</em> ao objeto que a contém da seguinte maneira:</p>\n<pre><code class=\"language-js\">init: function() {\n  console.log('Os seguintes pilotos começarão a corrida:', this.drivers);\n  setTimeout((function() {\n    console.log('O ganhador é ', randomWinner(this.drivers));\n  }).bind(this), 1000);\n}\n</code></pre>\n<p>Com ES2015, podemos solucionar este contratempo utilizando funções seta de uma\nmaneira muito mais elegante, já que ao criar o novo contexto, <code>this</code> sempre virá\ndeterminado pela função o contém:</p>\n<pre><code class=\"language-js\">init: function() {\n  console.log('Os seguintes pilotos começarão a corrida:', this.drivers);\n  setTimeout(() => console.log('O ganhador é ', randomWinner(this.drivers)), 1000);\n}\n</code></pre>"
            }
          }
        }
      ]
    },
    {
      "slug": "arrays",
      "intl": {
        "es": {
          "title": "Arrays (arreglos)"
        },
        "pt": {
          "title": "Arrays"
        }
      },
      "prefix": "04",
      "parts": [
        {
          "prefix": "01",
          "slug": "arrays",
          "type": "read",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Arreglos",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Aprender qué son <code>arrays</code> y para qué sirven</li>\n<li>Aprender a crear, acceder y modificar la información de un <code>array</code></li>\n</ul>\n<hr>\n<p>El texto a continuación se basa en gran medida, con ciertos ajustes, en el\ncapítulo 4 de <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>, de Marijn\nHaverbeke, 2014. Traducción en <a href=\"http://hectorip.github.io/Eloquent-JavaScript-ES-online/chapters/01_values.html\">Español</a>\ndisponible gracias a <a href=\"https://github.com/hectorip\">hectorip</a>, y del capítulo 3\nde <a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for kids</a>,\nNick Morgan, 2015.</p>\n<hr>\n<h2>Agrupando y manipulando data</h2>\n<p>Como hemos visto, gran parte de la programación consiste en agrupar y manipular\ndata. Esto nos permite transformar datos en información y utilizar esa información\npara resolver problemas. Hasta ahora hemos podido agrupar y manipular data haciendo\nuso de tipos de datos simples como: <code>numbers</code>,<code>booleans</code> y <code>strings</code>. Sobre ellos\nhemos creado una serie de programas sencillos. También hemos aprendido a modificar\nel control de flujo de estos programas, por medio de <code>estructuras repetitivas</code>,\n<code>estructuras condicionales</code> y <code>funciones</code>, lo cual nos ha permitido crear productos\nun poco más complejos. Sin embargo, nuestros programas han estado seriamente limitados\ndebido a que operan únicamente con <strong>tipos de datos simples</strong>. Para resolver problemas\nmás complejos necesitamos poder agrupar y manipular data de una manera más interesante.\nAfortunadamente, un entorno JavaScript nos permite lograr esto brindándonos <code>arrays</code>\ny <code>objects</code>.</p>\n<h2>¿Por qué necesitamos arrays?</h2>\n<p>Digamos, por poner un ejemplo, que queremos representar una colección de\nnúmeros: <code>2, 3, 5, 7 y 11</code>.</p>\n<p>Una opción para representar esto sería:</p>\n<pre><code class=\"language-js\">const firstNumber = 2;\nconst secondNumber = 3;\nconst thirdNumber = 5;\nconst fourthNumber = 7;\n\n</code></pre>\n<p>Esta lista es bien extraña y engorrosa. Implica tener una variable para cada\nelemento de nuestra lista. Cuando en realidad sólo deberíamos tener una sola\nvariable que \"contenga\" a cada una.¡Imagina que luego quieres tener una lista\nde 1,000 elementos!</p>\n<p>Otra opción -más creativa- sería utilizar un <code>string</code>. Después de todo, los\nstrings pueden ser de cualquier longitud, así que podemos poner mucha información\nen ellos. Podríamos usar un <code>string</code> con los números intercalados por un\nespacio, así:</p>\n<pre><code class=\"language-js\">const listOfNumbers = '2 3 5 7 11';\n</code></pre>\n<p>Sin embargo, esto también resulta engorroso. Tendríamos que buscar la manera de\nextraer cada elemento del <code>string</code> (contando los espacios entre ellos) y además,\ntendríamos que convertirlos de vuelta a <code>number</code> para acceder y manipular cada\nnúmero de manera individual.</p>\n<p>Afortunadamente, Javascript proporciona un tipo de dato específico para almacenar\nsecuencias de valores. Se llama <code>array</code> (arreglo en español) y se escribe como una\nlista de valores entre corchetes, separados por comas.</p>\n<pre><code class=\"language-js\">const listOfNumbers = [2, 3, 5, 7, 11];\n\n</code></pre>\n<p>Los <code>arrays</code> son tremendamente útiles para agrupar y manipular data. Es como\ncuando vamos al mercado y tenemos nuestra \"lista de compras\". Podríamos tener\nuna hoja de papel para cada artículo que queremos comprar. Por ejemplo, podríamos\ntener una hoja de papel que dice \"huevos\", otra hoja que dice \"pan\", y otra hoja\nque dice \"naranjas\". Sin embargo, la mayoría de la gente escribe la lista completa\nde cosas a comprar en <strong>una sola hoja de papel</strong>.</p>\n<h2>Accediendo información de un array</h2>\n<p>Antes de comenzar, vamos a generar una pequeña función utilitaria,\nque nos permita decir si dos string son iguales. La colocaremos\nen el <code>prototype</code> de <code>Array</code>.</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\nconsole.assert(equal([1, 2, 3], [1, 2, 3]));\nconsole.assert(!equal([1, 2, 3], ['a', 'b', 'c']));\nconsole.assert(!equal([1, 2, 3], [3, 2, 1]));\n\n</code></pre>\n<p>Para obtener un elemento dentro de un <code>array</code>, se utiliza la notación con corchetes,\ncon el <em>index</em> (índice en español) del elemento que se desea. Veamos un ejemplo:</p>\n<pre><code class=\"language-js\">listOfNumbers = [2, 3, 5, 7, 11];\n\nconsole.assert(listOfNumbers[1] === 3);\nconsole.assert(listOfNumbers[1 - 1] === 2);\n\n</code></pre>\n<p>El <em>index</em> es el número que corresponde a (o que coincide con) el punto del <code>array</code>\ndonde se almacena el valor. Al igual que con los <code>strings</code>, el primer elemento\nde un <code>array</code> está en el <code>index 0</code>, el segundo está en el <code>index 1</code>, el tercero\nen el <code>index 2</code>, y así sucesivamente. Es por eso que pedir index <code>1 - 1</code>\n(es decir, 0) del array anterior devuelve el número <code>2</code>.</p>\n<p><img src=\"https://user-images.githubusercontent.com/211721/40194836-51eebf22-59d1-11e8-8de8-8b29feb3bbf7.png\" alt=\"image\"></p>\n<p>Si no tienes antecedentes en programación, acostumbrarte a esta convención puede\ntomarte algún tiempo. Pero el conteo con base cero tiene una larga tradición en\ntecnología y mientras la convención se siga de manera consistente (que se ha hecho\nen Javascript), funciona bien.</p>\n<h2>Definiendo o cambiando los elementos de un array</h2>\n<p>Podemos utilizar los <em>indexes</em> entre corchetes para establecer, cambiar o incluso\nagregar elementos a un <code>array</code>. Por ejemplo, para reemplazar el primer elemento del\narray <code>listOfNumbers</code> por el número 1, podríamos hacer lo siguiente:</p>\n<pre><code class=\"language-js\">listOfNumbers = [2, 3, 5, 7, 11];\nlistOfNumbers[0] = 1;\n\nconsole.assert(\n  equal(listOfNumbers, [1, 3, 5, 7, 11]),\n);\n\n</code></pre>\n<p>También podemos utilizar los <em>indexes</em> entre corchetes para agregar elementos en\nun <code>array</code>. Por ejemplo, para agregar el número 13 al array <code>listOfNumbers</code>,\nharíamos lo siguiente:</p>\n<pre><code class=\"language-js\">listOfNumbers = [2, 3, 5, 7, 11];\nlistOfNumbers[5] = 13;\n\nconsole.assert(\n  equal(listOfNumbers, [2, 3, 5, 7, 11, 13]),\n);\n\n</code></pre>\n<p>De hecho, podemos crear un <code>array</code> vacío y luego definir cada elemento de forma\nindividual, así:</p>\n<pre><code class=\"language-js\">listOfNumbers = [];\nlistOfNumbers[0] = 2;\nlistOfNumbers[1] = 3;\nlistOfNumbers[2] = 5;\nlistOfNumbers[3] = 7;\nlistOfNumbers[4] = 11;\n\nconsole.assert(\n  equal(listOfNumbers, [2, 3, 5, 7, 11]),\n);\n\n</code></pre>\n<h2>Mezclando tipos de datos en arrays</h2>\n<p>Los elementos de un <code>array</code> no tienen que ser todos del mismo tipo de dato.\nPodemos, por ejemplo, tener un <code>array</code> que contenga un <code>number</code> (el número 3),\nun <code>string</code> (\"hola mundo\") y otro <code>number</code> (el número 3627.5):</p>\n<pre><code class=\"language-js\">const mixedArray = [3, 'hola mundo', 3627.5];\nconsole.assert(mixedArray[0] === 3);\nconsole.assert(mixedArray[1] === 'hola mundo');\nconsole.assert(mixedArray[2] === 3627.5);\n\n</code></pre>\n<p>Inclusive podemos tener un <code>array</code> dentro de otro <code>array</code> (algo que mucha gente\nllama arrays de 2 dimensiones). Por ejemplo, para organizar la data de preguntas\ny respuestas de un quiz, podemos utilizar un <code>array</code> en el que cada elemento es,\na su vez, un <code>array</code> que tiene dos elementos: una pregunta y una respuesta.</p>\n<pre><code class=\"language-js\">let questions = [\n  ['¿En cuántos países opera Laboratoria?', 4],\n  ['¿Cuál es la capital de Perú?', 'Lima'],\n  ['¿Cuál es baile típico Chileno?', 'Cueca'],\n  ['¿Cuál es la moneda de México?', 'Peso'],\n];\n\n</code></pre>\n<p>Para acceder a elementos individuales de los arrays internos simplemente se añade\nun nuevo par de corchetes con el index correspondiente. Por ejemplo, para obtener\nla respuesta a la pregunta '¿Cuál es la moneda de México?' haríamos:</p>\n<pre><code class=\"language-js\">questions = [\n  ['¿En cuántos países opera Laboratoria?', 4],\n  ['¿Cuál es la capital de Perú?', 'Lima'],\n  ['¿Cuál es baile típico Chileno?', 'Cueca'],\n  ['¿Cuál es la moneda de México?', 'Peso'],\n];\nconsole.assert(questions[3][1] === 'Peso');\n\n</code></pre>\n<p>Vamos a hacerlo de nuevo paso a paso</p>\n<pre><code class=\"language-js\">questions = [\n  ['¿En cuántos países opera Laboratoria?', 4],\n  ['¿Cuál es la capital de Perú?', 'Lima'],\n  ['¿Cuál es baile típico Chileno?', 'Cueca'],\n  ['¿Cuál es la moneda de México?', 'Peso'],\n];\nconst quest3 = questions[3];\nconsole.assert(\n  equal(quest3, ['¿Cuál es la moneda de México?', 'Peso']),\n);\nconsole.assert(quest3[1] === 'Peso');\n\n</code></pre>\n<p>A continuación Michelle nos explica los conceptos principales de <code>arrays</code> con un\nejemplo:</p>\n<p><a href=\"https://www.youtube.com/watch?v=-hLSzYr3z44\"><img src=\"https://img.youtube.com/vi/-hLSzYr3z44/0.jpg\" alt=\"ejemplo array dinosaurios pg 44 JS for Kids\"></a></p>"
            },
            "pt": {
              "title": "Arrays",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Aprenda o que são vetores (<em>arrays</em>) e para que servem</li>\n<li>Aprenda a criar, acessar e modificar os dados de um vetor</li>\n</ul>\n<p>O texto a seguir se baseia em grande medida, com alguns ajustes, ao capítulo 4\ndo <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn Haverbeke,\n2014. Tradução em\n<a href=\"https://github.com/braziljs/eloquente-javascript/blob/master/chapters/01-valores-tipos-operadores.md\">Português</a>,\ne ao capítulo 3 do <a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for\nkids</a>,\nNick Morgan, 2015;</p>\n<hr>\n<h2>Agrupando e manipulando dados</h2>\n<p>Como vimos, grande parte da programação consiste em agrupar e manipular dados.\nIsso nos permite transformar dados em informações e usar essas informações para\nresolver problemas. Até agora, pudemos agrupar e manipular dados usando tipos de\ndados simples, tais como: <em>numbers</em>, <em>booleans</em> e <em>strings</em>. Com eles, criamos\numa série de programas simples. Também aprendemos a modificar o fluxo desses\nprogramas, através de estruturas repetitivas, condicionais e funcionais, as\nquais nos permitiram criar produtos um pouco mais complexos. No entanto, nossos\nprogramas tinham muitas limitações porque operávamos apenas com <strong>tipos de dados\nsimples</strong>.</p>\n<p>Para resolver problemas mais complexos, precisamos ser capazes de agrupar e\nmanipular dados de uma maneira mais interessante. Felizmente, um ambiente\nJavaScript nos permite alcançar isso através de <em>arrays</em> e <em>objects</em>.</p>\n<h2>Por que precisamos de matrizes?</h2>\n<p>Digamos, por exemplo, que queiramos representar um conjunto de números: <code>2</code>,\n<code>3</code>, <code>5</code>, <code>7</code> e <code>11</code></p>\n<p>Uma opção para representar isso seria:</p>\n<pre><code class=\"language-javascript\">const firstNumber = 2;\nconst secondNumber = 3;\nconst thirdNumber = 5;\nconst fourthNumber = 7;\n</code></pre>\n<p>Esta lista é bem estranha e trabalhosa. Isso implica em ter uma variável para\ncada elemento da nossa lista. Quando, na realidade, devemos ter apenas uma única\nvariável que \"contenha\" cada um. Imagine se você quiser uma lista de 1.000\nelementos!</p>\n<p>Outra opção - mais criativa - seria usar uma <code>string</code>. Afinal, as <em>strings</em>\npodem ser de qualquer tamanho, e então podemos colocar muita informação nelas.\nPoderíamos usar uma cadeia de caracteres (<em>string</em>) com os números\nintercalados por um espaço, como esta:</p>\n<pre><code class=\"language-javascript\">const listOfNumbers = '2 3 5 7 11';\n</code></pre>\n<p>No entanto, isso também é complicado. Teríamos que encontrar uma maneira de\nextrair cada elemento de uma <code>string</code> (considerando os espaços entre eles) e\ntambém teríamos que convertê-los para <code>number</code> a fim de acessar e manipular cada\num dos números.</p>\n<p>Felizmente, o Javascript fornece um tipo específico de dados para armazenar\nsequência de valores. É chamado de <code>array</code> (arranjo ou vetor/matriz) e é\nescrito como uma lista de valores entre colchetes, separados por vírgulas.</p>\n<pre><code class=\"language-javascript\">const listOfNumbers = [2, 3, 5, 7, 11];\n</code></pre>\n<p>Os arranjos são extremamente úteis para agrupar e manipular dados. É como quando\nvamos ao mercado e temos nossa \"lista de compras\". Poderíamos ter uma folha de\npapel para cada item que queremos comprar. Por exemplo, poderíamos ter uma folha\nde papel que diz \"ovos\", outra folha que diz \"pão\" e outra folha que diz\n\"laranjas\". No entanto, a maioria das pessoas escreve todos os itens para\ncomprar em <strong>uma única folha de papel</strong>.</p>\n<h2>Acessando informações de um vetor</h2>\n<p>Antes de começar, vamos gerar uma pequena função utilitária, que nos permite\ndescobrir se duas <code>strings</code> são iguais.</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\nconsole.assert(equal([1, 2, 3], [1, 2, 3]));\nconsole.assert(!equal([1, 2, 3], ['a', 'b', 'c']));\nconsole.assert(!equal([1, 2, 3], [3, 2, 1]));\n</code></pre>\n<p>Para obter um elemento de um <code>array</code>, a notação com colchetes é usada contento o\níndice (<em>index</em>) do elemento desejado. Veja o exemplo abaixo:</p>\n<pre><code class=\"language-javascript\">const listOfNumbers = [2, 3, 5, 7, 11];\n\nconsole.assert(listOfNumbers[1] === 3);\nconsole.assert(listOfNumbers[1 - 1] === 2);\n</code></pre>\n<p>Índice é o número que corresponde a (ou coincide com) a posição em que o valor\né armazenado. Assim como nas <em>strings</em>, o primeiro elemento de um vetor está no\níndice <code>0</code>, o segundo no <code>1</code>, o terceiro no <code>2</code>, e assim por diante. É por isso\nque acessar o índice <code>1 - 1</code> no vetor acima, ou seja, devolve o número <code>2</code>\n(índice <code>0</code>).</p>\n<p><img src=\"https://user-images.githubusercontent.com/211721/40194836-51eebf22-59d1-11e8-8de8-8b29feb3bbf7.png\" alt=\"image\"></p>\n<p>Se você não tem experiência em programação, habituar-se com essa convenção pode\nlevar algum tempo. Mas a contagem baseada em zero tem uma longa tradição em\ntecnologia e, desde que a convenção seja seguida consistentemente (o que é\nfeito em JavaScript), ela funciona bem. Tome muito cuidado, pois esse descuido\né a causa de muitos <em>bugs</em>, inclusive para programadores um pouco mais\nexperientes.</p>\n<h2>Definindo ou alterando os elementos de um array</h2>\n<p>Podemos usar os índices entre colchetes para definir, alterar ou adicionar\nelementos a um vetor. Por exemplo, para substituir o primeiro elemento de\n<code>arraylistOfNumbers</code>  pelo número 1, poderíamos fazer o seguinte:</p>\n<pre><code class=\"language-js\">listOfNumbers[0] = 1;\n\nconsole.assert(\n  equal(listOfNumbers, [1, 3, 5, 7, 11]),\n);\n\n</code></pre>\n<p>Também podemos usar os índices entre colchetes para adicionar elementos em um\nvetor. Por exemplo, para adicionar o número 13 ao <em>array</em> <code>listOfNumbers</code>,\nfaríamos assim:</p>\n<pre><code class=\"language-js\">listOfNumbers[5] = 13;\n\nconsole.assert(\n  equal(listOfNumbers, [1, 3, 5, 7, 11, 13]),\n);\n\n</code></pre>\n<p>Ainda, podemos criar um vetor vazio e definir cada elemento individualmente a\nseguir, da seguinte maneira:</p>\n<pre><code class=\"language-js\">const listOfNumbers = [];\nlistOfNumbers[0] = 2;\nlistOfNumbers[1] = 3;\nlistOfNumbers[2] = 5;\nlistOfNumbers[3] = 7;\nlistOfNumbers[4] = 11;\n\nconsole.assert(\n  equal(listOfNumbers, [2, 3, 5, 7, 11]),\n);\n\n</code></pre>\n<h2>Misturando tipos de dados em <em>arrays</em></h2>\n<p>Os elementos de um <em>array</em> não precisam ser todos do mesmo tipo de dados.\nPodemos, por exemplo, ter um vetor que contenha um <code>number</code> (o número 3), uma\n<code>string</code> (\"dinossauros\") e outro <code>number</code> (o número 3627.5):</p>\n<pre><code class=\"language-js\">const mixedArray = [3, 'hola mundo', 3627.5];\nconsole.assert(mixedArray[0] === 3);\nconsole.assert(mixedArray[1] === 'hola mundo');\nconsole.assert(mixedArray[2] === 3627.5);\n\n</code></pre>\n<p>Podemos até ter um vetor dentro de outro (algo que muitas pessoas chamam de\nmatriz ou <em>array</em>  de 2 dimensões). Por exemplo, para organizar os dados de\nperguntas e respostas de um questionário, podemos usar um arranjo no qual cada\nelemento é um vetor com dois elementos: uma pergunta e uma resposta.</p>\n<pre><code class=\"language-js\">let questions = [\n  ['Em quantos países a Laboratoria opera?', 4],\n  ['Qual é a capital do Peru?', 'Lima'],\n  ['O que é dança chilena típica?', 'Cueca'],\n  ['Qual é a moeda do México?', 'Peso']\n];\n\n</code></pre>\n<p>Para acessar elementos individuais dos vetores internos, basta adicionar um novo\npar de colchetes com o índice correspondente. Por exemplo, para obter a resposta\npara a pergunta \"Qual é a moeda do México?\", nós faríamos:</p>\n<pre><code class=\"language-js\">questions = [\n  ['Em quantos países a Laboratoria opera?', 4],\n  ['Qual é a capital do Peru?', 'Lima'],\n  ['O que é dança chilena típica?', 'Cueca'],\n  ['Qual é a moeda do México?', 'Peso']\n];\nconsole.assert(questions[3][1] === 'Peso');\n\n</code></pre>\n<p>Vamos fazer de novo passo a passo:</p>\n<pre><code class=\"language-js\">questions = [\n  ['Em quantos países a Laboratoria opera?', 4],\n  ['Qual é a capital do Peru?', 'Lima'],\n  ['O que é dança chilena típica?', 'Cueca'],\n  ['Qual é a moeda do México?', 'Peso']\n];\nconst quest3 = questions[3];\nconsole.assert(\n  equal(quest3, ['Qual é a moeda do México?', 'Peso']),\n);\nconsole.assert(quest3[1] === 'Peso');\n\n</code></pre>\n<p>A seguir Juliana nos explica os conceitos principais de <code>arrays</code> con um\nexemplo:</p>\n<p><a href=\"https://www.youtube.com/watch?v=joMxeCl6ppg\"><img src=\"https://img.youtube.com/vi/joMxeCl6ppg/0.jpg\" alt=\"Arrays\"></a></p>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "array-proto",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Array.prototype",
              "body": "<p>Los arreglos (arrays) en JavaScript están implementados como objetos, lo cual\npuede sonar un poco raro, pero en JavaScript casi todos los tipos de datos\n(<code>Number</code>, <code>String</code>, <code>Array</code>, ...) están implementados como objetos, y como\ntales, los valores de estos <em>tipos</em> van a tener una serie de <em>métodos</em> y\n<em>propiedades</em> asociados a ellos. Técnicamente heredan estos <em>métodos</em> y\n<em>propiedades</em> de un <em>prototipo</em>.</p>\n<p>En este curso no vamos a profundizar en el mecanismo de <em>herencia prototipal</em>\nen JavaScript, pero sí necesitamos saber que todo arreglo en JavaScript es una\n<em>instancia</em> del <em>constructor</em> <code>Array</code>, y por tanto hereda todos los <em>métodos</em> y\n<em>propiedades</em> definidas en <code>Array.prototype</code>.</p>\n<p>De hecho, todos los objetos tienen un <em>prototipo</em>... y por ejemplo, es a través\nde estos prototipos que nuestros strings mágicamente tienen una <em>propiedad</em>\n<code>length</code> o un método <code>toLowerCase()</code>. Los hereda de <code>String.prototype.length</code> y\n<code>String.prototype.toLowerCase</code>.</p>\n<p>Regresando a los arreglos... veamos un ejempo. Abre la consola del navegador y\nescribe <code>[].</code>. Automáticamente debería salir una lista con todos los <em>métodos</em> y\n<em>propiedades</em> que tiene nuestro arreglo vacío (<code>[]</code>).</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/37485550-c77d636e-2859-11e8-8b76-21fc103691e5.png\" alt=\"Array methods and props in browser console\"></p>\n<h2>Propiedades <code>Array.prototype</code></h2>\n<p>Antes de comenzar, recordemos cómo era nuestra función\nque nos permitía comparar arrays</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\n</code></pre>\n<p>La única propiedad que nos interesa por ahora de los arreglos es\n<code>Array.prototype.length</code>, que es una propiedad de sólo lectura que siempre nos\nmuestra la longitud actual del arreglo. Por ejemplo:</p>\n<pre><code class=\"language-js\">console.assert([].length === 0);\nconsole.assert(['a'].length === 1);\nconsole.assert([true, 0, 'foo'].length === 3);\n\n</code></pre>\n<h2>Métodos comunes de <code>Array.prototype</code></h2>\n<p>JavaScript nos ofrece un montón de métodos para manipular arreglos, para iterar\nsobre ellos, ... no te preocupes por memorizar la lista completa (no creo que\nnadie la sepa de memoria), poco a poco con el uso irás familiarizándote y\naprendiendo a apreciar sus beneficios. Recuerda que siempre tienes la\n<a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array\">documentación oficial</a>\ndisponible, haz uso de ella, es la mejor referencia.</p>\n<p>Veamos algunos métodos comunes de los arreglos.</p>\n<h3><code>Array.prototype.push</code></h3>\n<p>El método <code>Array.prototype.push</code> recibe un valor, lo agrega al final del\narreglo sobre el que se invocó y retorna la nueva longitud del arreglo.</p>\n<pre><code class=\"language-js\">let arr = [0, 0, 0];\nconsole.assert(arr.length === 3);\nconsole.assert(typeof arr.push === 'function');\nconsole.assert(arr.push(1) === 4);\nconsole.assert(equal(arr, [0, 0, 0, 1]));\n\n</code></pre>\n<p>En este caso, la funcionalidad del método <code>push()</code> puede replicarse usando una\nsimple asignación:</p>\n<pre><code class=\"language-js\">arr = [0, 0, 0];\nconsole.assert(arr.length === 3);\narr[arr.length] = 1;\nconsole.assert(equal(arr, [0, 0, 0, 1]));\n\n</code></pre>\n<p>La mayor diferencia es un tema de semántica y estilo/paradigma, quizás parezca\nsútil, pero creanme, más adelante verán lo valiosa que es. En programación\nmuchas veces veremos que hay más de una manera de hacer las cosas, lo cual puede\ncrear confusión y frustración, pero al final son el reflejo de diferentes formas\nde pensar en código, y cada una tiene su lugar. Por ejemplo, en <em>programación\nfuncional</em> que veremos más adelante en el Bootcamp, favorecemos el cómputo a\ntravés de la aplicación de argumentos a funciones y tratamos de evitar la\nasignación y mutación de valores. En ese contexto, y en particular en JavaScript\nmoderno, vamos a ver que los métodos de los arreglos nos van a permitir escribir\ncódigo más expresivo, conciso y, por qué no, bonito.</p>\n<h3><code>Array.prototype.pop</code></h3>\n<p>Éste método no recibe ningún argumento, simplemente extrae el último elemento\ndel arreglo y lo retorna (modificando el arreglo directamente - <em>in place</em>).</p>\n<pre><code class=\"language-js\">arr = ['oh', 'my', 'god'];\nconsole.assert(arr.pop() === 'god');\nconsole.assert(equal(arr, ['oh', 'my']));\n\n</code></pre>\n<h3><code>Array.prototype.slice</code></h3>\n<p><code>Array.prototype.slice</code> crea un nuevo arreglo con una copia superficial\n(<em>shallow copy</em>) de una porción del arreglo obre el cual se invoca. Recibe dos\nargumentos, <code>begin</code> y <code>end</code>, que indican que porción del arreglo queremos\ncopiar. <code>begin</code> es el índice a partir del cual queremos empezar a copiar, y\n<code>end</code> hasta donde copiar (sin incluir el elemento con índice <code>end</code>).</p>\n<p>El arreglo original no se ve modificado.</p>\n<p>Ejecuta los siguientes ejemplos en la consola del navegador para que veas como\nse comporta el método <code>slice()</code>.</p>\n<pre><code class=\"language-js\">arr = [3, 2, 1];\nconsole.assert(\n  equal(arr.slice(0), [3, 2, 1]),\n);\nconsole.assert(\n  equal(arr.slice(1), [2, 1]),\n);\nconsole.assert(\n  equal(arr.slice(2), [1]),\n);\nconsole.assert(\n  equal(arr.slice(-1), [1]),\n);\nconsole.assert(\n  equal(arr.slice(0, 1), [3]),\n);\nconsole.assert(\n  equal(arr, [3, 2, 1]),\n);\n\n</code></pre>\n<h3><code>Array.prototype.indexOf</code></h3>\n<p>El método <code>indexOf()</code> recibe un valor, y devuelve el índice que contenga ese\nvalor si lo encuentra, si no devuelve <code>-1</code>. Este método se usa de forma muy\ncomún para comprobar si un arreglo contiene un determinado valor.</p>\n<pre><code class=\"language-js\">arr = ['foo', 'bar', 'baz'];\nconsole.assert(arr.indexOf('foo') === 0);\nconsole.assert(arr.indexOf('hmmm') === -1);\n\n</code></pre>\n<h2>Propiedades y métodos heredados de Object.prototype</h2>\n<p>Cabe mencionar que los arreglos también heredan de <code>Object.prototype</code>\nindirectamente, al igual que todos los demás objetos en JavaScript, así que\nnuestros arreglos también tendrán métodos como <code>toString()</code> o <code>isPrototypeOf()</code>.\nEn la próxima unidad (y cursos posteriores) iremos explorando\n<code>Object.prototype</code>, el concepto de <em>herencia</em> y la cadena de prototipos.</p>\n<hr>\n<p>En esta lectura hemos visto algunos ejemplos de métodos que tienen todos los\narreglos, pero hay muchos más. Te recomendamos explorar la documentación oficial\nde <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype\">Array.prototype en MDN</a>,\nahí podrás ver todos los <em>métodos</em> y <em>propiedades</em> disponibles y sus interfaces\n(qué argumentos esperan, qué retornan, ...).</p>\n<h2>Lecturas complementarias</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array en MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\">Object.prototype en MDN</a></li>\n<li><a href=\"https://javascript.info/array\">Array en javascript.info</a></li>\n</ul>"
            },
            "pt": {
              "title": "Array Proto",
              "body": "<p>Arranjos (<em>arrays</em>) em JavaScript são implementados como objetos, o que pode\nsoar um pouco estranho mas, em JavaScript, quase todos os tipos de dados\n(<code>number</code>, <code>string</code>, <code>array</code>, ...) são implementados como objetos e, como tal,\nos valores desses <em>tipos</em> terão uma série de <em>métodos</em> e <em>propriedades</em>\nassociados a eles. Tecnicamente, eles herdam esses <em>métodos</em> e <em>propriedades</em> de\num <em>protótipo</em>.</p>\n<p>Neste curso, nós não vamos aprofundar o mecanismo de <em>herança prototipal</em>  em\nJavaScript, mas precisamos ao menos saber que qualquer arranjo (<em>array</em>) em\nJavaScript é uma <em>instância</em> do construtor (<em>constructor</em>) <code>Array</code> e,\nportanto, herda todos os <em>métodos</em> e <em>propriedades</em> definidos em\n<code>Array.prototype</code>.</p>\n<p>A propósito, todos os objetos têm um <em>protótipo</em> e, por exemplo, é através\ndesses protótipos que nossas <code>strings</code> magicamente possuem uma <em>propriedade</em>\n<code>length</code> ou um método <code>toLowerCase()</code>. São herdados de <code>String.prototype.length</code>\ne <code>String.prototype.toLowerCase</code>, respectivamente.</p>\n<p>Voltando aos arranjos... Vejamos um exemplo: abra o console do navegador e\ndigite <code>[].</code>. Deve aparecer automaticamente uma lista com todos os <em>métodos</em> e\n<em>propriedades</em> de nossa matriz vazia (<code>[]</code>):</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/37485550-c77d636e-2859-11e8-8b76-21fc103691e5.png\" alt=\"Métodos e propriedades de &#x22;Array&#x22; no console do\nnavegador\"></p>\n<h2>Propriedades de <code>Array.prototype</code></h2>\n<p>Antes de começar, vamos recordar como era a nossa função que nos permite\ncomparar arrays.</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\n</code></pre>\n<p>A única propriedade dos arranjos que nos interessa por agora é\n<code>Array.prototype.length</code>, uma propriedade de somente leitura que sempre nos\nmostra o comprimento atual do <em>array</em>. Por exemplo:</p>\n<pre><code class=\"language-js\">console.assert([].length === 0);\nconsole.assert(['a'].length === 1);\nconsole.assert([true, 0, 'foo'].length === 3);\n\n</code></pre>\n<h2>Métodos comuns de <code>Array.prototype</code></h2>\n<p>O JavaScript nos fornece um monte de métodos para manipular arranjos, iterá-los,\netc. Não se preocupe em memorizar a lista completa (não acredito que alguém\nsaiba de cabeça), pois você irá se familiarizar com eles conforme o uso,\naprendendo a tirar vantagem de seus benefícios. Lembre-se de que sempre há a\n<a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array\">documentação\noficial</a>\ndisponível. Faça uso dela, é a melhor referência.</p>\n<p>Vejamos alguns métodos comuns dos arranjos.</p>\n<h3>Array.prototype.push</h3>\n<p>O método <code>Array.prototype.push</code> recebe um valor, adiciona-o ao final do arranjo\npelo qual foi chamado e devolve o novo tamanho (ou comprimento).</p>\n<pre><code class=\"language-js\">let arr = [0, 0, 0];\nconsole.assert(arr.length === 3);\nconsole.assert(typeof arr.push === 'function');\nconsole.assert(arr.push(1) === 4);\nconsole.assert(equal(arr, [0, 0, 0, 1]));\n\n</code></pre>\n<p>Nesse caso, a funcionalidade do método <code>push()</code> pode ser replicada usando uma\nsimples atribuição:</p>\n<pre><code class=\"language-js\">arr = [0, 0, 0];\nconsole.assert(arr.length === 3);\narr[arr.length] = 1;\nconsole.assert(equal(arr, [0, 0, 0, 1]));\n\n</code></pre>\n<p>A maior diferença é uma questão de semântica e estilo/paradigma. Talvez pareça\nsutil, mas acredite, mais tarde você verá o quanto é valioso. Na programação,\nmuitas vezes veremos que há mais de uma maneira de fazer as coisas, o que pode\ncriar confusão e frustração mas, no final das contas, isso é o reflexo de\ndiferentes maneiras de pensar no código, e cada uma tem o seu lugar. Por\nexemplo, na <em>programação funcional</em> que veremos mais adiante no Bootcamp,\nfavorecemos o uso de múltiplos processadores aplicando argumentos a funções e\nevitando a atribuição e mudança de valores. Neste contexto, e em particular no\nJavaScript moderno, veremos que os métodos dos arranjos nos permitirão escrever\ncódigos mais expressivos, concisos e, por que não, bonitos.</p>\n<h3>Array.prototype.pop</h3>\n<p>Esse método não recebe nenhum argumento. Ele simplesmente extrai o último\nelemento do arranjo e o retorna (modificando o arranjo diretamente - <em>in\nplace</em>).</p>\n<pre><code class=\"language-js\">arr = ['oh', 'my', 'god'];\nconsole.assert(arr.pop() === 'god');\nconsole.assert(equal(arr, ['oh', 'my']));\n\n</code></pre>\n<h3>Array.prototype.slice</h3>\n<p><code>Array.prototype.slice</code> cria um novo arranjo através de uma cópia superficial _\n_(<em>shallow copy</em>) de uma parte do arranjo pelo qual é invocado. Ele recebe\ndois argumentos: <code>begin</code> e <code>end</code> que indicam qual parte do arranjo queremos\ncopiar (sem incluir o elemento de índice <code>end</code>).</p>\n<p>O arranjo original não é modificado.</p>\n<p>Execute os seguintes exemplos no console do navegador para ver como o método\n<code>slice()</code> se comporta.</p>\n<pre><code class=\"language-js\">arr = [3, 2, 1];\nconsole.assert(\n  equal(arr.slice(0), [3, 2, 1]),\n);\nconsole.assert(\n  equal(arr.slice(1), [2, 1]),\n);\nconsole.assert(\n  equal(arr.slice(2), [1]),\n);\nconsole.assert(\n  equal(arr.slice(-1), [1]),\n);\nconsole.assert(\n  equal(arr.slice(0, 1), [3]),\n);\nconsole.assert(\n  equal(arr, [3, 2, 1]),\n);\n\n</code></pre>\n<h3>Array.prototype.indexOf</h3>\n<p>O método <code>indexOf()</code> recebe um valor e devolve o índice do vetor que contém esse\nvalor se ele for encontrado, ou <code>-1</code> caso contrário.  Esse método é usado com\nmuita frequência para verificar se um arranjo contém um determinado valor\n(basta que o resultado seja diferente de <code>-1</code>).</p>\n<pre><code class=\"language-js\">arr = ['foo', 'bar', 'baz'];\nconsole.assert(arr.indexOf('foo') === 0);\nconsole.assert(arr.indexOf('hmmm') === -1);\n\n</code></pre>\n<h2>Propriedades e métodos herdados de Object.prototype</h2>\n<p>Vale ressaltar que os arranjos também herdam de <code>Object.prototype</code>\nindiretamente, assim como todos os demais objetos em JavaScript. Então nossos\narranjos também terão métodos como <code>toString()</code> ou <code>isPrototypeOf()</code>. Na próxima\nunidade (e cursos posteriores), vamos explorar <code>Object.prototype</code>, o conceito\nde <em>herança</em> e a cadeia de protótipos.</p>\n<p>Nesta leitura, vimos alguns exemplos de métodos que todos os arranjos possuem,\nmas há muitos mais. Recomendamos que você explore a documentação oficial do\n<a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array.prototype no MDN</a>;\nlá, você pode ver todos os <em>métodos</em> e <em>propriedades</em> disponíveis e suas\ninterfaces (quais argumentos eles esperam, o que devolvem, ...).</p>\n<h2>Leituras complementares</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array na\nMDN</a></li>\n<li><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object\">Object.prototype na\nMDN</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "03",
          "slug": "filter-map-sort-reduce",
          "type": "read",
          "duration": 45,
          "intl": {
            "es": {
              "title": "filter, map, sort y reduce",
              "body": "<p>Ya vimos algunos de los métodos de uso más común de los arreglos,\npero <code>Array.prototype</code> provee mucho métodos más.</p>\n<p>Para facilitarte un poco la vida, los hemos dividido de la siguiente manera:</p>\n<ul>\n<li>para agregar y quitar elementos: <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>slice</code>,\n<code>splice</code> y <code>concat</code>.</li>\n<li>para buscar elementos dentro del array: <code>indexOf</code>, <code>lastIndexOf</code>, <code>includes</code>,\n<code>find</code>, <code>findIndex</code> y <code>filter</code>.</li>\n<li>para transformar el array: <code>map</code>,<code>reduce</code>, <code>sort</code>, <code>reverse</code>, <code>split</code> y <code>join</code>.</li>\n</ul>\n<p>Nosotros ahora nos enfocaremos en los 4 que consideramos un poco más utilizados:\n<code>filter</code>, <code>map</code> <code>sort</code> y <code>reduce</code>.</p>\n<p>Para conocer al detalle cada unos de estos métodos, visita la documentación en\n<a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array#M.C3.A9todos\">MDN</a>,</p>\n<p>Como hasta ahora, apelamos a nuestra función para comparar arrays.</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\n</code></pre>\n<p>Y a un conjunto de datos que utilizaremos como ejemplo para nuestros ejemplos</p>\n<pre><code class=\"language-js\">const inventors = [\n  {\n    first: 'Ada',\n    last: 'Lovelace',\n    year: 1815,\n    passed: 1852,\n  },\n  {\n    first: 'Lise',\n    last: 'Meitner',\n    year: 1878,\n    passed: 1968,\n  },\n  {\n    first: 'Caroline',\n    last: 'Herschel',\n    year: 1750,\n    passed: 1848,\n  },\n  {\n    first: 'Hanna',\n    last: 'Hammarström',\n    year: 1829,\n    passed: 1909,\n  },\n];\n\n</code></pre>\n<p>Ahora que tenemos todo, comencemos.</p>\n<h2><code>Array.prototype.filter</code></h2>\n<p><code>filter</code> nos permite obtener un subconjunto de los elementos\ndel array, que cumplan con cierta condición</p>\n<pre><code class=\"language-js\">const deadBeforeSXX = inventors.filter(inventor => (inventor.passed &#x3C; 1900));\nconsole.assert(\n  equal(deadBeforeSXX, [\n    {\n      first: 'Ada',\n      last: 'Lovelace',\n      year: 1815,\n      passed: 1852,\n    },\n    {\n      first: 'Caroline',\n      last: 'Herschel',\n      year: 1750,\n      passed: 1848,\n    },\n  ]),\n);\n\n</code></pre>\n<h2><code>Array.prototype.map</code></h2>\n<p><code>map</code> nos permite visitar cada uno de los elementos del array,\nrecolectando en el proceso, un valor de retorno para cada\nelemento visitado</p>\n<p>Por ejemplo, supongamos que queremos un lista de nombre y apellido\nde nuestro dataset</p>\n<pre><code class=\"language-js\">const fullNames = inventors.map(inventor => `${inventor.first} ${inventor.last}`);\nconsole.assert(\n  equal(fullNames, [\n    'Ada Lovelace',\n    'Lise Meitner',\n    'Caroline Herschel',\n    'Hanna Hammarström',\n  ]),\n);\n\n</code></pre>\n<p>O los años que vivió cada una</p>\n<pre><code class=\"language-js\">const yearAlive = inventors.map(({\n  first, last, passed, year,\n}) => [`${first} ${last}`, passed - year]);\nconsole.assert(\n  equal(yearAlive, [\n    ['Ada Lovelace', 37],\n    ['Lise Meitner', 90],\n    ['Caroline Herschel', 98],\n    ['Hanna Hammarström', 80],\n  ]),\n);\n\n</code></pre>\n<h2><code>Array.prototype.sort</code></h2>\n<p>Ordena el array <em>in place</em>.</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 15];\narr.sort();\nconsole.assert(equal(arr, [1, 15, 2]));\n\n</code></pre>\n<p>Si te fijas bien, aquí hay algo raro, y es que por defecto sort ordena el array,\nconvirtiendo a todos los elementos en <code>Strings</code>,\nes por eso que <code>15</code> aparece antes que <code>2</code>.</p>\n<p>Cómo lo solucionamos?</p>\n<pre><code class=\"language-js\">const compareNumeric = (a, b) => {\n  if (a > b) return 1;\n  if (a === b) return 0;\n  /* if (a &#x3C; b) */\n  return -1;\n};\narr = [1, 2, 15];\narr.sort(compareNumeric);\nconsole.assert(\n  equal(arr, [1, 2, 15]),\n);\n\n</code></pre>\n<p>Veamos unos ejemplos más interesantes</p>\n<h3>Ordenar de mayor a menor según año de nacimiento</h3>\n<pre><code class=\"language-js\">let ordered = inventors.sort((a, b) => {\n  if (a.year > b.year) {\n    return 1;\n  }\n  return -1;\n});\nconsole.assert(equal(\n  ordered,\n  [\n    {\n      first: 'Caroline',\n      last: 'Herschel',\n      year: 1750,\n      passed: 1848,\n    },\n    {\n      first: 'Ada',\n      last: 'Lovelace',\n      year: 1815,\n      passed: 1852,\n    },\n    {\n      first: 'Hanna',\n      last: 'Hammarström',\n      year: 1829,\n      passed: 1909,\n    },\n    {\n      first: 'Lise',\n      last: 'Meitner',\n      year: 1878,\n      passed: 1968,\n    },\n  ],\n));\n\n</code></pre>\n<p>Podríamos haber escrito la función de comparación con un operador\nternario y obtenido el mismo resultado.</p>\n<pre><code class=\"language-js\">ordered = inventors.sort((a, b) => (a.year > b.year ? 1 : -1));\n\n</code></pre>\n<h3>Ordenar según la cantidad de años vividos</h3>\n<pre><code class=\"language-js\">const moreYearsAlive = inventors.sort((a, b) => {\n  const last = a.passed - a.year;\n  const next = b.passed - b.year;\n  return last > next ? -1 : 1;\n});\nconsole.assert(equal(\n  moreYearsAlive,\n  [\n    {\n      first: 'Caroline',\n      last: 'Herschel',\n      year: 1750,\n      passed: 1848,\n    },\n    {\n      first: 'Lise',\n      last: 'Meitner',\n      year: 1878,\n      passed: 1968,\n    },\n    {\n      first: 'Hanna',\n      last: 'Hammarström',\n      year: 1829,\n      passed: 1909,\n    },\n    {\n      first: 'Ada',\n      last: 'Lovelace',\n      year: 1815,\n      passed: 1852,\n    },\n  ],\n));\n\n</code></pre>\n<h2><code>Array.prototype.reduce</code></h2>\n<p>Cuando queremos iterar un array, usamos <code>forEach</code>.\nAhora bien, para hacer lo mismo pero recolectando una lista de valores,\ncon un valor de cada elemento, usamos <code>map</code>.</p>\n<p><code>reduce</code> es similar a map, pero lo usamos para iterar un array\ny obtener un <strong>único valor</strong> que contenga un consolidado de\ntodos los elementos.</p>\n<p>Su signatura es la siguiente:</p>\n<pre><code class=\"language-js\">let initial = 0;\nconst value = arr.reduce((previousValue, item, index, array) => {\n  /* aqui tu codigo */\n}, initial);\n\n</code></pre>\n<p>Donde</p>\n<ul>\n<li>\n<p><code>item</code> -- es el elemento actual que estamos iterando</p>\n</li>\n<li>\n<p><code>index</code> -- el índice actual</p>\n</li>\n<li>\n<p><code>array</code> -- el array actual.</p>\n</li>\n</ul>\n<p>Hasta aquí todo mas o menos normal, pero se agrega un parámetro:</p>\n<ul>\n<li><code>previousValue</code> -- que es el resultado de la llamada anterior de la función.\nEn la primera llamada a la función, el valor de <code>previousValue</code> es <code>initial</code>.</li>\n</ul>\n<p>Veamos un ejemplo simple: Sumar todos los elementos de un array</p>\n<pre><code class=\"language-js\">arr = [1, 2, 3, 4, 5];\ninitial = 0;\nconst arrSum = arr.reduce((sum, current) => sum + current, initial);\nconsole.assert(arrSum === 15);\n\n</code></pre>\n<p>Aqui usamos la variante más común de <code>reduce</code>, que sólo utiliza los dos primeros\nargumentos.</p>\n<p>Veamos más detalle que está sucediendo:</p>\n<ol>\n<li>En la primera llamada, <code>sum</code> tiene el valor <code>initial</code> (el segundo argumento\nde <code>reduce</code>), que es <code>0</code>. Y <code>current</code> es el primer elemento del array, que es\n<code>1</code>. Entonces el resultado es <code>1</code>.</li>\n<li>En la segunda llamada, <code>sum === 1</code>, y sumamos el segundo elemento del array\n(<code>2</code>) y devolvemos.</li>\n<li>En la tercera llamada, <code>sum === 3</code> y sumamos al tercer elemento (<code>3</code>) ...</li>\n</ol>\n<p>Y así sigue:</p>\n<p><img src=\"https://user-images.githubusercontent.com/211721/40194646-c88004e4-59d0-11e8-8ba2-71e6afeef003.png\" alt=\"image\"></p>\n<p>Si lo pasamos a una tabla, donde cada fila representa una llamada a la función\nsobre el próximo elemento del array</p>\n<p>|   |<code>sum</code>|<code>current</code>|<code>result</code>|\n|---|-----|---------|---------|\n|primera llamada|<code>0</code>|<code>1</code>|<code>1</code>|\n|segunda llamada|<code>1</code>|<code>2</code>|<code>3</code>|\n|tercera llamada|<code>3</code>|<code>3</code>|<code>6</code>|\n|cuarta llamada|<code>6</code>|<code>4</code>|<code>10</code>|\n|quinta llamada|<code>10</code>|<code>5</code>|<code>15</code>|</p>\n<p>Como se puede apreciar, el resultado de la llamada anterior, se convierte en el\nprimer parámetro de la próxima llamada.</p>\n<p>Y para terminar, solo decir que <code>reduceRight</code> hace lo mismo, pero comenzando por\nel final del array.</p>\n<p>Veamos ahora un par de ejemplos:</p>\n<h3>Calcular la cantidad de años vividos, de todas las inventoras sumadas</h3>\n<pre><code class=\"language-js\">const totalYears = inventors.reduce(\n  (total, inventor) => total + (inventor.passed - inventor.year),\n  0,\n);\nconsole.assert(totalYears === 305);\n\n</code></pre>\n<h3>Sumar la cantidad de apariciones de cada medio de transporte</h3>\n<p>Cambiamos de dataset</p>\n<pre><code class=\"language-js\">const transportationData = [\n  'car', 'car', 'truck', 'truck', 'bike', 'walk',\n  'car', 'van', 'bike', 'walk', 'car', 'van',\n  'car', 'truck',\n];\n\nconst transportReduceFn = (obj, item) => {\n  const result = {\n    ...obj,\n  };\n  /* si es la primera vez que encuentro este medio de transporte */\n  if (!obj[item]) {\n    result[item] = 0; /* inicializo en 0 */\n  }\n  result[item] += 1;\n  return result;\n};\n\nlet transportation = transportationData.reduce(transportReduceFn, {});\nconsole.assert(equal(\n  transportation,\n  {\n    car: 5, truck: 3, bike: 2, walk: 2, van: 2,\n  },\n));\n\n</code></pre>\n<h3>Ahora lo mismo, pero agregando un nuevo medio de transporte (pogostick)</h3>\n<pre><code class=\"language-js\">transportationData.push('pogostick');\ntransportation = transportationData.reduce(transportReduceFn, {});\nconsole.assert(equal(\n  transportation,\n  {\n    car: 5, truck: 3, bike: 2, walk: 2, van: 2, pogostick: 1,\n  },\n));\n\n</code></pre>\n<hr>\n<p>En esta lectura hemos visto algunos ejemplos de métodos de arrays que siempre al\ncomienzo, pero que una vez que uno aprende a dominarlos, son super útiles.</p>\n<h2>Lecturas complementarias</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array en MDN</a></li>\n<li><a href=\"https://javascript.info/array-methods\">Array methods en javascript.info</a></li>\n</ul>"
            },
            "pt": {
              "title": "filter, map, sort e reduce",
              "body": "<p>Já vimos alguns dos métodos de uso mais comuns para arrays, porém\n<code>Array.prototype</code> nos fornece vários outros métodos úteis.</p>\n<p>Para facilitar um pouco a vida, os dividimos da seguinte forma:</p>\n<ul>\n<li>para agregar e retirar elementos: <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>slice</code>,\n<code>splice</code> e <code>concat</code>.</li>\n<li>para buscar elementos dentro da array: <code>indexOf</code>, <code>lastIndexOf</code>, <code>includes</code>,\n<code>find</code>, <code>findIndex</code> e <code>filter</code>.</li>\n<li>para transformar arrays: <code>map</code>,<code>reduce</code>, <code>sort</code>, <code>reverse</code>, <code>split</code> e <code>join</code>.</li>\n</ul>\n<p>Agora focaremos nos quatro métodos que consideramos mais utilizados: <code>filter</code>,\n<code>map</code> <code>sort</code> e <code>reduce</code>.</p>\n<p>Para conhecer em detalhes cada um destes métodos, visite a documentação no\n<a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array\">MDN</a></p>\n<p>Vamos usar uma função para comparar arrays.</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\n</code></pre>\n<p>Abaixo segue  um conjunto de dados que utilizaremos como exemplo para nossos\nexemplos :)</p>\n<pre><code class=\"language-js\">const inventors = [\n  {\n    first: 'Ada',\n    last: 'Lovelace',\n    year: 1815,\n    passed: 1852,\n  },\n  {\n    first: 'Lise',\n    last: 'Meitner',\n    year: 1878,\n    passed: 1968,\n  },\n  {\n    first: 'Caroline',\n    last: 'Herschel',\n    year: 1750,\n    passed: 1848,\n  },\n  {\n    first: 'Hanna',\n    last: 'Hammarström',\n    year: 1829,\n    passed: 1909,\n  },\n];\n\n</code></pre>\n<p>Agora que já temos o que precisamos, vamos começar.</p>\n<h2><code>Array.prototype.filter</code></h2>\n<p><code>filter</code> nos permite obter um subconjunto dos elementos da array, desde que\ncumpram uma certa condição.</p>\n<pre><code class=\"language-js\">const deadBeforeSXX = inventors.filter(inventor => (inventor.passed &#x3C; 1900));\nconsole.assert(\n  equal(deadBeforeSXX, [\n    {\n      first: 'Ada',\n      last: 'Lovelace',\n      year: 1815,\n      passed: 1852,\n    },\n    {\n      first: 'Caroline',\n      last: 'Herschel',\n      year: 1750,\n      passed: 1848,\n    },\n  ]),\n);\n\n</code></pre>\n<p>A seguir o Dani explica mais a fundo como o método <code>filter</code> funciona:</p>\n<p><a href=\"https://www.youtube.com/watch?v=M0sG5YTRiII\"><img src=\"https://img.youtube.com/vi/M0sG5YTRiII/0.jpg\" alt=\"Filtrando Arrays em\nJavaScript\"></a></p>\n<h2><code>Array.prototype.map</code></h2>\n<p><code>map</code> nos permite visitar cada um dos elementos da array, coletando neste\nprocesso um valor de retorno para cada elemento visitado.</p>\n<p>Por exemplo, supondo que queremos uma lista de nomes e sobrenomes da nossa base\nde dados.</p>\n<pre><code class=\"language-js\">const fullNames = inventors.map(inventor => `${inventor.first} ${inventor.last}`);\nconsole.assert(\n  equal(fullNames, [\n    'Ada Lovelace',\n    'Lise Meitner',\n    'Caroline Herschel',\n    'Hanna Hammarström',\n  ]),\n);\n\n</code></pre>\n<p>Ou quantos anos cada uma viveu.</p>\n<pre><code class=\"language-js\">const yearAlive = inventors.map(({\n  first, last, passed, year,\n}) => [`${first} ${last}`, passed - year]);\nconsole.assert(\n  equal(yearAlive, [\n    ['Ada Lovelace', 37],\n    ['Lise Meitner', 90],\n    ['Caroline Herschel', 98],\n    ['Hanna Hammarström', 80],\n  ]),\n);\n\n</code></pre>\n<h2><code>Array.prototype.sort</code></h2>\n<p>Ordena a array <em>in place</em> (ou seja, dentro da própria array).</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 15];\narr.sort();\nconsole.assert(equal(arr, [1, 15, 2]));\n\n</code></pre>\n<p>Se olhar bem, vai perceber que algo está estranho: por padrão, <code>sort</code> ordena a\narray convertendo todos os elementos em <code>strings</code>. Por isso <code>15</code> apareceu antes\nde <code>2</code>.</p>\n<p>Como resolvemos isso?</p>\n<pre><code class=\"language-js\">const compareNumeric = (a, b) => {\n  if (a > b) return 1;\n  if (a === b) return 0;\n  /* if (a &#x3C; b) */\n  return -1;\n};\narr = [1, 2, 15];\narr.sort(compareNumeric);\nconsole.assert(\n  equal(arr, [1, 2, 15]),\n);\n\n</code></pre>\n<p>Vejamos alguns exemplos mais interessantes.</p>\n<h3>Ordenar de maior a menor segundo o ano de nascimento</h3>\n<pre><code class=\"language-js\">let ordered = inventors.sort((a, b) => {\n  if (a.year > b.year) {\n    return 1;\n  }\n  return -1;\n});\nconsole.assert(equal(\n  ordered,\n  [\n    {\n      first: 'Caroline',\n      last: 'Herschel',\n      year: 1750,\n      passed: 1848,\n    },\n    {\n      first: 'Ada',\n      last: 'Lovelace',\n      year: 1815,\n      passed: 1852,\n    },\n    {\n      first: 'Hanna',\n      last: 'Hammarström',\n      year: 1829,\n      passed: 1909,\n    },\n    {\n      first: 'Lise',\n      last: 'Meitner',\n      year: 1878,\n      passed: 1968,\n    },\n  ],\n));\n\n</code></pre>\n<p>Poderíamos escrever a função de comparação usando um operador ternário, obtendo\no mesmo resultado.</p>\n<pre><code class=\"language-js\">ordered = inventors.sort((a, b) => (a.year > b.year ? 1 : -1));\n\n</code></pre>\n<h3>Ordenar segundo a quantidade de anos vividos</h3>\n<pre><code class=\"language-js\">const moreYearsAlive = inventors.sort((a, b) => {\n  const last = a.passed - a.year;\n  const next = b.passed - b.year;\n  return last > next ? -1 : 1;\n});\nconsole.assert(equal(\n  moreYearsAlive,\n  [\n    {\n      first: 'Caroline',\n      last: 'Herschel',\n      year: 1750,\n      passed: 1848,\n    },\n    {\n      first: 'Lise',\n      last: 'Meitner',\n      year: 1878,\n      passed: 1968,\n    },\n    {\n      first: 'Hanna',\n      last: 'Hammarström',\n      year: 1829,\n      passed: 1909,\n    },\n    {\n      first: 'Ada',\n      last: 'Lovelace',\n      year: 1815,\n      passed: 1852,\n    },\n  ],\n));\n\n</code></pre>\n<h2><code>Array.prototype.reduce</code></h2>\n<p>Quando queremos iterar uma array, usamos <code>forEach</code>. Agora, para fazer o mesmo,\nmas coletando uma lista de valores, com um valor de cada elemento, usamos <code>map</code>.</p>\n<p><code>reduce</code> é similar ao <code>map</code>, porém o utilizamos para iterar uma array e obter um\n<strong>único valor</strong> que contenha um consolidado de todos os elementos.</p>\n<p>Façamos o seguinte:</p>\n<pre><code class=\"language-js\">let initial = 0;\nconst value = arr.reduce((previousValue, item, index, array) => {\n  /* aqui tu codigo */\n}, initial);\n\n</code></pre>\n<p>Onde</p>\n<ul>\n<li>\n<p><code>item</code> -- é o elemento atual que estamos iterando</p>\n</li>\n<li>\n<p><code>index</code> -- é o índice atual</p>\n</li>\n<li>\n<p><code>array</code> -- é a array atual</p>\n</li>\n</ul>\n<p>Até aqui tudo mais ou menos normal, porém adicionamos um parâmetro:</p>\n<ul>\n<li><code>valorPrevio</code> -- que é o resultado da chamada anterior da função. Na primeira\nchamada da função, o valor de <code>valorPrevio</code> é <code>inicial</code>.</li>\n</ul>\n<p>Vejamos um exemplo simples: somar todos os elementos de uma array.</p>\n<pre><code class=\"language-js\">arr = [1, 2, 3, 4, 5];\ninitial = 0;\nconst arrSum = arr.reduce((sum, current) => sum + current, initial);\nconsole.assert(arrSum === 15);\n\n</code></pre>\n<p>Aqui usamos a variante mais comum de <code>reduce</code>, que só utiliza os dois primeiros\nparâmetros.</p>\n<p>Vejamos com mais detalhes o que está acontecendo:</p>\n<ol>\n<li>Na primeira chamada, <code>soma</code> tem o valor de <code>inicial</code> (o segundo argumento de\n<code>reduce</code>), que é <code>0</code>. E <code>atual</code> é o primeiro elemento da array, que é <code>1</code>.\nEntão o resultado é <code>1</code>.</li>\n<li>Na segunda chamada, <code>sum === 1</code>, somamos o segundo elemento da array (<code>2</code>) e\ndevolvemos.</li>\n<li>Na terceira chamada, <code>sum === 3</code> e somamos ao terceiro elemento (<code>3</code>) ...</li>\n</ol>\n<p>E assim segue:</p>\n<p><img src=\"https://user-images.githubusercontent.com/211721/40194646-c88004e4-59d0-11e8-8ba2-71e6afeef003.png\" alt=\"image\"></p>\n<p>Se passarmos para uma tabela, onde cada fila representa uma chamada da função\nsobre o próximo elemento da array:</p>\n<p>|                |<code>soma</code>|<code>atual</code>|<code>resultado</code>|\n|----------------|------|-------|-----------|\n|primeira chamada|  <code>0</code> |  <code>1</code>  |    <code>1</code>    |\n|segunda chamada |  <code>1</code> |  <code>2</code>  |    <code>3</code>    |\n|terceira chamada|  <code>3</code> |  <code>3</code>  |    <code>6</code>    |\n|quarta chamada  |  <code>6</code> |  <code>4</code>  |   <code>10</code>    |\n|quinta chamada  | <code>10</code> |  <code>5</code>  |   <code>15</code>    |</p>\n<p>Como podemos ver, o resultado da chamada anterior se converte no primeiro\nparâmetro da próxima chamada.</p>\n<p>Finalizando, apenas vamos mencionar que <code>reduceRight</code> faz a mesma coisa, porém\ncomeçando pelo final da array.</p>\n<p>Vejamos agora dois exemplos:</p>\n<h3>Calcular a quantidade de anos vividos de todas as inventoras, somados</h3>\n<pre><code class=\"language-js\">const totalYears = inventors.reduce(\n  (total, inventor) => total + (inventor.passed - inventor.year),\n  0,\n);\nconsole.assert(totalYears === 305);\n\n</code></pre>\n<h3>Somar a quantidade de ocorrências de cada meio de transporte</h3>\n<p>Vamos mudar de base de dados.</p>\n<pre><code class=\"language-js\">const transportationData = [\n  'car', 'car', 'truck', 'truck', 'bike', 'walk',\n  'car', 'van', 'bike', 'walk', 'car', 'van',\n  'car', 'truck',\n];\n\nconst transportReduceFn = (obj, item) => {\n  const result = {\n    ...obj,\n  };\n  /* si es la primera vez que encuentro este medio de transporte */\n  if (!obj[item]) {\n    result[item] = 0; /* inicializo en 0 */\n  }\n  result[item] += 1;\n  return result;\n};\n\nlet transportation = transportationData.reduce(transportReduceFn, {});\nconsole.assert(equal(\n  transportation,\n  {\n    car: 5, truck: 3, bike: 2, walk: 2, van: 2,\n  },\n));\n\n</code></pre>\n<h3>Agora a mesma coisa, porém agregando um novo meio de transporte (pogobol)</h3>\n<pre><code class=\"language-js\">transportationData.push('pogostick');\ntransportation = transportationData.reduce(transportReduceFn, {});\nconsole.assert(equal(\n  transportation,\n  {\n    car: 5, truck: 3, bike: 2, walk: 2, van: 2, pogostick: 1,\n  },\n));\n\n</code></pre>\n<hr>\n<p>Nesta leitura vimos alguns exemplos de métodos de arrays que, uma vez que se\naprende a dominá-los, são super úteis.</p>\n<h2>Leituras complementares</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array no\nMDN</a></li>\n<li><a href=\"https://javascript.info/array-methods\">Array methods em javascript.info (em\ninglês)</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "guided-exercises",
          "type": "practice",
          "duration": 80,
          "intl": {
            "es": {
              "title": "Ejercicios guiados",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender, a través de casos prácticos, cómo aplicar los conceptos de\n<code>funciones</code> y <code>arrays</code> para la resolución de problemas.</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Al igual que hemos hecho antes, es hora de aplicar los conceptos aprendidos para\nresolver problemas.</p>\n<p>A continuación tendrás varios problemas que debemos resolver. Intenta\nresolverlos primero por tu cuenta. Más abajo encontrarás las soluciones de\nLourdes, otra instructora estrella de Laboratoria. Después de haberlo intentado,\ncompara tus soluciones con las de Lourdes.</p>\n<h3>1. Reverse</h3>\n<p>Crea una función que invierta el orden de los elementos de un <code>array</code>. Completa\neste reto de dos maneras: en una, el <code>array</code> invertido es un <em>nuevo</em> <code>array</code>;\nen la segunda, modifica el mismo <code>array</code> que se proporciona como argumento.\nInvestiga sobre el método <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\"><code>reverse</code></a>.\n¿Qué puedes concluir?</p>\n<h3>2. Search</h3>\n<p>Crea una función que busque un elemento en un <code>array</code>, devolviendo su posición\n(index) e imprima el valor en la consola. Tip: utiliza el <a href=\"https://en.wikipedia.org/wiki/Linear_search\"><code>algoritmo de linear search</code></a>. Con este ejercicio\nintroducimos el concepto de <code>algoritmo</code>. Para entender qué es un algoritmo,\nrevisa los siguientes videos:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=U3CGMyjzlvM\">Magic Markers: ¿Qué es un algoritmo?</a></li>\n<li>[Kahn Academy: ¿Qué es un algoritmo y por qué debería importarte?]\n(<a href=\"https://es.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/v/what-are-algorithms\">https://es.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/v/what-are-algorithms</a>)</li>\n</ul>\n<h2>Solucionarios</h2>\n<p>A continuación, Lourdes te explica cómo resolvió cada uno de los ejercicios\nanteriores.</p>\n<h3>1. Reverse</h3>\n<p><a href=\"https://www.youtube.com/watch?v=BgcnOdIrUdo\"><img src=\"https://img.youtube.com/vi/BgcnOdIrUdo/0.jpg\" alt=\"Solution Reverse\"></a></p>\n<h3>2. Search</h3>\n<p><a href=\"https://www.youtube.com/watch?v=JjcDSIShTm0\"><img src=\"https://img.youtube.com/vi/JjcDSIShTm0/0.jpg\" alt=\"Solution Search\"></a></p>"
            },
            "pt": {
              "title": "Exercícios Livres",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender, através de casos práticos, como aplicar os conceitos de <code>funções</code> e\n<code>arrays</code> para a resolução de problemas.</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Como já fizemos anteriormente, agora é hora de aplicar os conceitos aprendidos\npara resolver problemas.</p>\n<p>A seguir, você verá vários problemas a serem resolvidos. Tente resolvê-los\nprimeiro por conta própria. Mais abaixo, você encontrará as soluções da nossa\nequipe. Depois que você tentar, compare suas soluções a nossa.</p>\n<h3>1. Reverse</h3>\n<p>Crie uma função que inverta a ordem dos elementos de um vetor (<em>array</em>).\nComplete este desafio de duas maneiras: em uma, o vetor invertido é um <strong>novo</strong>\nvetor; na segunda, modifique o <strong>mesmo</strong> <em>array</em> que é fornecido como argumento\n(<em>in place</em>). Pesquise o método\n<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\"><code>reverse</code></a>.\nO que você pode concluir?</p>\n<h3>2. Search</h3>\n<p>Crie uma função que procure um elemento em um vetor, retorne sua posição\n(índice - <em>index</em>) e imprima o valor no console. Dica: use o <a href=\"https://en.wikipedia.org/wiki/Linear_search\">algoritmo de\nbusca linear</a>. Nesse exercício,\nintroduzimos o conceito de <strong>algoritmo</strong>. Para entender o que é um algoritmo,\nconfira os seguintes vídeos:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=U3CGMyjzlvM\">Magic Markers: O que é um\nalgoritmo?</a></li>\n<li><a href=\"https://pt.khanacademy.org/computing/computer-science/algorithms/intro-to-algorithms/v/what-are-algorithms\">Kahn Academy: O que é um algoritmo e por que você deve se importar com\nisso?</a></li>\n</ul>\n<h2>Soluções</h2>\n<p>A seguir, Rafael lhe explicará como ele resolveu cada um dos exercícios\nanteriores.</p>\n<h3>1. Reverse</h3>\n<p><a href=\"https://www.youtube.com/watch?v=ErS_iFp8eFc&#x26;t\"><img src=\"https://img.youtube.com/vi/ErS_iFp8eFc&#x26;t/0.jpg\" alt=\"Solução para\nReverse\"></a></p>\n<h3>2. Search</h3>\n<p><a href=\"https://www.youtube.com/watch?v=AJCWkJgTCj0\"><img src=\"https://img.youtube.com/vi/AJCWkJgTCj0/0.jpg\" alt=\"Solução para\nSearch\"></a></p>"
            }
          },
          "challenges": []
        },
        {
          "prefix": "06",
          "slug": "practice",
          "type": "practice",
          "duration": 180,
          "intl": {
            "es": {
              "title": "Retos de código",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>A continuación te presentamos una serie de retos que debes completar para\nponer tus conocimientos a prueba.</li>\n</ul>"
            },
            "pt": {
              "title": "Exercícios",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>A seguir, apresentaremos uma série de desafios para você completar enquanto\ncoloca seus conhecimentos à prova.</li>\n</ul>"
            }
          },
          "challenges": [
            {
              "slug": "compute-average-length-of-words",
              "prefix": "01",
              "path": "topics/javascript/04-arrays/06-practice/01-compute-average-length-of-words",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "computeAverageLengthOfWords",
                  "body": "<p>Escribe una función 'computeAverageLengthOfWords' que recibe dos strings y\ndevuelve el promedio de la longitud de ambos strings.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const output = computeAverageLengthOfWords('code', 'programs');\nconsole.log(output); // --> 6\n</code></pre>"
                },
                "pt": {
                  "title": "computeAverageLengthOfWords",
                  "body": "<p>Escreva uma função <code>computeAverageLengthOfWords</code> que receba duas strings e\ndevolva o comprimento médio de ambas as strings.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const output = computeAverageLengthOfWords('code', 'programs');\nconsole.log(output); // --> 6\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/computeAverageLengthOfWords.js": "const computeAverageLengthOfWords = (word1, word2) => {\n  // your code here\n\n};\n\nmodule.exports = computeAverageLengthOfWords;\n",
                "/solution/computeAverageLengthOfWords.js": "const computeAverageLengthOfWords = (word1, word2) => (word1.length + word2.length) / 2;\n\nmodule.exports = computeAverageLengthOfWords;\n",
                "/test/computeAverageLengthOfWords.spec.js": "const { assert } = require('chai');\nconst computeAverageLengthOfWords = require('../solution/computeAverageLengthOfWords');\n\ndescribe('computeAverageLengthOfWords()', () => {\n  it('debería regresar  4, para  (\"A\", \"kamnjhs\")', () => {\n    assert.deepEqual(computeAverageLengthOfWords('A', 'kamnjhs'), 4);\n  });\n\n  it('debería regresar  12, para (\"Lalalalala\", \"Kekekekekekeke\")', () => {\n    assert.deepEqual(computeAverageLengthOfWords('Lalalalala', 'Kekekekekekeke'), 12);\n  });\n\n  it('debería regresar 5, para (\"Kemal\", \"Kemal\")', () => {\n    assert.deepEqual(computeAverageLengthOfWords('Kemal', 'Kemal'), 5);\n  });\n});\n"
              }
            },
            {
              "slug": "get-nth-element",
              "prefix": "02",
              "path": "topics/javascript/04-arrays/06-practice/02-get-nth-element",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getNthElement",
                  "body": "<p>Escribe una función llamada <code>getNthElement</code>.</p>\n<p>Dado un arreglo y un entero, <code>getNthElement</code> devuelve el valor según el entero\ndado, dentro del arreglo dado.</p>\n<p>Notas:</p>\n<ul>\n<li>Si el arreglo tiene una longitud de 0, debería devolver' <code>undefined</code>'.</li>\n</ul>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const output = getNthElement([1, 3, 5], 1);\nconsole.log(output); // --> 3\n</code></pre>"
                },
                "pt": {
                  "title": "getNthElement",
                  "body": "<p>Escreva uma função chamada <code>getNthElement</code>.</p>\n<p>Dado um <em>array</em> e um inteiro, <code>getNthElement</code> devolve o valor de acordo com o\ninteiro dado, dentro do array fornecido.</p>\n<p>Notas:</p>\n<ul>\n<li>Se o array tiver um comprimento de <code>0</code>, ele deve retornar  <code>undefined</code>.</li>\n</ul>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const output = getNthElement([1, 3, 5], 1);\nconsole.log(output); // --> 3\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getNthElement.js": "const getNthElement = (array, n) => {\n  // your code here\n};\n\nmodule.exports = getNthElement;\n",
                "/solution/getNthElement.js": "const getNthElement = (array, n) => array[n];\n\nmodule.exports = getNthElement;\n",
                "/test/getNthElement.spec.js": "const { assert } = require('chai');\nconst getNthElement = require('../solution/getNthElement');\n\ndescribe('getNthElement()', () => {\n  it('debería regresar undefined, para array vacío', () => {\n    const arr = [];\n    assert.deepEqual(getNthElement(arr, 1), undefined);\n  });\n\n  it('debería regresar 2, para getNthElement([1, 2, 3, 4, 5, 6, 100, 7, 9], 1)', () => {\n    const arr = [1, 2, 3, 4, 5, 6, 100, 7, 9];\n    assert.deepEqual(getNthElement(arr, 1), 2);\n  });\n});\n"
              }
            },
            {
              "slug": "convert-double-space-to-single",
              "prefix": "03",
              "path": "topics/javascript/04-arrays/06-practice/03-convert-double-space-to-single",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "convertDoubleSpaceToSingle",
                  "body": "<p>Escribe una función llamada <code>convertDoubleSpaceToSingle</code>.</p>\n<p>Dada una cadena, <code>convertDoubleSpaceToSingle</code> devuelve la cadena pasada en\ncadena con todos los espacios dobles convertidos a espacios simples.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const output = convertDoubleSpaceToSingle('string  with  double  spaces');\nconsole.log(output); // --> \"string with double spaces\"\n\n</code></pre>\n<p>Notas:</p>\n<ul>\n<li>Para hacer este problema, debes estar familiarizada con <code>String.split</code>, y <code>Array.join</code>.</li>\n</ul>"
                },
                "pt": {
                  "title": "convertDoubleSpaceToSingle",
                  "body": "<p>Escreva uma função chamada <code>convertDoubleSpaceToSingle</code>.</p>\n<p>Dada uma <em>string</em>,  <code>convertDoubleSpaceToSingle</code> devolve essa cadeia de\ncaracteres com os espaços duplos convertidos em espaços simples.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const output = convertDoubleSpaceToSingle(\"string  with  double  spaces\");\nconsole.log(output); // --> \"string with double spaces\"\n</code></pre>\n<p>Notas:</p>\n<ul>\n<li>Para resolver esse problema, você deve estar familiarizado com <code>String.split</code>e\n<code>Array.join</code>.</li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/convertDoubleSpaceToSingle.js": "const convertDoubleSpaceToSingle = (str) => {\n  // your code here\n};\n\nmodule.exports = convertDoubleSpaceToSingle;\n",
                "/solution/convertDoubleSpaceToSingle.js": "const convertDoubleSpaceToSingle = str => str.split('  ').join(' ');\n\nmodule.exports = convertDoubleSpaceToSingle;\n",
                "/test/convertDoubleSpaceToSingle.spec.js": "const { assert } = require('chai');\nconst convertDoubleSpaceToSingle = require('../solution/convertDoubleSpaceToSingle');\n\ndescribe('convertDoubleSpaceToSingle()', () => {\n  it(\"debería regresar '', para string vacío\", () => {\n    assert.deepEqual(convertDoubleSpaceToSingle(''), '');\n  });\n\n  it(\"debería regresar 'Messi is the greatest player ever', para 'Messi  is  the  greatest  player  ever'\", () => {\n    const output = convertDoubleSpaceToSingle('Messi  is  the  greatest  player  ever');\n    assert.deepEqual(output, 'Messi is the greatest player ever');\n  });\n});\n"
              }
            },
            {
              "slug": "are-valid-credentials",
              "prefix": "04",
              "path": "topics/javascript/04-arrays/06-practice/04-are-valid-credentials",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "areValidCredentials",
                  "body": "<p>Escribe una función llamada <code>areValidCredentials</code>.</p>\n<p>Dando un nombre y una contraseña, <code>areValidCredentials</code>, devuelve <code>true</code> si el\nnombre es superior a 3 caracteres, Y, la contraseña tiene al menos 8 caracteres\nde longitud. De lo contrario, devuelve <code>false</code>.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const output = areValidCredentials('Ritu', 'mylongpassword');\nconsole.log(output); // --> true\n</code></pre>"
                },
                "pt": {
                  "title": "areValidCredentials",
                  "body": "<p>Escreva uma função chamada <code>areValidCredentials</code>.</p>\n<p>Dado um nome e uma senha, <code>areValidCredentials</code> retorna <code>true</code>se o nome contiver\nmais do que 3 caracteres e a senha, pelo menos 8 caracteres. Caso contrário,\nretorna <code>false</code>.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = areValidCredentials('Ritu', 'mylongpassword');\nconsole.log(output); // --> true\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/areValidCredentials.js": "const areValidCredentials = (name, password) => {\n  // your code here\n};\n\nmodule.exports = areValidCredentials;\n",
                "/solution/areValidCredentials.js": "const areValidCredentials = (name, password) => (name.length > 3 && password.length >= 8);\n\nmodule.exports = areValidCredentials;\n",
                "/test/areValidCredentials.spec.js": "const { assert } = require('chai');\nconst areValidCredentials = require('../solution/areValidCredentials');\n\ndescribe('areValidCredentials()', () => {\n  it('debería regresar true cuando las credenciales son válidas', () => {\n    const output = areValidCredentials('Kemal', 'testtesttest');\n    assert.deepEqual(output, true);\n  });\n\n  it('debería regresar false cuando el nombre es demasiado corto', () => {\n    const output = areValidCredentials('K', 'mylongpassword');\n    assert.deepEqual(output, false);\n  });\n\n  it('debería regresar false cuando la contraseña es demasiado corta', () => {\n    const output = areValidCredentials('Kemal', 'aah');\n    assert.deepEqual(output, false);\n  });\n});\n"
              }
            },
            {
              "slug": "find-pair-for-sum",
              "prefix": "05",
              "path": "topics/javascript/04-arrays/06-practice/05-find-pair-for-sum",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "findPairForSum",
                  "body": "<p>Dada una lista de números enteros no negativos y una suma objetivo, encuentra un\npar de números que sumen a la suma objetivo.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const pair = findPairForSum([3, 34, 4, 12, 5, 2], 9);\nconsole.log(pair); // --> [4, 5]\n\n</code></pre>"
                },
                "pt": {
                  "title": "findPairForSum",
                  "body": "<p>Dada uma lista de inteiros não negativos e o resultado desejado de uma soma,\nencontre dois números na lista cuja soma seja o resultado desejado.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const pair = findPairForSum([3, 34, 4, 12, 5, 2], 9);\nconsole.log(pair); // --> [4, 5]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/findPairForSum.js": "const findPairForSum = (array, number) => {\n\n};\n\nmodule.exports = findPairForSum;\n",
                "/solution/findPairForSum.js": "const findPairForSum = (array, number) => {\n  for (let i = 0; i < array.length; i += 1) {\n    for (let j = i + 1; j < array.length; j += 1) {\n      if ((array[i] + array[j]) === number) {\n        return [array[i], array[j]];\n      }\n    }\n  }\n\n  return [];\n};\n\nmodule.exports = findPairForSum;\n",
                "/test/findPairForSum.spec.js": "const { assert } = require('chai');\nconst findPairForSum = require('../solution/findPairForSum');\n\ndescribe('findPairForSum()', () => {\n  it('debería regresar [0, 1], para ([0, 8, 1, 7, 19, 12, 4], 1)', () => {\n    const pair = findPairForSum([0, 8, 1, 7, 19, 12, 4], 1);\n    const hasil = [0, 1];\n\n    assert.deepEqual(pair, hasil);\n  });\n\n  it('debería regresar [2, 11], para  ([1, 2, 6, 8, 11, 10], 13)', () => {\n    const pair = findPairForSum([1, 2, 6, 8, 11, 10], 13);\n    const hasil = [2, 11];\n\n    assert.deepEqual(pair, hasil);\n  });\n\n\n  it('debería regresar [4, 5], para ([3, 34, 4, 12, 5, 2], 9)', () => {\n    const pair = findPairForSum([3, 34, 4, 12, 5, 2], 9);\n    const hasil = [4, 5];\n\n    assert.deepEqual(pair, hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "filter-odd-elements",
              "prefix": "06",
              "path": "topics/javascript/04-arrays/06-practice/06-filter-odd-elements",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "filterOddElements",
                  "body": "<p>Escribe una función llamada \"filterOddElements\".</p>\n<p>Dado un array de números,\"filterOddElements\" devuelve un array que contiene sólo\nlos números impares del array dado.</p>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = filterOddElements([1, 2, 3, 4, 5]);\nconsole.log(output); // --> [1, 3, 5]\n</code></pre>"
                },
                "pt": {
                  "title": "filterOddElements",
                  "body": "<p>Escreva uma função chamada <code>filterOddElements</code>.</p>\n<p>Dado um vetor de números, <code>filterOddElements</code> retorna um <em>array</em> que contém\napenas os números ímpares do vetor fornecido.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = filterOddElements([1, 2, 3, 4, 5]);\nconsole.log(output); // --> [1, 3, 5]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/filterOddElements.js": "const filterOddElements = (arr) => {\n  // your code here\n};\n\nmodule.exports = filterOddElements;\n",
                "/solution/filterOddElements.js": "const filterOddElements = (arr) => {\n  const ret = [];\n\n  for (let i = 0; i < arr.length; i += 1) {\n    if (arr[i] % 2 !== 0) {\n      ret.push(arr[i]);\n    }\n  }\n\n  return ret;\n};\n\nmodule.exports = filterOddElements;\n",
                "/test/filterOddElements.spec.js": "const { assert } = require('chai');\nconst filterOddElements = require('../solution/filterOddElements');\n\ndescribe('filterOddElements()', () => {\n  it('Prueba: ([2, 4, 6, 8, 10]) => []', () => {\n    const arr = [2, 4, 6, 8, 10];\n    const hasil = [];\n    const call = filterOddElements(arr);\n\n    assert.deepEqual(call, hasil);\n  });\n\n  it('Prueba: ([69, 10, 6, 8, 22]) => [69]', () => {\n    const arr = [69, 10, 6, 8, 22];\n    const hasil = [69];\n    const call = filterOddElements(arr);\n\n    assert.deepEqual(call, hasil);\n  });\n\n\n  it('Prueba: ([1, 2, 3, 4, 5]) => [1, 3, 5]', () => {\n    const arr = [1, 2, 3, 4, 5];\n    const hasil = [1, 3, 5];\n    const call = filterOddElements(arr);\n\n    assert.deepEqual(call, hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "find-shortest-word-among-mixed-elements",
              "prefix": "07",
              "path": "topics/javascript/04-arrays/06-practice/07-find-shortest-word-among-mixed-elements",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "findShortestWordAmongMixedElements",
                  "body": "<p>Escribe una función llamada \"findShortestWordAmongMixedElements\".</p>\n<p>Dado un array, \"findShortestWordAmongMixedElements\" devuelve la cadena más corta\ndentro del array dado.</p>\n<p>Notas:</p>\n<ul>\n<li>Si hay vínculos, debería devolver el primer elemento que aparezca en el array\ndado.</li>\n<li>Espera que el array tenga otros valores además de las cuerdas.</li>\n<li>Si el array dado está vacío, debería devolver una cadena vacía.</li>\n<li>Si el array dado no contiene cadenas, debería devolver una cadena vacía.</li>\n</ul>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = findShortestWordAmongMixedElements([4, 'two', 2, 'three']);\nconsole.log(output); // --> 'two'\n</code></pre>"
                },
                "pt": {
                  "title": "findShortestWordAmongMixedElements",
                  "body": "<p>Escreva uma função chamada \"findShortestWordAmongMixedElements\".</p>\n<p>Dado um <em>array</em>, \"findShortestWordAmongMixedElements\" devolve a string mais\ncurta encontrada no <em>array</em> especificado.</p>\n<p>Notas:</p>\n<ul>\n<li>Se houver repetições, você deve optar pelo primeiro elemento que aparece no\n<em>array</em> especificado.</li>\n<li>Assuma que o array pode ter outros valores além de <em>strings</em>.</li>\n<li>Se o <em>array</em> informado estiver vazio, ela deve devolver uma <em>string</em> vazia.</li>\n<li>Se o <em>array</em> informado não contiver <em>strings</em>, ela deverá retornar uma\n<em>string</em> vazia.</li>\n</ul>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = findShortestWordAmongMixedElements([4, 'two', 2, 'three']);\nconsole.log(output); // --> 'two'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/findShortestWordAmongMixedElements.js": "const findShortestWordAmongMixedElements = (arr) => {\n  // your code here\n};\n\nmodule.exports = findShortestWordAmongMixedElements;\n",
                "/solution/findShortestWordAmongMixedElements.js": "const findShortestWordAmongMixedElements = (arr) => {\n  if (arr.length === 0) {\n    return '';\n  }\n\n  let min = 10000;\n  let index = -1;\n\n  for (let i = 0; i < arr.length; i += 1) {\n    if (typeof arr[i] === 'string') {\n      if (arr[i].length < min) {\n        min = arr[i];\n        index = i;\n      }\n    }\n  }\n\n  if (index === -1) {\n    return '';\n  }\n\n  return arr[index];\n};\n\nmodule.exports = findShortestWordAmongMixedElements;\n",
                "/test/findShortestWordAmongMixedElements.spec.js": "const { assert } = require('chai');\nconst findShortestWordAmongMixedElements = require('../solution/findShortestWordAmongMixedElements');\n\ndescribe('findShortestWordAmongMixedElements()', () => {\n  it(\"debería regresar '', para  ([3, 4, 5])\", () => {\n    const output = findShortestWordAmongMixedElements([3, 4, 5]);\n    assert.deepEqual(output, '');\n  });\n\n  it(\"debería regresar '', para ([])\", () => {\n    const output = findShortestWordAmongMixedElements([]);\n    assert.deepEqual(output, '');\n  });\n\n\n  it(\"debería regresar 'yes', para ([1, 2, 3, 'yes', 'one')\", () => {\n    const output = findShortestWordAmongMixedElements([1, 2, 3, 'yes', 'one']);\n    assert.deepEqual(output, 'yes');\n  });\n\n\n  it(\"debería regresar 'two', para [4, 'two', 2, 'three'])\", () => {\n    const output = findShortestWordAmongMixedElements([4, 'two', 2, 'three']);\n    assert.deepEqual(output, 'two');\n  });\n});\n"
              }
            },
            {
              "slug": "find-smallest-number-among-mixed-elements",
              "prefix": "08",
              "path": "topics/javascript/04-arrays/06-practice/08-find-smallest-number-among-mixed-elements",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "findSmallestNumberAmongMixedElements",
                  "body": "<p>Escribe una función llamada \"findSmallestNumberAmongMixedElements\".</p>\n<p>Dado un arreglo de elementos mixtos, \"findSmallestNumberAmongMixedElements\"\ndevuelve el número más pequeño dentro del arreglo dado.</p>\n<p>Notas:</p>\n<ul>\n<li>Si el arreglo está vacío, debería devolver 0.</li>\n<li>Si el arreglo no contiene números, debería devolver 0.</li>\n</ul>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = findSmallestNumberAmongMixedElements([4, 'lincoln', 9, 'octopus']);\nconsole.log(output); // --> 4\n</code></pre>"
                },
                "pt": {
                  "title": "findSmallestNumberAmongMixedElements",
                  "body": "<p>Escreva uma função chamada \"findSmallestNumberAmongMixedElements\".</p>\n<p>Dado um array de elementos mistos, \"findSmallestNumberAmongMixedElements\"\ndevolve o menor número dentro do <em>array</em> especificado.</p>\n<p>Notas:</p>\n<ul>\n<li>Se o <em>array</em> estiver vazio, ela deve devolver <code>0</code>.</li>\n<li>Se  o <em>array</em> não contiver números, deverá devolver <code>0</code>.</li>\n</ul>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = findSmallestNumberAmongMixedElements([4, 'lincoln', 9, 'octopus']);\nconsole.log(output); // --> 4\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/findSmallestNumberAmongMixedElements.js": "const findSmallestNumberAmongMixedElements = (arr) => {\n  // your code here\n};\n\nmodule.exports = findSmallestNumberAmongMixedElements;\n",
                "/solution/findSmallestNumberAmongMixedElements.js": "const findSmallestNumberAmongMixedElements = (arr) => {\n  if (arr.length === 0) {\n    return '';\n  }\n\n  let min = 10000;\n  let index = -1;\n\n  for (let i = 0; i < arr.length; i += 1) {\n    if (typeof arr[i] === 'number') {\n      if (arr[i] < min) {\n        min = arr[i];\n        index = i;\n      }\n    }\n  }\n\n  if (index === -1) {\n    return '';\n  }\n\n  return arr[index];\n};\n\nmodule.exports = findSmallestNumberAmongMixedElements;\n",
                "/test/findSmallestNumberAmongMixedElements.spec.js": "const { assert } = require('chai');\nconst findSmallestNumberAmongMixedElements = require('../solution/findSmallestNumberAmongMixedElements');\n\ndescribe('findSmallestNumberAmongMixedElements()', () => {\n  it(\"debería regresar 0, para  (['cat', 'is', 'cute', 'as', 'fuck'])\", () => {\n    const output = findSmallestNumberAmongMixedElements(['cat', 'is', 'cute', 'as', 'fuck']);\n    assert.equal(output, 0);\n  });\n\n  it('debería regresar 0, para ([])', () => {\n    const output = findSmallestNumberAmongMixedElements([]);\n    assert.equal(output, 0);\n  });\n\n\n  it(\"debería regresar 1, para ([10, 9, 'Yes', 'why', 1, 'ahh'])\", () => {\n    const output = findSmallestNumberAmongMixedElements([10, 9, 'Yes', 'why', 1, 'ahh']);\n    assert.equal(output, 1);\n  });\n});\n"
              }
            },
            {
              "slug": "get-longest-word-of-mixed-elements",
              "prefix": "09",
              "path": "topics/javascript/04-arrays/06-practice/09-get-longest-word-of-mixed-elements",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getLongestWordOfMixedElements",
                  "body": "<p>Escribe una función llamada \"getLongestWordOfMixedElements\".</p>\n<p>Dado un arreglo de tipos mixtos, \"getLongestWordOfMixedElements\" devuelve la\ncadena más larga del arreglo dado.</p>\n<p>Notas:</p>\n<ul>\n<li>Si el arreglo está vacío, debería devolver una cadena vacía (\"\").</li>\n<li>Si el arreglo no contiene cadenas de texto, debería devolver una cadena vacía.</li>\n</ul>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = getLongestWordOfMixedElements([3, 'word', 5, 'up', 3, 1]);\nconsole.log(output); // --> 'word'\n</code></pre>"
                },
                "pt": {
                  "title": "getLongestWordOfMixedElements",
                  "body": "<p>Escreva uma função chamada \"getLongestWordOfMixedElements\".</p>\n<p>Dado um array de tipos mistos, \"getLongestWordOfMixedElements\" devolve a\n<em>string</em> mais longa do <em>array</em> especificado.</p>\n<p>Notas:</p>\n<ul>\n<li>Se o <em>array</em> estiver vazio, ela deve devolver uma <em>string</em> vazia (<code>\"\"</code>).</li>\n<li>Se o <em>array</em> não contiver cadeias de texto, ela deverá devolver uma <em>string</em>\nvazia.</li>\n</ul>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = getLongestWordOfMixedElements([3, 'word', 5, 'up', 3, 1]);\nconsole.log(output); // --> 'word'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getLongestWordOfMixedElements.js": "const getLongestWordOfMixedElements = (arr) => {\n  // your code here\n};\n\nmodule.exports = getLongestWordOfMixedElements;\n",
                "/solution/getLongestWordOfMixedElements.js": "const getLongestWordOfMixedElements = (arr) => {\n  if (arr.length === 0) {\n    return '';\n  }\n\n  let max = 0;\n  let index = -1;\n\n  for (let i = 0; i < arr.length; i += 1) {\n    if (typeof arr[i] === 'string') {\n      if (arr[i].length > max) {\n        max = arr[i].length;\n        index = i;\n      }\n    }\n  }\n\n  if (index === -1) {\n    return '';\n  }\n\n  return arr[index];\n};\n\nmodule.exports = getLongestWordOfMixedElements;\n",
                "/test/getLongestWordOfMixedElements.spec.js": "const { assert } = require('chai');\nconst getLongestWordOfMixedElements = require('../solution/getLongestWordOfMixedElements');\n\ndescribe('getLongestWordOfMixedElements()', () => {\n  it(\"debería regresar '', para  ([3, 4, 5, 6, 7])\", () => {\n    const output = getLongestWordOfMixedElements([3, 4, 5, 6, 7]);\n    assert.deepEqual(output, '');\n  });\n\n  it(\"debería regresar '', para ([])\", () => {\n    const output = getLongestWordOfMixedElements([]);\n    assert.deepEqual(output, '');\n  });\n\n\n  it(\"debería regresar 'word', para ([3, 'word', 5, 'up', 3, 1])\", () => {\n    const output = getLongestWordOfMixedElements([3, 'word', 5, 'up', 3, 1]);\n    assert.deepEqual(output, 'word');\n  });\n});\n"
              }
            },
            {
              "slug": "get-largest-number-among-mixed-elements",
              "prefix": "10",
              "path": "topics/javascript/04-arrays/06-practice/10-get-largest-number-among-mixed-elements",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getLargestNumberAmongMixedElements",
                  "body": "<p>Escriba una función llamada \"getLargestNumberAmongMixedElements\".</p>\n<p>Dado cualquier arreglo, \"getLargestNumberAmongMixedElements\" devuelve el mayor\nnúmero en el arreglo dado.</p>\n<p>Notas:</p>\n<ul>\n<li>El arreglo puede contener valores de un tipo distinto a los números.</li>\n<li>Si el arreglo está vacío, debería devolver 0.</li>\n<li>Si el arreglo no contiene números, debería devolver 0.</li>\n</ul>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = getLargestNumberAmongMixedElements([3, 'word', 5, 'up', 3, 1]);\nconsole.log(output); // --> 5\n</code></pre>"
                },
                "pt": {
                  "title": "getLargestNumberAmongMixedElements",
                  "body": "<p>Escreva uma função chamada \"getLargestNumberAmongMixedElements\".</p>\n<p>Dado qualquer vetor, \"getLargestNumberAmongMixedElements\" retorna o maior número\ndo vetor especificado.</p>\n<p>Notas:</p>\n<ul>\n<li>O <em>array</em> pode conter valores de um tipo diferente de <code>number</code>.</li>\n<li>Se o <em>array</em> estiver vazio, ela deve retornar <code>0</code>.</li>\n<li>Se o <em>array</em> não contiver números, deverá retornar <code>0</code>.</li>\n</ul>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = getLargestNumberAmongMixedElements([3, 'word', 5, 'up', 3, 1]);\nconsole.log(output); // --> 5\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getLargestNumberAmongMixedElements.js": "const getLargestNumberAmongMixedElements = (arr) => {\n  // your code here\n};\n\nmodule.exports = getLargestNumberAmongMixedElements;\n",
                "/solution/getLargestNumberAmongMixedElements.js": "const getLargestNumberAmongMixedElements = (arr) => {\n  if (arr.length === 0) {\n    return 0;\n  }\n\n  let max = 0;\n  let index = -1;\n\n  for (let i = 0; i < arr.length; i += 1) {\n    if (typeof arr[i] === 'number') {\n      if (arr[i] > max) {\n        max = arr[i];\n        index = i;\n      }\n    }\n  }\n\n  if (index === -1) {\n    return 0;\n  }\n\n  return arr[index];\n};\n\nmodule.exports = getLargestNumberAmongMixedElements;\n",
                "/test/getLargestNumberAmongMixedElements.spec.js": "const { assert } = require('chai');\nconst getLargestNumberAmongMixedElements = require('../solution/getLargestNumberAmongMixedElements');\n\ndescribe('getLargestNumberAmongMixedElements()', () => {\n  it(\"debería regresar 0, para  (['wat', 'no', true, true])\", () => {\n    const output = getLargestNumberAmongMixedElements(['wat', 'no', true, true]);\n    assert.deepEqual(output, 0);\n  });\n\n  it('debería regresar 0, para ([])', () => {\n    const output = getLargestNumberAmongMixedElements([]);\n    assert.deepEqual(output, 0);\n  });\n\n\n  it(\"debería regresar 5, para ([3, 'word', 5, 'up', 3, 1])\", () => {\n    const output = getLargestNumberAmongMixedElements([3, 'word', 5, 'up', 3, 1]);\n    assert.deepEqual(output, 5);\n  });\n});\n"
              }
            },
            {
              "slug": "compute-sum-of-all-elements",
              "prefix": "11",
              "path": "topics/javascript/04-arrays/06-practice/11-compute-sum-of-all-elements",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "computeSumOfAllElements",
                  "body": "<p>Escribe una función llamada <code>computeSumOfAllElements</code>.</p>\n<p>Dado un array de números, <code>computeSumOfAllElements</code> devuelve la suma de todos\nlos elementos del array dado.</p>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const output = computeSumOfAllElements([1, 2, 3]);\nconsole.log(output); // --> 6\n</code></pre>"
                },
                "pt": {
                  "title": "computeSumOfAllElements",
                  "body": "<p>Escreva uma função chamada <code>computeSumOfAllElements</code>.</p>\n<p>Dado um <em>array</em> de números, <code>computeSumOfAllElements</code> devolve a soma de todos os\nelementos do <em>array</em> dado.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = computeSumOfAllElements([1, 2, 3]);\nconsole.log(output); // --> 6\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/computeSumOfAllElements.js": "const computeSumOfAllElements = (arr) => {\n  // your code here\n};\n\nmodule.exports = computeSumOfAllElements;\n",
                "/solution/computeSumOfAllElements.js": "const computeSumOfAllElements = (arr) => {\n  if (arr.length === 0) {\n    return 0;\n  }\n\n  let sum = 0;\n\n  for (let i = 0; i < arr.length; i += 1) {\n    if (typeof arr[i] === 'number') {\n      sum += arr[i];\n    }\n  }\n\n  return sum;\n};\n\nmodule.exports = computeSumOfAllElements;\n",
                "/test/computeSumOfAllElements.spec.js": "const { assert } = require('chai');\nconst computeSumOfAllElements = require('../solution/computeSumOfAllElements');\n\ndescribe('computeSumOfAllElements()', () => {\n  it('debería regresar 0, para  ([1, 2, 3])', () => {\n    const output = computeSumOfAllElements([1, 2, 3]);\n    assert.deepEqual(output, 6);\n  });\n\n  it('debería regresar 169, para ([10, 90, 69])', () => {\n    const output = computeSumOfAllElements([10, 90, 69]);\n\n    assert.deepEqual(output, 169);\n  });\n\n\n  it('debería regresar 28, para ([4, 5, 10, 9])', () => {\n    const output = computeSumOfAllElements([4, 5, 10, 9]);\n    assert.deepEqual(output, 28);\n  });\n});\n"
              }
            },
            {
              "slug": "compute-sum-between",
              "prefix": "12",
              "path": "topics/javascript/04-arrays/06-practice/12-compute-sum-between",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "computeSumBetween",
                  "body": "<p>Escribe una función llamada \"computeSumBetween\".</p>\n<p>Dado 2 enteros, \"computeSumBetween\" devuelve la suma entre los dos enteros\ndados, comenzando en num1 y excluyendo num2.</p>\n<p>Notas:</p>\n<ul>\n<li>La suma entre 1 y 4 es 1 + 2 + 3 = 6.</li>\n<li>Si num2 no es mayor que num1, debe devolver 0.</li>\n</ul>\n<pre><code class=\"language-js\">const output = computeSumBetween (2, 5);\nconsole.log (salida); // -> 9\n</code></pre>"
                },
                "pt": {
                  "title": "computeSumBetween",
                  "body": "<p>Escreva uma função chamada \"computeSumBetween\".</p>\n<p>Com 2 inteiros, por exemplo <code>num1</code> e <code>num2</code>, \"computeSumBetween\" devolve a soma\nde todos os números entre eles, começando em <code>num1</code> e excluindo <code>num2</code>.</p>\n<p>Notas:</p>\n<ul>\n<li>A soma entre 1 e 4 é 1 + 2 + 3 = 6.</li>\n<li>Se <code>num2</code> não for maior que <code>num1</code>, ela deve devolver 0.</li>\n</ul>\n<pre><code class=\"language-javascript\">const output = computeSumBetween (2, 5);\nconsole.log (salida); // -> 9\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/computeSumBetween.js": "const computeSumBetween = (num1, num2) => {\n  // your code here\n};\n\nmodule.exports = computeSumBetween;\n",
                "/solution/computeSumBetween.js": "const computeSumBetween = (num1, num2) => {\n  let sum = 0;\n\n  for (let i = num1; i < num2; i += 1) {\n    sum += i;\n  }\n\n  return sum;\n};\n\nmodule.exports = computeSumBetween;\n",
                "/test/computeSumBetween.spec.js": "const { assert } = require('chai');\nconst computeSumBetween = require('../solution/computeSumBetween');\n\ndescribe('computeSumBetween()', () => {\n  it(\"debería regresar [{a: 1, b: 2, c: true}, {a: 10, b: 20, c: false}], para [[['a', 1], ['b', 2], ['c', true]],[['a', 10], ['b', 20], ['c', false]]]\", () => {\n    const output = computeSumBetween(5, 5);\n\n    assert.deepEqual(output, 0);\n  });\n\n  it(\"debería regresar [{firstName: 'Joe', lastName: 'Blow', age: 42, role: 'clerk'}, {firstName: 'Mary', lastName: 'Jenkins', age: 36, role: 'manager'}], para [[['firstName', 'Joe'], ['lastName', 'Blow'], ['age', 42], ['role', 'clerk']],[['firstName', 'Mary'], ['lastName', 'Jenkins'], ['age', 36], ['role', 'manager']]]\", () => {\n    const output = computeSumBetween(2, 5);\n\n    assert.deepEqual(output, 9);\n  });\n});\n"
              }
            },
            {
              "slug": "get-longest-of-three-words",
              "prefix": "13",
              "path": "topics/javascript/04-arrays/06-practice/13-get-longest-of-three-words",
              "createdAt": "2024-02-08T16:56:33.610Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getLongestOfThreeWords",
                  "body": "<p>Escribe una función llamada <code>getLongestOfThreeWords</code>.</p>\n<p>Dado 3 palabras, <code>getLongestOfThreeWords</code> devuelve la más larga de tres\npalabras.</p>\n<p>Notas:</p>\n<ul>\n<li>Si hay un empate, debe devolver la primera palabra en el empate.</li>\n</ul>\n<pre><code class=\"language-js\">const output = getLongestOfThreeWords('estos', 'tres', 'palabras');\nconsole.log(output); // -> 'estos'\n</code></pre>"
                },
                "pt": {
                  "title": "getLongestOfThreeWords",
                  "body": "<p>Escreva uma função chamada <code>getLongestOfThreeWords</code>.</p>\n<p>Com 3 palavras, <code>getLongestOfThreeWords</code> devolve a mais longa das três palavras.</p>\n<p>Notas:</p>\n<ul>\n<li>Se houver um empate, você deve retornar a primeira palavra do empate.</li>\n</ul>\n<pre><code class=\"language-javascript\">const output = getLongestOfThreeWords('estas', 'três', 'palavras');\nconsole.log(output); // -> 'palabras'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getLongestOfThreeWords.js": "const getLongestOfThreeWords = (word1, word2, word3) => {\n  // your code here\n};\n\nmodule.exports = getLongestOfThreeWords;\n",
                "/solution/getLongestOfThreeWords.js": "const getLongestOfThreeWords = (word1, word2, word3) => {\n  let strLong = word1;\n\n  if (strLong.length < word2.length) {\n    strLong = word2;\n  }\n\n  if (strLong.length < word3.length) {\n    strLong = word3;\n  }\n\n  return strLong;\n};\n\nmodule.exports = getLongestOfThreeWords;\n",
                "/test/getLongestOfThreeWords.spec.js": "const { assert } = require('chai');\nconst getLongestOfThreeWords = require('../solution/getLongestOfThreeWords');\n\ndescribe('getLongestOfThreeWords()', () => {\n  it(\"debería regresar 'these', para 'these', 'three', 'words'\", () => {\n    const output = getLongestOfThreeWords('these', 'three', 'words');\n\n    assert.deepEqual(output, 'these');\n  });\n\n  it(\"debería regresar 'three', para 'a', 'two', 'three', 'four'\", () => {\n    const output = getLongestOfThreeWords('a', 'two', 'three', 'four');\n\n    assert.deepEqual(output, 'three');\n  });\n});\n"
              }
            },
            {
              "slug": "find-shortest-of-three-words",
              "prefix": "14",
              "path": "topics/javascript/04-arrays/06-practice/14-find-shortest-of-three-words",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "findShortestOfThreeWords",
                  "body": "<p>Escribe una función llamada <code>findShortestOfThreeWords</code>.</p>\n<p>Dado 3 cadenas, <code>findShortestOfThreeWords</code> devuelve el más corto de las cadenas\ndadas.</p>\n<p>Notas:</p>\n<ul>\n<li>Si hay empate, debe devolver la primera palabra en la lista de parámetros.</li>\n</ul>\n<pre><code class=\"language-js\">const = findShortestOfThreeWords('a', 'dos', 'tres');\nconsole.log(salida); // -> 'a'\n</code></pre>"
                },
                "pt": {
                  "title": "findShortestOfThreeWords",
                  "body": "<p>Escreva uma função chamada <code>findShortestOfThreeWords</code>.</p>\n<p>Com 3 <em>strings</em>, <code>findShortestOfThreeWords</code> devolve a <em>string</em> mais curta delas.</p>\n<p>Notas:</p>\n<ul>\n<li>Se houver um empate, você deve retornar a primeira palavra da lista de\nparâmetros.</li>\n</ul>\n<pre><code class=\"language-javascript\">const output = findShortestOfThreeWords('a', 'dos', 'tres');\nconsole.log(output); // -> 'a'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/findShortestOfThreeWords.js": "const findShortestOfThreeWords = (word1, word2, word3) => {\n  // your code here\n};\n\nmodule.exports = findShortestOfThreeWords;\n",
                "/solution/findShortestOfThreeWords.js": "const findShortestOfThreeWords = (word1, word2, word3) => {\n  let strShort = word1;\n\n  if (strShort.length > word2.length) {\n    strShort = word2;\n  }\n\n  if (strShort.length > word3.length) {\n    strShort = word3;\n  }\n\n  return strShort;\n};\n\nmodule.exports = findShortestOfThreeWords;\n",
                "/test/findShortestOfThreeWords.spec.js": "const { assert } = require('chai');\nconst findShortestOfThreeWords = require('../solution/findShortestOfThreeWords');\n\ndescribe('findShortestOfThreeWords()', () => {\n  it(\"debería regresar 'b', para 'yes', 'b', 'a', 'two', 'three', 'four'\", () => {\n    const output = findShortestOfThreeWords('yes', 'b', 'a', 'two', 'three', 'four');\n\n    assert.deepEqual(output, 'b');\n  });\n\n  it(\"debería regresar 'a', para 'a', 'two', 'three'\", () => {\n    const output = findShortestOfThreeWords('a', 'two', 'three');\n\n    assert.deepEqual(output, 'a');\n  });\n});\n"
              }
            },
            {
              "slug": "calculate-bill-total",
              "prefix": "15",
              "path": "topics/javascript/04-arrays/06-practice/15-calculate-bill-total",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "calculateBillTotal",
                  "body": "<p>Escribe una función llamada <code>calculateBillTotal</code>.</p>\n<p>Dado el pre impuesto y la cantidad antes de propina de una comida,\n<code>calculateBillTotal</code> devuelve la cantidad total debida después de impuestos y\npropina.</p>\n<p>Notas:</p>\n<ul>\n<li>Piensa que el impuesto de ventas es 9.5% y la propina es 15%.</li>\n<li>NO inclines el impuesto sobre las ventas, solo sobre la cantidad de propina.</li>\n</ul>\n<pre><code class=\"language-js\">const output = calculateBillTotal(20);\nconsole.log(output); // -> 24,9\n</code></pre>"
                },
                "pt": {
                  "title": "calculateBillTotal",
                  "body": "<p>Escreva uma função chamada <code>calculateBillTotal</code>.</p>\n<p>Dado o imposto e a quantia antes da gorjeta de uma refeição,\n<code>calculateBillTotal</code>devolve a quantia total devida depois de impostos e gorjeta.</p>\n<p>Notas:</p>\n<ul>\n<li>Suponha que o imposto sobre vendas seja de 9,5% e a gorjeta seja de 15%.</li>\n<li>NÃO aplique o imposto sobre a gorjeta, apenas sobre a venda.</li>\n</ul>\n<pre><code class=\"language-js\">const output = calculateBillTotal(20);\nconsole.log(output); // -> 24,9\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/calculateBillTotal.js": "const calculateBillTotal = (preTaxAndTipAmount) => {\n  // your code here\n};\n\nmodule.exports = calculateBillTotal;\n",
                "/solution/calculateBillTotal.js": "module.exports = amount => amount + (amount * 0.095) + (amount * 0.15);\n",
                "/test/calculateBillTotal.spec.js": "const { assert } = require('chai');\nconst calculateBillTotal = require('../solution/calculateBillTotal');\n\ndescribe('calculateBillTotal()', () => {\n  it('debería regresar 62.25, para 50', () => {\n    const preTaxAndTipAmount = 50;\n    const tax = preTaxAndTipAmount * (0.095);\n    const tip = preTaxAndTipAmount * (0.15);\n    const total = preTaxAndTipAmount + tax + tip;\n\n    assert.deepEqual(calculateBillTotal(preTaxAndTipAmount), total);\n  });\n\n  it('debería regresar 24.9, para 20', () => {\n    const preTaxAndTipAmount = 20;\n    const tax = preTaxAndTipAmount * (0.095);\n    const tip = preTaxAndTipAmount * (0.15);\n    const total = preTaxAndTipAmount + tax + tip;\n\n    assert.deepEqual(calculateBillTotal(preTaxAndTipAmount), total);\n  });\n\n  it('debería regresar 41.085, para 33', () => {\n    const preTaxAndTipAmount = 33;\n    const tax = preTaxAndTipAmount * (0.095);\n    const tip = preTaxAndTipAmount * (0.15);\n    const total = preTaxAndTipAmount + tax + tip;\n\n    assert.deepEqual(calculateBillTotal(preTaxAndTipAmount), total);\n  });\n});\n"
              }
            },
            {
              "slug": "convert-score-to-grade",
              "prefix": "16",
              "path": "topics/javascript/04-arrays/06-practice/16-convert-score-to-grade",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "convertScoreToGrade",
                  "body": "<p>Escribe una función llamada <code>convertScoreToGrade</code>.</p>\n<p>Dada una puntuación, <code>convertScoreToGrade</code> devuelve una cadena que representa el\ngrado de letra correspondiente a la puntuación dada.</p>\n<p>Notas:</p>\n<ul>\n<li>(100 - 90) -> 'A'</li>\n<li>(89 - 80) ->' B '</li>\n<li>(79 - 70) -> 'C'</li>\n<li>(69 - 60) -> 'D'</li>\n<li>(59 - 0) -> 'F'</li>\n<li>Si la puntuación dada es mayor que 100 o menor que 0, debe devolver\n'PUNTUACION INVALIDA'.</li>\n</ul>\n<pre><code class=\"language-js\">const output = convertScoreToGrade(91);\nconsole.log(output); // -> 'A'\n</code></pre>"
                },
                "pt": {
                  "title": "convertScoreToGrade",
                  "body": "<p>Escreva uma função chamada <code>convertScoreToGrade</code>.</p>\n<p>Dada uma pontuação numérica, <code>convertScoreToGrade</code> devolve uma letra\n(<em>string</em>) que representa essa pontuação.</p>\n<p>Notas:</p>\n<ul>\n<li>(100 - 90) -> 'A'</li>\n<li>(89 - 80) -> 'B'</li>\n<li>(79 - 70) -> 'C'</li>\n<li>(69 - 60) -> 'D'</li>\n<li>(59 - 0) -> 'F'</li>\n<li>Se a pontuação dada for maior que 100 ou menor que 0, você deve retornar\n'INVALID SCORE'.</li>\n</ul>\n<pre><code class=\"language-javascript\">const output = convertScoreToGrade(91);\nconsole.log(output); // -> 'A'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/convertScoreToGrade.js": "const convertScoreToGrade = (score) => {\n  // your code here\n};\n\nmodule.exports = convertScoreToGrade;\n",
                "/solution/convertScoreToGrade.js": "const convertScoreToGrade = (score) => {\n  let str;\n\n  switch (true) {\n    case ((score <= 100) && (score >= 90)):\n      str = 'A';\n      break;\n    case ((score <= 89) && (score >= 80)):\n      str = 'B';\n      break;\n    case ((score <= 79) && (score >= 70)):\n      str = 'C';\n      break;\n    case ((score <= 69) && (score >= 60)):\n      str = 'D';\n      break;\n    case ((score <= 59) && (score >= 0)):\n      str = 'F';\n      break;\n    default:\n      str = 'PUNTUACION INVALIDA';\n      break;\n  }\n  return str;\n};\n\nmodule.exports = convertScoreToGrade;\n",
                "/test/convertScoreToGrade.spec.js": "const { assert } = require('chai');\nconst convertScoreToGrade = require('../solution/convertScoreToGrade');\n\ndescribe('convertScoreToGrade()', () => {\n  it(\"debería regresar 'PUNTUACION INVALIDA', para 102\", () => {\n    const output = convertScoreToGrade(102);\n\n    assert.deepEqual(output, 'PUNTUACION INVALIDA');\n  });\n\n  it(\"debería regresar 'F', para 59\", () => {\n    const output = convertScoreToGrade(59);\n\n    assert.deepEqual(output, 'F');\n  });\n\n  it(\"debería regresar 'C', para 79\", () => {\n    const output = convertScoreToGrade(79);\n\n    assert.deepEqual(output, 'C');\n  });\n\n  it(\"debería regresar 'A', para 91\", () => {\n    const output = convertScoreToGrade(91);\n\n    assert.deepEqual(output, 'A');\n  });\n});\n"
              }
            }
          ]
        }
      ]
    },
    {
      "slug": "objects",
      "intl": {
        "es": {
          "title": "Objects (objetos)"
        },
        "pt": {
          "title": "Objects"
        }
      },
      "prefix": "05",
      "parts": [
        {
          "prefix": "01",
          "slug": "objects",
          "type": "read",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Objetos en JavaScript",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Aprender qué son <code>objects</code> y para qué sirven</li>\n<li>Aprender a crear, acceder y modificar la información de un <code>object</code></li>\n<li>Entender la diferencia entre un <code>array</code> y un <code>object</code></li>\n</ul>\n<hr>\n<p>El texto a continuación se basa en gran medida, con ciertos ajustes, en el\ncapítulo 4 de <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn\nHaverbeke, 2014. Traducción en <a href=\"http://hectorip.github.io/Eloquent-JavaScript-ES-online/chapters/01_values.html\">Español</a>\ndisponible gracias a <a href=\"https://github.com/hectorip\">hectorip</a>, y del capítulo 3\nde <a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for kids</a>,\nNick Morgan, 2015.</p>\n<hr>\n<h2>¿Qué es un object en JavaScript?</h2>\n<p>Los <code>objects</code> en JavaScript son muy similares a los <code>arrays</code>, pero con dos\nimportantes diferencias:</p>\n<ol>\n<li>\n<p>Como hemos visto, para acceder a información dentro de un <code>array</code> utilizamos\nun número correspondiente al <em>index</em>; es decir, la posición en la que se\nubica el valor. Los <code>objects</code>, por su parte, utilizan <code>strings</code> en lugar de\nnúmeros para acceder a los diferentes elementos. Estos <code>strings</code> se denominan\n<em>keys</em> (llaves) o propiedades, y los elementos a los que apuntan son llamados\n<em>valores</em>. Juntas, estas piezas de información se llaman <em>pares key-value</em>.</p>\n</li>\n<li>\n<p>Dado que en los <code>arrays</code> se requiere del <em>index</em> para acceder a la\ninformación, es importante mantener un determinado orden de los valores. En\nel caso de los <code>objects</code> los <em>pares key-value</em> de información pueden estar en\ncualquier orden.</p>\n</li>\n</ol>\n<p>Mientras que los <code>arrays</code> se utilizan sobre todo para representar listas de\ncosas múltiples, los objetos son a menudo usado para representar cosas simples\npero con <strong>múltiples características, o atributos</strong>. Por ejemplo, si quisiéramos\nagrupar los títulos de nuestras películas preferidas, utilizaríamos un <code>array</code>,\nasí:</p>\n<pre><code class=\"language-js\">const favoriteMovies = [\n  'The Big Fish',\n  'The Lord of the Rings',\n  'The Empire Strikes Back',\n  'The Artist',\n  'The Godfather',\n  'Back to the Future',\n];\n\n</code></pre>\n<p>¿Pero qué sucede si quisiéramos almacenar diferentes piezas de información sobre\nuna <strong>misma</strong> película? Aquí es donde entra la utilidad de un <code>object</code>.</p>\n<h2>Creando Objetos</h2>\n<p>Almacenemos diferentes piezas de información de la película <code>Back to the Future</code>\nen un solo lugar, por medio de un <code>object</code>:</p>\n<pre><code class=\"language-js\">let movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n  plot: 'Marty McFly, a 17-year-old high school student, ' +\n    'is accidentally sent 30 years into the past in a time-traveling DeLorean ' +\n    'invented by his close friend, the maverick scientist Doc Brown.',\n  oscar: 1,\n  tags: ['Adventure', 'Comedy', 'Sci-Fi'],\n};\n\n</code></pre>\n<p>En el ejemplo anterior hemos creado una variable llamada <code>movie</code> y le hemos\nasignado un objeto con 6 <em>pares key-value</em>. Para crear un objeto utilizamos las\nllaves <code>{}</code>, en lugar de los corchetes <code>[]</code> que usamos para crear <code>arrays</code>.\nDentro de las llaves colocamos los <em>pares key-value</em> separados por una coma.\nComo se muestra en el ejemplo, no necesitamos colocar una coma después del\núltimo par <em>key-value</em>.</p>\n<p>La sintaxis de cada par <em>key-value</em> es la siguiente:</p>\n<pre><code class=\"language-js\">{ key : value }\n</code></pre>\n<p>Cuando se crea un <code>object</code>, el <em>key</em> va antes de los dos puntos <code>:</code>, y el\n<em>value</em> va después. Los dos puntos actúan un poco como un signo igual (<code>=</code>); es\ndecir, los valores de la derecha se asignan a los nombres de la izquierda, al\nigual que cuando se crean variables.</p>\n<h3>Keys (strings) con o sin comillas</h3>\n<p>Como hemos visto, los <em>keys</em> son <code>strings</code>. Como muestra el ejemplo anterior, no\nes necesario colocar los <em>keys</em> entre comillas. Esto es porque Javascript sabe\nque los <em>keys</em> son <code>strings</code>. Sin embargo, es también válido colocar los <em>keys</em>\nentre comillas. Por ejemplo, el objeto a continuación también es válido:</p>\n<pre><code class=\"language-js\">const person = {\n  age: 18,\n  name: 'Michelle',\n  friends: ['Alexandra', 'Ana'],\n};\n\n</code></pre>\n<p>Si no colocamos las comillas, los <em>keys</em> deben seguir las mismas reglas de\nnombramiento de variables. Por ejemplo, no deben tener espacios. Pero si\ncolocamos los <em>keys</em> entre comillas, entonces sí podemos usar el nombre que\nqueramos. Por ejemplo, si queremos agregar un <em>key</em> del año en que salió la\npelícula ('year of release'), haríamos:</p>\n<pre><code class=\"language-js\">movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n  plot: 'Marty McFly, a 17-year-old high school student, ' +\n    'is accidentally sent 30 years into the past in a time-traveling DeLorean ' +\n    'invented by his close friend, the maverick scientist Doc Brown.',\n  oscar: 1,\n  tags: ['Adventure', 'Comedy', 'Sci-Fi'],\n};\n\n</code></pre>\n<p>Es importante resaltar que aunque los <em>keys</em> son siempre <code>strings</code>, los <em>values</em>\npueden ser cualquier valor JavaScript - inclusive pueden ser una variable que\ncontiene, o mejor dicho \"agarra\" (con sus tentáculos) un valor.</p>\n<h2>Accediendo información de un object</h2>\n<p>Podemos acceder a los valores de un <code>object</code> de dos maneras:</p>\n<ol>\n<li>La primera es usando los corchetes <code>[]</code>, tal como lo hacemos para los\n<code>arrays</code>. La única diferencia es que, en lugar de usar el <em>index</em> (un\n<code>number</code>), utilizamos el <em>key</em> (un <code>string</code>), siempre entre comillas.</li>\n<li>La segunda es usando el punto (<code>.</code>) con el nombre del <em>key</em> inmediatamente\ndespués, <strong>sin</strong> comillas. A esto se le llama <code>dot notation</code>. Al igual que en\nla declaración de los <em>keys</em>, si utilizamos <code>dot notation</code>, el <em>key</em> debe\nobligatoriamente cumplir con las reglas de nombres válidos (por ejemplo, no\ndeben contener espacios).</li>\n</ol>\n<p>Veamos algunos ejemplos para aclarar cuándo se usa una o la otra:</p>\n<pre><code class=\"language-js\">movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n};\n\nconsole.assert(movie['title'] === 'Back to the Future');\nconsole.assert(movie.title === movie['title']);\n\n</code></pre>\n<pre><code class=\"language-js\">let error = false;\ntry {\n  console.assert(movie[title] === 'Back to the Future');\n} catch (e) {\n  error = e.message;\n}\nconsole.assert(error === 'title is not defined');\n\n</code></pre>\n<pre><code class=\"language-js\">console.assert(movie.'title' === 'Back to the Future');\n// → Uncaught SyntaxError: Unexpected string\n</code></pre>\n<p>Analicemos los dos errores:</p>\n<ol>\n<li>Cuando utilizamos los corchetes <strong>sin</strong> comillas, JavaScript piensa que title\nes una variable y como en nuestro programa no existe una variable llamada\ntitle, se genera un error de referencia y JavaScript nos devuelve que title\nno está definida: <code>Uncaught ReferenceError: title is not defined</code></li>\n<li>Cuando utilizamos <code>dot notation</code> <strong>con</strong> comillas, JavaScript nos devuleve un\nerror de sintaxis, dado que <code>dot notation</code> no se debe utilizar con un\n<code>string</code>. Por eso nos devuelve: <code>Uncaught SyntaxError: Unexpected string</code>.</li>\n</ol>\n<p>¿Qué pasa cuando le pedimos un <em>key</em> que no tiene el <code>object</code>? JavaScript nos\ndevuelve <code>undefined</code>. Veamos un ejemplo:</p>\n<pre><code class=\"language-js\">movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n  plot: 'Marty McFly, a 17-year-old high school student, ' +\n    'is accidentally sent 30 years into the past in a time-traveling DeLorean ' +\n    'invented by his close friend, the maverick scientist Doc Brown.',\n  oscar: 1,\n  tags: ['Adventure', 'Comedy', 'Sci-Fi'],\n};\n\nconsole.assert(movie['producer'] === undefined);\n\n</code></pre>\n<p>¿Y cómo hacemos para obtener uno de los actores (stars) de la película? Para\nesto tenemos que entrar a la <em>key</em> <code>'stars'</code> del object <code>movie</code>, que nos va a\ndevolver un <code>array</code> y luego acceder a uno de los elementos del <code>array</code> a través\nde los corchetes <code>[]</code> y el <em>index</em>. Veamos un ejemplo:</p>\n<pre><code class=\"language-js\">movie = {\n  title: 'Back to the Future',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n};\n\nconsole.assert(movie.stars[0] === 'Michael J. Fox');\nconsole.assert(movie['stars'][1] === 'Christopher Lloyd');\nconsole.assert(movie.stars[2] === 'Lea Thompson');\n\n</code></pre>\n<p>Fíjate que hemos usado <code>movie.stars</code> y <code>movie['stars']</code> para hacer énfasis de\nque ambas maneras funcionan, como parte de la experiencia educativa. Pero\ncuidado, esto <strong>no</strong> es una buena práctica. Solo lo hemos hecho por dar el\nejemplo. Cuando escribamos programas, sean los retos de código, nuestros\nejercicios de clase o en proyectos personales, lo correcto es escoger una opción\ny ser consistente a lo largo del código. Recomendamos, en particular,\n<code>movie.stars</code> ya que es más corto y fácil de leer. Recuerda que lo mismo sucede\ncon las comillas de los <code>strings</code>, se pueden usar simples o dobles, pero de\nmanera consistente.</p>\n<h2>Definiendo o cambiando los elementos de un object</h2>\n<p>Al igual que con los <code>arrays</code>, podemos añadir o cambiar los elementos de un\n<code>object</code> utilizando los corchetes y <em>keys</em> o <code>dot notation</code>.</p>\n<p>Veamos un ejemplo que empieza con un <code>object</code> vacío y se le va añadiendo y\nmodificando elementos.</p>\n<pre><code class=\"language-js\">/* creando un object vacío */\nconst student = {};\n\n/* añadiendo elementos al object con corchetes y comillas */\nstudent['name'] = 'Carolina';\nstudent['points'] = 2500;\n\n/* añadiendo elementos al object con dot notation */\nstudent.courses = ['Intro a JS', 'Intro a UX'];\nstudent.isActive = true;\n\n/* resucitamos nuestra función comparadora */\n\nconst equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\nconsole.assert(equal(\n  student,\n  {\n    name: 'Carolina',\n    points: 2500,\n    courses: ['Intro a JS', 'Intro a UX'],\n    isActive: true,\n  },\n));\n\n/* actualizando los puntos */\nstudent['points'] = 3500;\n\nconsole.assert(equal(\n  student,\n  {\n    name: 'Carolina',\n    points: 3500,\n    courses: ['Intro a JS', 'Intro a UX'],\n    isActive: true,\n  },\n));\n\n</code></pre>\n<p>A continuación Michelle nos explica los conceptos principales de <code>objects</code> con\nun ejemplo:</p>\n<p><a href=\"https://www.youtube.com/watch?v=J6U0gDzWsUg\"><img src=\"https://img.youtube.com/vi/J6U0gDzWsUg/0.jpg\" alt=\"ejemplo de crear y modificar un object\"></a></p>"
            },
            "pt": {
              "title": "Objetos em JavaScript",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Aprender o que são <code>objects</code> e para que servem</li>\n<li>Aprender a criar, acessar e modificar as informações de um <code>object</code></li>\n<li>Entender a diferença entre um <code>array</code> e um<code>object</code></li>\n</ul>\n<hr>\n<p>O texto a seguir se baseia em grande medida, com alguns ajustes, ao capítulo 4\ndo <a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>,de Marijn Haverbeke,\n2014. Tradução em\n<a href=\"https://github.com/braziljs/eloquente-javascript/blob/master/chapters/01-valores-tipos-operadores.md\">Português</a>,\ne ao capítulo 3 do <a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for\nkids</a>,\nNick Morgan, 2015;</p>\n<hr>\n<h2>O que é um objeto em JavaScript?</h2>\n<p>Os <code>objetos</code> em JavaScript são muito similares ao <code>arrays</code>, mas com alguns\ndiferenciais:</p>\n<ol>\n<li>Como vimos, para acessar informações dentro de um <code>array</code>, nós usamos um\nnúmero correspondente ao <em>índice</em>; isto é, a posição em que o valor está\nlocalizado. Os <code>objects</code>, por outro lado, utilizam <code>strings</code>ao invés de\nnúmeros para acessar os diferentes elementos. Essas <code>strings</code> são chamadas de\nchaves (<em>keys</em>) ou propriedades, e os elementos para os quais eles apontam\nsão chamados de valores (<em>values</em>). Juntas, essas informações são\nchamadas de <em>pares de chave-valor</em>.</li>\n<li>Como nos <code>arrays</code> é necessário o <em>índice</em> para acessar informações, é\nimportante manter uma determinada ordem de seus valores. No caso dos <em>pares\nde chave-valor</em>, as informações podem estar em qualquer ordem.</li>\n</ol>\n<p>Enquanto os <code>arrays</code> são usados ​​principalmente para representar listas de\nvárias coisas, os objetos costumam ser usados ​​para representar elementos\nsimples, mas com <strong>várias características ou atributos</strong>. Por exemplo, se\nquiséssemos agrupar os títulos dos nossos filmes favoritos, usaríamos um <code>array</code>\nassim:</p>\n<pre><code class=\"language-javascript\">let favoriteMovies = [\n  'The Big Fish',\n  'The Lord of the Rings',\n  'The Empire Strikes Back',\n  'The Artist',\n  'The Godfather',\n  'Back to the Future'\n];\n</code></pre>\n<p>Mas o que aconteceria se quiséssemos armazenar diferentes informações sobre o\n<strong>mesmo</strong> filme? É aí que entra a utilidade de um <code>object</code>.</p>\n<h2>Criando Objetos</h2>\n<p>Nós armazenamos diferentes informações sobre o filme <code>De Volta para o Futuro</code> em\num só lugar, por meio de um<code>object</code>:</p>\n<pre><code class=\"language-javascript\">let movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n  plot: 'Marty McFly, a 17-year-old high school student, is accidentally sent 30 years into the past in a time-traveling DeLorean invented by his close friend, the maverick scientist Doc Brown.',\n  oscar: 1,\n  tags: ['Adventure', 'Comedy', 'Sci-Fi']\n};\n</code></pre>\n<p>No exemplo anterior, criamos uma variável chamada <code>movie</code>e atribuímos a ela um\nobjeto com seis <em>pares de chave-valor</em>. Para criar um objeto, usamos as chaves\n<code>{}</code>  ao invés dos colchetes <code>[]</code>  que usamos para criar <em>arrays</em>. Dentro das\nchaves, colocamos os <em>pares de chave-valor</em> separados por uma vírgula. Conforme\nmostrado no exemplo, não precisamos colocar uma vírgula após o último par de\nchave-valor.</p>\n<p>A sintaxe de cada par de <em>valores-chave</em> é a seguinte:</p>\n<pre><code class=\"language-javascript\">{chave: valor}\n</code></pre>\n<p>Quando criamos um <code>object</code>, a chave (<em>key</em>) é colocada antes dos dois pontos\n<code>:</code>, e o valor (<em>value</em>), depois. Os dois pontos agem um pouco como um sinal\nde igual ( <code>=</code>), isto é, os valores à direita são atribuídos aos nomes à\nesquerda, assim como quando variáveis ​​são criadas.</p>\n<h3>Chaves (<em>strings</em>) com ou sem aspas</h3>\n<p>Como vimos, as chaves são <code>strings</code>. Como mostra o exemplo anterior, não é\nnecessário colocar as chaves entre aspas. Isso ocorre porque o JavaScript sabe\nque as chaves são <code>strings</code>. No entanto, também é válido colocar as chaves entre\naspas. Por exemplo, o objeto abaixo também é válido:</p>\n<pre><code class=\"language-javascript\">const person = {\n  'age': 18,\n  'name': 'Michelle',\n  'friends': ['Alexandra','Ana']\n  };\n</code></pre>\n<p>Se não colocarmos as aspas, as chaves devem seguir as mesmas regras para nomear\nvariáveis. Por exemplo, elas não devem ter espaços. Mas se colocarmos as chaves\nentre aspas, podemos usar o nome que quisermos. Por exemplo, se quisermos\nadicionar uma chave do ano em que o filme saiu (\"ano de lançamento\"),\nfaríamos:</p>\n<pre><code class=\"language-javascript\">movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n  'year of release': 1984,\n  plot: 'Marty McFly, a 17-year-old high school student, is accidentally sent 30 years into the past in a time-traveling DeLorean invented by his close friend, the maverick scientist Doc Brown.',\n  oscar: 1,\n  tags: ['Adventure', 'Comedy', 'Sci-Fi'],\n  'other awards': ['best sound']\n  };\n</code></pre>\n<p>É importante notar que, embora as <em>keys</em> sejam sempre <code>strings</code>, os <em>values</em>\npodem ser qualquer valor JavaScript - eles podem até ser uma variável que\ncontenha, ou melhor, \"agarre\" (com seus tentáculos) um valor.</p>\n<h2>Acessando informações de um objeto</h2>\n<p>Podemos acessar os valores de um <code>object</code>de duas maneiras:</p>\n<ol>\n<li>O primeiro é usar os colchetes <code>[]</code>, assim como fazemos com <em>arrays</em>. A única\ndiferença é que, em vez de usar o <em>índice</em> (um <code>number</code>), usamos a chave\n(uma <code>string</code>), sempre entre aspas.</li>\n<li>O segundo é usando o ponto ( <code>.</code>) com o nome da chave imediatamente depois,\n<strong>sem</strong> aspas. Isso é chamado notação de ponto (<em>dot notation</em>). Como na\ndeclaração das chaves, se usarmos notação de ponto, a chave deve obedecer às\nregras de nomes válidos (por exemplo, elas não devem conter espaços).</li>\n</ol>\n<p>Vamos ver alguns exemplos para esclarecer quando um ou outro é usado:</p>\n<pre><code class=\"language-js\">movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n};\n\nconsole.assert(movie['title'] === 'Back to the Future');\nconsole.assert(movie.title === movie['title']);\n\n</code></pre>\n<pre><code class=\"language-js\">let error = false;\ntry {\n  console.assert(movie[title] === 'Back to the Future');\n} catch (e) {\n  error = e.message;\n}\nconsole.assert(error === 'title is not defined');\n\n</code></pre>\n<pre><code class=\"language-js\">console.assert(movie.'title' === 'Back to the Future');\n// → Uncaught SyntaxError: Unexpected string\n</code></pre>\n<p>Vamos analisar os dois erros:</p>\n<ol>\n<li>Quando usamos colchetes <strong>sem</strong> aspas, o JavaScript acha que o título é uma\nvariável e como não há uma variável chamada titulo no nosso programa, um erro\nde referência é gerado e o JavaScript avisa que esse título não está\ndefinido:<code>Uncaught ReferenceError: titulo is not defined</code></li>\n<li>Quando usado <code>dot notation</code> <strong>com</strong> aspas, o JavaScript devolve um erro de\nsintaxe, uma vez que <code>dot notation</code>não deve ser usada com <code>string</code>. Por isso,\ndevolve-nos: <code>Uncaught SyntaxError: Unexpected string</code>.</li>\n</ol>\n<p>O que acontece quando pedimos uma chave que o <code>object</code> não tem? JavaScript nos\nretorna <code>undefined</code>. Vamos ver um exemplo:</p>\n<pre><code class=\"language-js\">movie = {\n  title: 'Back to the Future',\n  director: 'Robert Zemeckis',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n  plot: 'Marty McFly, a 17-year-old high school student, ' +\n    'is accidentally sent 30 years into the past in a time-traveling DeLorean ' +\n    'invented by his close friend, the maverick scientist Doc Brown.',\n  oscar: 1,\n  tags: ['Adventure', 'Comedy', 'Sci-Fi'],\n};\n\nconsole.assert(movie['producer'] === undefined);\n</code></pre>\n<p>E como conseguimos um dos atores (<code>stars</code>) do filme? Para isso, temos que\nacessar a chave <code>'stars'</code> do objeto <code>movie</code>, que devolverá um <code>array</code>, para em\nseguida acessar um dos elementos através de colchetes <code>[]</code> e o índice. Vejamos\num exemplo:</p>\n<pre><code class=\"language-js\">movie = {\n  title: 'Back to the Future',\n  stars: ['Michael J. Fox', 'Christopher Lloyd', 'Lea Thompson'],\n};\n\nconsole.assert(movie.stars[0] === 'Michael J. Fox');\nconsole.assert(movie['stars'][1] === 'Christopher Lloyd');\nconsole.assert(movie.stars[2] === 'Lea Thompson');\n</code></pre>\n<p>Observe que usamos <code>movie.stars</code>e <code>movie['stars']</code>para enfatizar que as duas\nformas funcionam, por motivos didáticos. Mas tenha cuidado, isso <strong>não</strong> é uma\nboa prática. Nós só fizemos isso para dar o exemplo. Quando escrevemos\nprogramas, seja nos desafios de código, nossos exercícios de classe ou projetos\npessoais, a coisa certa a fazer é escolher uma opção e ser consistente em todo o\ncódigo. Recomendamos, em particular, <code>movie.stars</code>uma vez que é mais curto e\nmais fácil de ler. Lembre-se que a mesma coisa acontece com as aspas das\n<code>strings</code>: você pode usar simples ou dupla, mas de forma consistente.</p>\n<h2>Definindo ou alterando os elementos de um objeto</h2>\n<p>Assim como com <code>arrays</code>, podemos adicionar ou alterar os elementos de um\n<code>object</code>usando os colchetes e chaves ou notação de ponto.</p>\n<p>Vamos ver um exemplo que começa com um <code>object</code>vazio e segue adicionando e\nmodificando elementos.</p>\n<pre><code class=\"language-js\">/* criando um objeto vazio */\nconst student = {};\n\n/* adicionando elementos ao objeto */\nstudent['name'] = 'Carolina';\nstudent['points'] = 2500;\n\n/* adicionando elementos ao objeto */\nstudent.courses = ['Intro a JS', 'Intro a UX'];\nstudent.isActive = true;\n\n/* ressucitamos a nossa função comparadora */\n\nconst equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\nconsole.assert(equal(\n  student,\n  {\n    name: 'Carolina',\n    points: 2500,\n    courses: ['Intro a JS', 'Intro a UX'],\n    isActive: true,\n  },\n));\n\n/* atualiando os pontos */\nstudent['points'] = 3500;\n\nconsole.assert(equal(\n  student,\n  {\n    name: 'Carolina',\n    points: 3500,\n    courses: ['Intro a JS', 'Intro a UX'],\n    isActive: true,\n  },\n));\n\n</code></pre>\n<p>A seguir Daniel nos explica os conceitos principais de <code>objects</code> com um\nexemplo:</p>\n<p><a href=\"https://www.youtube.com/watch?v=_P1kAhq7W38\"><img src=\"https://img.youtube.com/vi/_P1kAhq7W38/0.jpg\" alt=\"Arrays\"></a></p>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "object-proto",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Object.prototype",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Familiarizarse con <code>Object.prototype</code></li>\n</ul>\n<h2><code>Object.prototype</code></h2>\n<p>Todos los objetos en JavaScript provienen de <code>Object</code>, es decir que todos\nheredan los métodos y propiedades de <code>Object.prototype</code>, es decir que alterando\neste objeto, puedes alterar el comportamiento de <strong>todos</strong> los objetos.</p>\n<p>Entérate de más: <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Object\">Object.prototype en MDN</a></p>"
            },
            "pt": {
              "title": "Object.prototype",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Conhecer o <code>Object.prototype</code></li>\n</ul>\n<h2><code>Object.prototype</code></h2>\n<p>Todos os objetos em JavaScript provém de <code>Object</code>, quer dizer que todos herdam\nos métodos e propriedades de <code>Object.prototype</code>, quer dizer que alterando este\nobjeto, se pode alterar o comportamento de <strong>todos</strong> os objetos.</p>\n<p>Para entender melhor leia: <a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object\">Object.prototype en\nMDN</a></p>"
            }
          }
        },
        {
          "prefix": "03",
          "slug": "arrays-and-objects",
          "type": "read",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Combinando arrays con objects",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Entender, por medio de un ejemplo, cómo combinar las dos estructuras de datos\naprendidas en esta unidad: <code>arrays</code> y <code>objects</code></li>\n</ul>\n<hr>\n<p>El texto a continuación se basa en gran medida, con ciertos ajustes, en 4 de\n<a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for kids</a>,\nNick Morgan, 2015.</p>\n<hr>\n<h2>Combinando arrays con objects</h2>\n<p>Ya hemos visto el caso de tener un <code>array</code> como valor de una propiedad\n<strong>dentro</strong> de un <code>object</code> (por ejemplo, un <code>array</code> de los protagonistas de un\n<code>object</code> movie), pero otra combinación bastante común para agrupar data es\ntener un <code>array</code> <strong>de</strong> <code>objects</code>.Veamos un ejemplo:</p>\n<p>Imaginemos que tenemos data de 3 estudiantes de Laboratoria y queremos\nestructurarla en nuestro programa. Para cada estudiante, tenemos cierta data: su\nnombre, sus puntos, los cursos que ha completado y si la estudiante ha\nabandonado o sigue cursando el programa.</p>\n<p>Una manera de estructurar esta data sería crear un <code>object</code> para cada estudiante\n, cada uno con su información, y luego un <code>array</code> que contenga los 3 <code>objects</code>.</p>\n<p>Veamos:</p>\n<pre><code class=\"language-js\">\nconst michelle = {\n  name: 'Michelle',\n  points: 2000,\n  isActive: true,\n  courses: ['Intro JS', 'JS avanzado', 'JS master']\n};\n\nconst alexandra = {\n  name: 'Alexandra',\n  points: 4100,\n  isActive: true,\n  courses: ['Intro JS', 'Intro UX', 'UX master']\n};\n\nconst andrea = {\n  name: 'Andrea',\n  points: 800,\n  isActive: false,\n  courses: ['Intro JS', 'JS avanzado']\n};\n\nconst students = [michelle, alexandra, andrea];\n\n</code></pre>\n<p>Fíjate que para cada propiedad de los <code>objects</code> hemos utilizado un tipo de dato\ndiferente:</p>\n<ul>\n<li>El nombre es un <code>string</code></li>\n<li>Los puntos son un <code>number</code></li>\n<li>Para saber si está estudiando o ha abandonado el programa escogimos un\n<code>boolean</code>, donde <code>true</code> significa que está activa (es decir, estudiando)</li>\n<li>Los cursos que ha completado son un <code>array</code>.</li>\n</ul>\n<p>Qué lindo cuando ya vemos todo lo que hemos aprendido aplicado en un solo bloque\nde código, ¿no? :) Lo mejor de todo es que con esta estrutura podemos acceder a\nla data de manera sencilla.</p>\n<p>A continuación Michelle te explica cómo utilizar <code>funciones</code>, <code>estructuras repetitivas</code> y <code>estructuras condicionales</code> para imprimir en la consola:</p>\n<ol>\n<li>Los nombres de todas las estudiantes <strong>activas</strong></li>\n<li>Los puntos totales de la clase</li>\n<li>Los nombres de las estudiantes que han llevado el curso de <strong>'JS avanzado'</strong></li>\n</ol>\n<p><a href=\"https://www.youtube.com/watch?v=M4vXJ62IIlI\"><img src=\"https://img.youtube.com/vi/M4vXJ62IIlI/0.jpg\" alt=\"video\"></a></p>"
            },
            "pt": {
              "title": "Vetores e Objetos",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Entender, por meio de um exemplo, como combinar as duas estruturas de dados\nestudadas nesta unidade: <code>array</code> e <code>object</code></li>\n</ul>\n<hr>\n<p>O texto abaixo é amplamente baseado, com alguns ajustes, em 4 de <a href=\"http://pepa.holla.cz/wp-content/uploads/2015/11/JavaScript-for-Kids.pdf\">JavaScript for\nKids</a> ,\nNick Morgan, 2015.</p>\n<hr>\n<h2>Combinando <em>arrays</em> com <em>objects</em></h2>\n<p>Já vimos o caso de ter um <code>array</code>como valor de uma propriedade <strong>dentro de</strong> um\n<code>object</code> (por exemplo, um <code>array</code> do elenco de um <code>object</code> <em>movie</em>), mas outra\ncombinação bem comum para agrupar dados é ter um <code>array</code> de <code>objects</code>. Vejamos\num exemplo:</p>\n<p>Imagine que temos dados de 3 estudantes da Laboratoria e queremos estruturá-los\nem nosso programa. Para cada aluna, temos os dados: seu nome, sua pontuação, os\ncursos que ela completou e se a aluna deixou ou continua com o programa.</p>\n<p>Uma maneira de estruturar esses dados seria criar um <code>object</code> para cada aluna,\ncada um com suas informações e, em seguida, um <code>array</code> que contenha todos os\ntrês <code>objects</code>.</p>\n<p>Vamos ver:</p>\n<pre><code class=\"language-js\">\nconst michelle = {\n  name: 'Michelle',\n  points: 2000,\n  isActive: true,\n  courses: ['Intro JS', 'JS avanzado', 'JS master']\n};\n\nconst alexandra = {\n  name: 'Alexandra',\n  points: 4100,\n  isActive: true,\n  courses: ['Intro JS', 'Intro UX', 'UX master']\n};\n\nconst andrea = {\n  name: 'Andrea',\n  points: 800,\n  isActive: false,\n  courses: ['Intro JS', 'JS avanzado']\n};\n\nconst students = [michelle, alexandra, andrea];\n\n</code></pre>\n<p>Observe que, para cada propriedade dos <code>objects</code>, usamos um tipo diferente de\ndados:</p>\n<ul>\n<li>O nome é um <code>string</code></li>\n<li>Os pontos são um <code>number</code></li>\n<li>Para descobrir se ela está estudando ou saiu do programa, escolhemos um\n<code>boolean</code>, onde <code>true</code> quer dizer que ela está ativa (ou seja, estudando)</li>\n<li>Os cursos que completou estão em um <code>array</code>.</li>\n</ul>\n<p>Que legal quando vemos tudo o que aprendemos aplicado em um único bloco de\ncódigo, né? :) A melhor parte é que, com essa estrutura, podemos acessar os\ndados de maneira simples.</p>\n<p>Em seguida, Daniel dirá como usar <code>funções</code>, <code>estruturas de repetição</code> e <code>estruturas condicionais</code> para imprimir no console:</p>\n<ol>\n<li>Os nomes de todas as alunas ativas</li>\n<li>O total de pontos da turma</li>\n<li>Os nomes das alunas que fizeram um determinado curso</li>\n</ol>\n<p><a href=\"https://www.youtube.com/watch?v=mU8FjHZcE0Y\"><img src=\"https://img.youtube.com/vi/mU8FjHZcE0Y/0.jpg\" alt=\"Vídeo sobre arrays com\nobjects\"></a></p>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "guided-exercises",
          "type": "practice",
          "duration": 40,
          "intl": {
            "es": {
              "title": "Ejercicios guiados",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender, a través de casos prácticos, cómo aplicar los conceptos de\n<code>funciones</code>, <code>arrays</code> y <code>objetos</code> para la resolución de problemas</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Al igual que hemos hecho antes, es hora de aplicar los conceptos aprendidos para\nresolver problemas.</p>\n<p>A continuación tendrás un problema que resolver. Intenta resolverlo primero por\ntu cuenta. Más abajo encontrarás la solución de Lourdes, otra instructora\nestrella de Laboratoria. Después de haberlo intentado, compara tus solución con\nla de Lourdes.</p>\n<h3>1. Array to Object</h3>\n<p>Escribe una función que tome un array 2D y devuelva un objeto con cada par de\nelementos en el <code>array</code> como un par <em>key-value</em>. Por ejemplo:</p>\n<ul>\n<li>Input</li>\n</ul>\n<pre><code class=\"language-js\">[['make', 'Ford'], ['model', 'Mustang'], ['year', 1964]]\n</code></pre>\n<ul>\n<li>Output</li>\n</ul>\n<pre><code class=\"language-js\">{\n  make : 'Ford',\n  model : 'Mustang',\n  year : 1964\n}\n</code></pre>\n<p>También escribe una función que haga lo contrario. Transforme los pares\n<em>key-value</em> de un <code>object</code> en un <code>array 2D</code>.</p>\n<h2>Solucionario</h2>\n<p>A continuación, Lourdes te explica cómo resolvió el ejercicio:</p>\n<h3>1. Array to Object</h3>\n<p><a href=\"https://www.youtube.com/watch?v=41ZJrHO6BsE\"><img src=\"https://img.youtube.com/vi/41ZJrHO6BsE/0.jpg\" alt=\"Solution ArrayToObject\"></a></p>"
            },
            "pt": {
              "title": "Exercícios Livres",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Entender, através de casos práticos, como aplicar os conceitos de <code>funções</code>,\n<code>arrays</code> e <code>objetos</code> para resolução de problemas</li>\n</ul>\n<hr>\n<h2>Enunciados</h2>\n<p>Como já fizemos antes, é hora de aplicar os conceitos aprendidos para resolver\nproblemas.</p>\n<p>Em seguida, você terá um problema para resolver. Tente resolvê-lo primeiro\nsozinha. Abaixo, você encontrará a solução de Lourdes, outra excelente\ninstrutora da Laboratoria. Depois de tentar resolvê-lo, compare sua solução com\na de Lourdes.</p>\n<h3>1. <em>Array</em> para <em>Object</em></h3>\n<p>Escreva uma função que receba um <em>array</em> 2D (vetor) e retorne um objeto com\ncada par de elementos do <code>array</code> como um par chave-valor . Por exemplo:</p>\n<ul>\n<li>Input</li>\n</ul>\n<pre><code class=\"language-js\">[['make', 'Ford'], ['model', 'Mustang'], ['year', 1964]]\n</code></pre>\n<ul>\n<li>Output</li>\n</ul>\n<pre><code class=\"language-js\">{\n  make : 'Ford',\n  model : 'Mustang',\n  year : 1964\n}\n</code></pre>\n<p>Escreva também uma função que faça o contrário. Transforme os pares de\n<em>key-value</em> de um <code>object</code> em um <code>array 2D</code>.</p>\n<h2>Resolução</h2>\n<p>A seguir, Daniel explica como ele resolveu o exercício:</p>\n<h3>1. <em>Array</em> para <em>Object</em></h3>\n<p><a href=\"https://www.youtube.com/watch?v=yQcNA41PMco\"><img src=\"https://img.youtube.com/vi/yQcNA41PMco/0.jpg\" alt=\"Solução\nArrayToObject\"></a></p>"
            }
          },
          "challenges": []
        },
        {
          "prefix": "06",
          "slug": "practice",
          "type": "practice",
          "duration": 180,
          "intl": {
            "es": {
              "title": "Retos de código",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>A continuación te presentamos una serie de retos que debes completar para\nponer tus conocimientos a prueba.</li>\n</ul>"
            },
            "pt": {
              "title": "Desafios de código",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>Aqui, apresentaremos uma série de desafios que você deve completar para testar\nseus conhecimentos.</li>\n</ul>"
            }
          },
          "challenges": [
            {
              "slug": "add-array-property",
              "prefix": "00",
              "path": "topics/javascript/05-objects/06-practice/00-add-array-property",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "addArrayProperty",
                  "body": "<p>Escribe una función llamada <code>addArrayProperty(obj, key, array)</code>.</p>\n<p>Dado un objeto, una llave y un array, <code>addArrayProperty</code> asigna una nueva\npropiedad sobre el objeto en la lave dada, con el array dado como valor.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const myObj = {};\nconst myStr = 'myProperty';\nconst myArray = [1, 3];\n\naddArrayProperty(myObj, myStr, myArray);\nconsole.log(myObj.myProperty); // => [1, 3]\n</code></pre>"
                },
                "pt": {
                  "title": "addArrayProperty",
                  "body": "<p>Escreva uma função chamada \"addArrayProperty(obj, key, array)\".</p>\n<p>Dado um objeto, uma chave (<em>key</em>) e um array, \"addArrayProperty\" define uma\nnova propriedade no objeto na chave fornecida, com seu valor definido no <em>array</em>\nespecificado.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const myObj = {};\nconst myStr = 'myProperty';\nconst myArray = [1 ,3 ];\n\naddArrayProperty(myObj, myStr, myArray);\nconsole.log(myObj.myProperty); // -> [1, 3]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/addArrayProperty.js": "const addArrayProperty = (obj, key, arr) => {\n  // your code here\n};\n\nmodule.exports = addArrayProperty;\n",
                "/solution/addArrayProperty.js": "const addArrayProperty = (obj, key, arr) => Object.assign(obj, { [key]: arr });\n\n\nmodule.exports = addArrayProperty;\n",
                "/test/addArrayProperty.spec.js": "const { assert } = require('chai');\nconst addArrayProperty = require('../solution/addArrayProperty');\n\ndescribe('addArrayProperty()', () => {\n  it('debería regresar [5, 8, 12], para addArrayProperty({}, \"key\", [5, 8, 12])', () => {\n    const myObj = {};\n    const myArray = [5, 8, 12];\n\n    addArrayProperty(myObj, 'key', myArray);\n    assert.deepEqual(myObj.key, myArray);\n  });\n});\n"
              }
            },
            {
              "slug": "object-properties-counter",
              "prefix": "01",
              "path": "topics/javascript/05-objects/06-practice/01-object-properties-counter",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Contador de propiedades",
                  "body": "<p>Dado un objeto como parámetro, contar la cantidad de propiedades que este\ncontiene y retornarlo.</p>\n<p>Ejemplo:</p>\n<pre><code class=\"language-javascript\">const output = objectPropertiesCounter({ 'name': 'John', 'lastname': 'Doe' });\n\nconsole.log(ouput); // => 2\n</code></pre>"
                },
                "pt": {
                  "title": "Contador de propriedades",
                  "body": "<p>Dado um objeto como parâmetro, contar a quantidade de propriedades que existem\nno objeto e retornar este valor.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = objectPropertiesCounter({ 'name': 'John', 'lastname': 'Doe' });\n\nconsole.log(ouput); // => 2\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/objectPropertiesCounter.js": "const objectPropertiesCounter = (obj) => {\n\n};\n\nmodule.exports = objectPropertiesCounter;\n",
                "/solution/objectPropertiesCounter.js": "const objectPropertiesCounter = obj => Object.keys(obj).length;\n\nmodule.exports = objectPropertiesCounter;\n",
                "/test/objectPropertiesCounter.spec.js": "const { assert } = require('chai');\nconst objectPropertiesCounter = require('../solution/objectPropertiesCounter');\n\ndescribe('objectPropertiesCounter()', () => {\n  it('debería regresar la cantidad de propiedades cuando es un objeto simple', () => {\n    const obj = { name: 'John', lastname: 'Doe' };\n    const output = objectPropertiesCounter(obj);\n    assert.deepEqual(output, 2);\n  });\n\n  it('debería regresar la cantidad de propiedades cuando es un objeto con propiedades anidadas', () => {\n    const obj = {\n      name: 'Laboratoria',\n      cohorts: {\n        SCL: ['2017-1', '2017-2'],\n        CDMX: ['2017-1', '2017-2'],\n      },\n    };\n    const output = objectPropertiesCounter(obj);\n    assert.deepEqual(output, 2);\n  });\n\n  it('debería regresar 0 cuando es un objeto vacío', () => {\n    const obj = {};\n    const output = objectPropertiesCounter(obj);\n    assert.deepEqual(output, 0);\n  });\n});\n"
              }
            },
            {
              "slug": "remove-string-values-longer-than",
              "prefix": "02",
              "path": "topics/javascript/05-objects/06-practice/02-remove-string-values-longer-than",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "removeStringValuesLongerThan",
                  "body": "<p>Escribe una función llamada <code>removeStringValuesLongerThan</code>.</p>\n<p>Dado un número y un objeto, <code>removeStringValuesLongerThan</code> elimina cualquier\npropiedad en el objeto dado cuyos valores son cadenas de texto más largas que el\nnúmero dado.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const obj = {\n  name: 'Montana',\n  age: 20,\n  location: 'Texas',\n};\n\nremoveStringValuesLongerThan(6, obj);\nconsole.log(obj); // => { age: 20, location: 'Texas' }\n</code></pre>"
                },
                "pt": {
                  "title": "removeStringValuesLongerThan",
                  "body": "<p>Escreva uma função chamada \"removeStringValuesLongerThan\".</p>\n<p>Dado um número e um objeto, \"removeStringValuesLongerThan\" remove qualquer\npropriedade no objeto dado cujos valores são strings maiores que o número\nfornecido.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const obj = {\n  name: 'Montana',\n  age: 20,\n  location: 'Texas',\n};\nremoveStringValuesLongerThan(6, obj);\nconsole.log(obj); // { age: 20, location: 'Texas' }\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/removeStringValuesLongerThan.js": "const removeStringValuesLongerThan = (num, obj) => {\n  // your code here\n};\n\nmodule.exports = removeStringValuesLongerThan;\n",
                "/solution/removeStringValuesLongerThan.js": "const removeStringValuesLongerThan = (num, obj) => Object.keys(obj).reduce(\n  (memo, key) => (\n    (obj[key].length > num)\n      ? memo\n      : { ...memo, [key]: obj[key] }\n  ),\n  {},\n);\n\n\nmodule.exports = removeStringValuesLongerThan;\n",
                "/test/removeStringValuesLongerThan.spec.js": "const { assert } = require('chai');\nconst removeStringValuesLongerThan = require('../solution/removeStringValuesLongerThan');\n\ndescribe('removeStringValuesLongerThan()', () => {\n  it('Prueba: key-value mayor a 1', () => {\n    const obj = {\n      name: 'Montana',\n      age: 20,\n      location: 'Texas',\n    };\n\n    const num = 1;\n    const hasil = {\n      age: 20,\n    };\n    assert.deepEqual(removeStringValuesLongerThan(num, obj), hasil);\n  });\n\n  it('Prueba: key-value mayor a 6', () => {\n    const obj = {\n      name: 'Montana',\n      age: 20,\n      location: 'Texas',\n    };\n\n    const num = 6;\n    const hasil = {\n      age: 20,\n      location: 'Texas',\n    };\n    assert.deepEqual(removeStringValuesLongerThan(num, obj), hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "get-element-of-array-property",
              "prefix": "03",
              "path": "topics/javascript/05-objects/06-practice/03-get-element-of-array-property",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getElementOfArrayProperty",
                  "body": "<p>Escriba una función llamada <code>getElementOfArrayProperty</code>.</p>\n<p>Dado un objeto, una llave (nombre de una propiedad) y un índice numérico,\n<code>getElementOfArrayProperty</code> devuelve el valor del elemento en el índice dado del\narreglo localizado dentro del objeto dado en la llave dada.</p>\n<p>Notas:</p>\n<ul>\n<li>Si el arreglo está vacío, debería devolver <code>undefined</code>.</li>\n<li>Si el índice dado está fuera de rango del arreglo ubicado en la llave dada,\ndebería devolver <code>undefined</code>.</li>\n<li>Si la propiedad en la llave dada no es un arreglo, debería devolver\n<code>undefined</code>.</li>\n<li>Si no hay ninguna propiedad en la llave, debería devolverse <code>undefined</code>.</li>\n</ul>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const obj = {\n key: ['Jamil', 'Albrey'],\n};\n\nconst output = getElementOfArrayProperty(obj, 'key', 0);\nconsole.log(output); // => 'Jamil'\n</code></pre>"
                },
                "pt": {
                  "title": "getElementOfArrayProperty",
                  "body": "<p>Escreva uma função chamada <code>getElementOfArrayProperty</code>.</p>\n<p>Dado um objeto, uma chave e um índice numérico, <code>getElementOfArrayProperty</code>\nretorna o valor do elemento no índice fornecido do array localizado dentro do\nobjeto informado na chave especificada.</p>\n<p>Notas:</p>\n<ul>\n<li>Se a matriz estiver vazia, ela deve devolver <code>undefined</code>.</li>\n<li>Se o índice fornecido estiver fora do intervalo da matriz localizada na chave\nespecificada, ela deverá devolver <code>undefined</code>.</li>\n<li>Se a propriedade na chave fornecida não for uma matriz, ela deve devolver\n<code>undefined</code>.</li>\n<li>Se não houver propriedade na chave, ela deve devolver <code>undefined</code>.</li>\n</ul>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const obj = {\n key: ['Jamil', 'Albrey'],\n};\n\nconst output = getElementOfArrayProperty(obj, 'key', 0);\nconsole.log(output); // --> 'Jamil'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getElementOfArrayProperty.js": "const getElementOfArrayProperty = (obj, key, index) => {\n  // your code here\n};\n\nmodule.exports = getElementOfArrayProperty;\n",
                "/solution/getElementOfArrayProperty.js": "const getElementOfArrayProperty = (obj, key, index) => {\n  if (!obj[key]) {\n    return undefined;\n  }\n\n  if (!Array.isArray(obj[key])) {\n    return undefined;\n  }\n\n  if (!obj[key][index]) {\n    return undefined;\n  }\n\n  return obj[key][index];\n};\n\nmodule.exports = getElementOfArrayProperty;\n",
                "/test/getElementOfArrayProperty.spec.js": "const { assert } = require('chai');\nconst getElementOfArrayProperty = require('../solution/getElementOfArrayProperty');\n\ndescribe('getElementOfArrayProperty()', () => {\n  it(\"debería regresar undefined, para ({yey: [1, 3, 5, 7]}, 'key', 1)\", () => {\n    const obj = {\n      yey: [1, 3, 5, 7],\n    };\n    const output = getElementOfArrayProperty(obj, 'key', 1);\n\n    assert.deepEqual(output, undefined);\n  });\n\n  it(\"debería regresar undefined, para  ({key: 'eyoooo'}, 'key', 1)\", () => {\n    const obj = {\n      key: 'eyoooo',\n    };\n    const output = getElementOfArrayProperty(obj, 'key', 0);\n    assert.deepEqual(output, undefined);\n  });\n\n\n  it(\"debería regresar undefined, para ({key: ['Kemal', 'Mahmud']}, 'key', 2)\", () => {\n    const obj = {\n      key: ['Kemal', 'Mahmud'],\n    };\n    const output = getElementOfArrayProperty(obj, 'key', 2);\n    assert.deepEqual(output, undefined);\n  });\n\n  it(\"debería regresar 3, para ({key: [1, 2, 3, 4, 5]}, 'key', 2)\", () => {\n    const obj = {\n      key: [1, 2, 3, 4, 5],\n    };\n    const output = getElementOfArrayProperty(obj, 'key', 2);\n    assert.deepEqual(output, 3);\n  });\n});\n"
              }
            },
            {
              "slug": "greet-customer",
              "prefix": "04",
              "path": "topics/javascript/05-objects/06-practice/04-greet-customer",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "greetCustomer",
                  "body": "<p>Escribe una función llamada <code>greetCustomer</code>.</p>\n<p>Dando un nombre, <code>greetCustomer</code> devuelve un saludo basado en cuántas veces ese\ncliente ha visitado el restaurante.  Consulte el objeto <code>customerData</code>.</p>\n<p>El saludo debe ser diferente, dependiendo del nombre de la reservación.</p>\n<p>Caso 1 - Cliente desconocido (el nombre no está presente en los datos de\ncliente):</p>\n<pre><code class=\"language-js\">console.log(greetCustomer('Terrance'));\n// => 'Welcome! Is this your first time?'\n</code></pre>\n<p>Caso 2 - Cliente que ha visitado sólo una vez (el valor de las visitas es 1)</p>\n<pre><code class=\"language-js\">console.log(greetCustomer('Joe'));\n// => 'Welcome back, Joe! We're glad you liked us the first time!'\n</code></pre>\n<p>Caso 3 - Repetir cliente: (valor de' visitas' es mayor que 1)</p>\n<pre><code class=\"language-js\">console.log(greetCustomer('Carol'));\n// --> 'Welcome back, Carol! So glad to see you again!'\n</code></pre>\n<p>Notas:</p>\n<ul>\n<li>Tu función no debe alterar el objeto <code>customerData</code> para actualizar el número\nde visitas.</li>\n<li>No codificar los datos exactos de la muestra. Esto es una mala idea:</li>\n</ul>\n<pre><code class=\"language-js\">if (firstName === 'Joe') {\n  // do something\n}\n</code></pre>"
                },
                "pt": {
                  "title": "greetCustomer",
                  "body": "<p>Escreva uma função chamada <code>greetCustomer</code>.</p>\n<p>Dado um nome, <code>greetCustomer</code> retorna uma saudação com base em quantas vezes o\ncliente visitou o restaurante. Consulte o objeto <code>customerData</code>.</p>\n<p>A saudação deve ser diferente, dependendo do nome da reserva.</p>\n<p>Caso 1 - Cliente desconhecido (o nome não está presente nos dados do cliente):</p>\n<pre><code class=\"language-javascript\">console.log(greetCustomer('Terrance')); // --> 'Welcome! Is this your first time?'\n</code></pre>\n<p>Caso 2 - Cliente que visitou apenas uma vez (o valor das visitas é 1)</p>\n<pre><code class=\"language-javascript\">console.log(greetCustomer('Joe')); // --> 'Welcome back, Joe! We're glad you liked us the first time!'\n</code></pre>\n<p>Caso 3 - Cliente repetido: (o valor de 'visitas' é maior que 1)</p>\n<pre><code class=\"language-javascript\">console.log(greetCustomer('Carol')); // --> 'Welcome back, Carol! So glad to see you again!'\n</code></pre>\n<p>Notas:</p>\n<ul>\n<li>Sua função não deve alterar o objeto <code>customerData</code> para atualizar o número de\nvisitas.</li>\n<li>Não codifique os dados exatos da amostra. Esta é uma má ideia:</li>\n</ul>\n<pre><code class=\"language-javascript\">if (firstName === 'Joe') {\n  // do something\n}\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/greetCustomer.js": "const customerData = {\n  Joe: {\n    visits: 1,\n  },\n  Carol: {\n    visits: 2,\n  },\n  Howard: {\n    visits: 3,\n  },\n  Carrie: {\n    visits: 4,\n  },\n};\n\nconst greetCustomer = (firstName) => {\n  const greeting = '';\n\n  // your code here\n\n  return greeting;\n};\n\nmodule.exports = greetCustomer;\n",
                "/solution/greetCustomer.js": "const customerData = {\n  Joe: {\n    visits: 1,\n  },\n  Carol: {\n    visits: 2,\n  },\n  Howard: {\n    visits: 3,\n  },\n  Carrie: {\n    visits: 4,\n  },\n};\n\nconst greetCustomer = (firstName) => {\n  if (!customerData[firstName]) {\n    return 'Welcome! Is this your first time?';\n  }\n\n  if (customerData[firstName].visits === 1) {\n    return `Welcome back, ${firstName}! We're glad you liked us the first time!`;\n  }\n\n  if (customerData[firstName].visits > 1) {\n    return `Welcome back, ${firstName}! So glad to see you again!`;\n  }\n\n  return undefined;\n};\n\nmodule.exports = greetCustomer;\n",
                "/test/greetCustomer.spec.js": "const { assert } = require('chai');\nconst greetCustomer = require('../solution/greetCustomer');\n\ndescribe('greetCustomer()', () => {\n  it(\"debería regresar 'Welcome back, Howard! So glad to see you again!', para  ('Howard')\", () => {\n    const pair = greetCustomer('Howard');\n    const hasil = 'Welcome back, Howard! So glad to see you again!';\n\n    assert.deepEqual(pair, hasil);\n  });\n\n  it(\"debería regresar'Welcome back, Joe! We're glad you liked us the first time!', para ('Joe')\", () => {\n    const pair = greetCustomer('Joe');\n    const hasil = \"Welcome back, Joe! We're glad you liked us the first time!\";\n\n    assert.deepEqual(pair, hasil);\n  });\n\n\n  it(\"debería regresar  'Welcome! Is this your first time?', para  ('Kemal')\", () => {\n    const pair = greetCustomer('Kemal');\n    const hasil = 'Welcome! Is this your first time?';\n\n    assert.deepEqual(pair, hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "transform-first-and-last",
              "prefix": "05",
              "path": "topics/javascript/05-objects/06-practice/05-transform-first-and-last",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "transformFirstAndLast",
                  "body": "<p>Escribe una función <code>transformFirstAndLast</code> que toma un array y devuelve un\nobjeto con:</p>\n<ol>\n<li>el primer elemento del array como la llave del objeto, y</li>\n<li>el último elemento del array como valor de esa llave.</li>\n</ol>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">['Queen', 'Elizabeth', 'Of Hearts', 'Beyonce']\n</code></pre>\n<p>Valor de retorno de la función (salida):</p>\n<pre><code class=\"language-js\">{\n  Queen: 'Beyonce'\n}\n</code></pre>\n<p>No cambies el array de entrada. Piensa que todos los elementos del array de\nentrada serán del tipo <code>string</code>.</p>\n<p>Ten en cuenta que el array de entrada puede tener un número variable de\nelementos. Tu código debería acomodarse de manera flexible.</p>\n<p>Ejemplo, debe manejar la entrada como:</p>\n<pre><code class=\"language-js\">['Kevin', 'Bacon', 'Amor', 'Hart', 'Costner', 'Spacey']\n</code></pre>\n<p>Valor de retorno de la función (salida):</p>\n<pre><code class=\"language-js\">{\n  Kevin: \"Spacey\"\n}\n</code></pre>"
                },
                "pt": {
                  "title": "transformFirstAndLast",
                  "body": "<p>Escreva uma função 'transformFirstAndLast' que receba um vetor e retorne um\nobjeto com:</p>\n<ol>\n<li>o primeiro elemento do vetor como a chave do objeto e</li>\n<li>o último elemento do vetor como o valor dessa chave.</li>\n</ol>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">['Queen', 'Elizabeth', 'Of Hearts', 'Beyonce']\n</code></pre>\n<p>Valor de retorno da função (saída):</p>\n<pre><code class=\"language-javascript\">{\n  Queen: 'Beyonce'\n}\n</code></pre>\n<p>Não altere o vetor de entrada. Suponha que todos os elementos do <em>array</em> de\nentrada sejam do tipo <code>string</code>.</p>\n<p>Observe que o vetor de entrada pode ter um número variável de elementos. Seu\ncódigo deve responder de forma flexível.</p>\n<p>Por exemplo, você deve manipular entradas como:</p>\n<pre><code class=\"language-javascript\">['Kevin', 'Bacon', 'Amor', 'Hart', 'Costner', 'Spacey']\n</code></pre>\n<p>Saída da função:</p>\n<pre><code class=\"language-javascript\">{\n  Kevin: \"Spacey\"\n}\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/transformFirstAndLast.js": "const transformFirstAndLast = (array) => {\n  // your code here\n};\n\nmodule.exports = transformFirstAndLast;\n",
                "/solution/transformFirstAndLast.js": "const transformFirstAndLast = (array) => {\n  const obj = {};\n\n  obj[array[0]] = array[array.length - 1];\n\n  return obj;\n};\n\nmodule.exports = transformFirstAndLast;\n",
                "/test/transformFirstAndLast.spec.js": "const { assert } = require('chai');\nconst transformFirstAndLast = require('../solution/transformFirstAndLast');\n\ndescribe('transformFirstAndLast()', () => {\n  it(\"debería regresar { King : 'Freddie' }, para ['King', 'Kemal', 'Freddie']\", () => {\n    assert.deepEqual(transformFirstAndLast(['King', 'Kemal', 'Freddie']), { King: 'Freddie' });\n  });\n\n  it(\"debería regresar { Queen : 'Beyonce' }, para ['Queen', 'Elizabeth', 'Of Hearts', 'Beyonce']\", () => {\n    assert.deepEqual(transformFirstAndLast(['Queen', 'Elizabeth', 'Of Hearts', 'Beyonce']), { Queen: 'Beyonce' });\n  });\n});\n"
              }
            },
            {
              "slug": "get-all-keys",
              "prefix": "06",
              "path": "topics/javascript/05-objects/06-practice/06-get-all-keys",
              "createdAt": "2024-02-08T16:56:33.611Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getAllKeys",
                  "body": "<p>Escribe una función llamada <code>getAllKeys</code> que devuelve un array de todas las\nllaves del objeto de entrada.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">{\n  name: 'Sam',\n  age: 25,\n  hasPets: true\n}\n</code></pre>\n<p>Valor de retorno de la función (salida):</p>\n<pre><code class=\"language-js\">['name', 'age', 'hasPets']\n</code></pre>\n<p>Ten en cuenta que tu función debe ser capaz de manejar cualquier objeto pasado\nen ella.</p>\n<p>Por ejemplo, también debe manejar una entrada como:</p>\n<pre><code class=\"language-js\">{\n  a: 'a',\n  number: 11,\n  hungry: true,\n  grammyWins: 1\n}\n</code></pre>\n<p>Valor de retorno de la función (salida):</p>\n<pre><code class=\"language-js\">['a', 'number', 'hungry', 'grammyWins']\n</code></pre>"
                },
                "pt": {
                  "title": "getAllKeys",
                  "body": "<p>Escreva uma função chamada \"getAllKeys\" que retorna um <em>array</em> com todas as\nchaves do objeto de entrada.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">{\n  name: 'Sam',\n  age: 25,\n  hasPets: true\n}\n</code></pre>\n<p>Valor de retorno da função (saída):</p>\n<pre><code class=\"language-javascript\">['name', 'age', 'hasPets']\n</code></pre>\n<p>Tenha em mente que sua função deve ser capaz de manipular qualquer objeto\npassado nela.</p>\n<p>Por exemplo, você também deve tratar uma entrada como a seguinte:</p>\n<pre><code class=\"language-javascript\">{\n  a: 'a',\n  number: 11,\n  hungry: true,\n  grammyWins: 1\n}\n</code></pre>\n<p>Saída da função:</p>\n<pre><code class=\"language-javascript\">['a', 'number', 'hungry', 'grammyWins']\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getAllKeys.js": "const getAllKeys = (obj) => {\n  // your code here\n};\n\nmodule.exports = getAllKeys;\n",
                "/solution/getAllKeys.js": "const getAllKeys = obj => Object.keys(obj);\n\nmodule.exports = getAllKeys;\n",
                "/test/getAllKeys.spec.js": "const { assert } = require('chai');\nconst getAllKeys = require('../solution/getAllKeys');\n\ndescribe('getAllKeys()', () => {\n  it(\"debería regresar ['tes', 'ini', 'berhasil'], para { tes : 'tes', ini : 'apa',berhasil : 10 }\", () => {\n    const hasil = ['tes', 'ini', 'berhasil'];\n    const obj = {\n      tes: 'tes',\n      ini: 'apa',\n      berhasil: 10,\n    };\n\n    assert.deepEqual(getAllKeys(obj), hasil);\n  });\n\n  it(\"debería regresar ['a', 'number', 'hungry', 'grammyWins'], para { a: 'a', number: 11, hungry: true, grammyWins: 1 }\", () => {\n    const hasil = ['a', 'number', 'hungry', 'grammyWins'];\n    const obj = {\n      a: 'a',\n      number: 11,\n      hungry: true,\n      grammyWins: 1,\n    };\n\n    assert.deepEqual(getAllKeys(obj), hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "from-list-to-object",
              "prefix": "07",
              "path": "topics/javascript/05-objects/06-practice/07-from-list-to-object",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "fromListToObject",
                  "body": "<p>Escribe una función <code>fromListToObject</code> que toma un array de matrices, y\ndevuelve un objeto con cada par de elementos en la array como un par\nllave-valor.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">[['make', 'Ford'], ['model', 'Mustang'], ['year', 1964]]\n</code></pre>\n<p>Valor de retorno de la función (salida):</p>\n<pre><code class=\"language-js\">{\n  make: 'Ford'\n  model: 'Mustang',\n  year: 1964\n}\n</code></pre>\n<p>No cambies la cadena de entrada. Piensa que todos los elementos del array serán\ndel tipo <code>string</code>.</p>\n<p>Ten en cuenta que la entrada puede tener un número diferente de elementos que\nla muestra dada. Por ejemplo, si la entrada tenía 6 valores en lugar de 4, tu\ncódigo debería adaptarse de manera flexible.</p>"
                },
                "pt": {
                  "title": "fromListToObject",
                  "body": "<p>Escreva uma função <code>fromListToObject</code> que receba um <em>array</em> de <em>arrays</em> e\nretorne um objeto com cada par de elementos do <em>array</em> como um par de\nchave-valor.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">[['make', 'Ford'], ['model', 'Mustang'], ['year', 1964]]\n</code></pre>\n<p>Saída função:</p>\n<pre><code class=\"language-javascript\">{\n  make: 'Ford'\n  model: 'Mustang',\n  year: 1964\n}\n</code></pre>\n<p>Não mude a string de entrada. Suponha que todos os elementos do <em>array</em> sejam do\ntipo <code>string</code>.</p>\n<p>Observe que a entrada pode ter um número diferente de elementos do que a amostra\nfornecida. Por exemplo, se a entrada tiver 6 valores em vez de 4, seu código\ndeve se adaptar de maneira flexível.</p>"
                }
              },
              "files": {
                "/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/fromListToObject.js": "const fromListToObject = (array) => {\n  // your code here\n};\n\nmodule.exports = fromListToObject;\n",
                "/solution/fromListToObject.js": "const fromListToObject = (array) => {\n  const obj = {};\n\n  for (let i = 0; i < array.length; i += 1) {\n    /* eslint-disable-next-line prefer-destructuring */\n    obj[array[i][0]] = array[i][1];\n  }\n\n  return obj;\n};\n\nmodule.exports = fromListToObject;\n",
                "/test/fromListToObject.spec.js": "const { assert } = require('chai');\nconst fromListToObject = require('../solution/fromListToObject');\n\ndescribe('fromListToObject()', () => {\n  it(\"debería regresar { make: 'Ford', model: 'Mustang', year: 1964, quality: 'eeehhh' }, para [['make', 'Ford'], ['model', 'Mustang'], ['year', 1964], ['quality', 'eeehhh']]\", () => {\n    const array = [['make', 'Ford'], ['model', 'Mustang'], ['year', 1964], ['quality', 'eeehhh']];\n    const hasil = {\n      make: 'Ford',\n      model: 'Mustang',\n      year: 1964,\n      quality: 'eeehhh',\n    };\n    assert.deepEqual(fromListToObject(array), hasil);\n  });\n\n  it(\"debería regresar { make : 'Ford', model : 'Mustang', year : 1964 }, para [['make', 'Ford'], ['model', 'Mustang'], ['year', 1964]]\", () => {\n    const array = [['make', 'Ford'], ['model', 'Mustang'], ['year', 1964]];\n    const hasil = {\n      make: 'Ford',\n      model: 'Mustang',\n      year: 1964,\n    };\n    assert.deepEqual(fromListToObject(array), hasil);\n  });\n\n  it(\"debería regresar { Kemal: 'Mahmud' }, para [['Kemal', 'Mahmud']]\", () => {\n    const array = [['Kemal', 'Mahmud']];\n    const hasil = {\n      Kemal: 'Mahmud',\n    };\n    assert.deepEqual(fromListToObject(array), hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "list-all-values",
              "prefix": "08",
              "path": "topics/javascript/05-objects/06-practice/08-list-all-values",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "listAllValues",
                  "body": "<p>Escribe una función llamada <code>listAllValues</code> que devuelve un array de todos los\nvalores del objeto de entrada.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">{\n  name: 'Krysten',\n  age: 33,\n  hasPets: false\n}\n</code></pre>\n<p>Valor de retorno de la función (salida):</p>\n<pre><code class=\"language-js\">['Krysten', 33, false]\n</code></pre>\n<p>Ten en cuenta que la entrada puede tener un número diferente de llaves y\nvalores que la muestra dada.</p>\n<p>Por ejemplo, también debe manejar una entrada como:</p>\n<pre><code class=\"language-js\">{\n  a: 'a',\n  number: 11,\n  hungry: true,\n  grammyWins: 1\n}\n</code></pre>\n<p>Valor de retorno de la función (salida):</p>\n<pre><code class=\"language-js\">['a', 11, true, 1]\n</code></pre>"
                },
                "pt": {
                  "title": "listAllValues",
                  "body": "<p>Escreva uma função chamada <code>listAllValues</code> que retorna um <em>array</em> de todos os\nvalores do objeto de entrada.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">{\n  name: 'Krysten'\n  age: 33,\n  hasPets: false\n}\n</code></pre>\n<p>Valor devolvido pela função (saída):</p>\n<pre><code class=\"language-javascript\">['Krysten', 33, false]\n</code></pre>\n<p>Observe que a entrada pode ter um número diferente de chaves e valores que a\namostra fornecida. Por exemplo, você também deve manipular uma entrada como:</p>\n<pre><code class=\"language-javascript\">{\n  a: 'a',\n  number: 11 ,\n  hungry: true,\n  grammyWins: 1\n}\n</code></pre>\n<p>Valor devolvido pela função (saída):</p>\n<pre><code class=\"language-javascript\">['a', 11, true, 1]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/listAllValues.js": "const listAllValues = (obj) => {\n  // your code here\n};\n\nmodule.exports = listAllValues;\n",
                "/solution/listAllValues.js": "const listAllValues = (obj) => {\n  const arr = [];\n  const arrKeys = Object.keys(obj);\n\n  for (let i = 0; i < arrKeys.length; i += 1) {\n    arr.push(obj[arrKeys[i]]);\n  }\n\n  return arr;\n};\n\nmodule.exports = listAllValues;\n",
                "/test/listAllValues.spec.js": "const { assert } = require('chai');\nconst listAllValues = require('../solution/listAllValues');\n\ndescribe('listAllValues()', () => {\n  it('debería regresar [1, 2, 3, false, false], para { a: 1, b: 2, c: 3, d: false, e: false }', () => {\n    const obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: false,\n      e: false,\n    };\n    const hasil = [1, 2, 3, false, false];\n\n    assert.deepEqual(listAllValues(obj), hasil);\n  });\n\n  it(\"debería regresar ['a', 11, true, 1], para { a: 'a', number: 11, hungry: true, grammyWins: 1 }\", () => {\n    const obj = {\n      a: 'a',\n      number: 11,\n      hungry: true,\n      grammyWins: 1,\n    };\n    const hasil = ['a', 11, true, 1];\n\n    assert.deepEqual(listAllValues(obj), hasil);\n  });\n\n  it(\"debería regresar ['yes'], para { tez: 'yes' }\", () => {\n    const obj = {\n      tez: 'yes',\n    };\n    const hasil = ['yes'];\n\n    assert.deepEqual(listAllValues(obj), hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "transform-employee-data",
              "prefix": "09",
              "path": "topics/javascript/05-objects/06-practice/09-transform-employee-data",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "transformEmployeeData",
                  "body": "<p>Escribe una función llamada <code>transformEmployeeData</code> que transforma algunos\ndatos de los empleados de un formato a otro.</p>\n<p>El argumento se verá así:</p>\n<pre><code class=\"language-js\">[\n  [\n    ['firstName', 'Joe'], ['lastName', 'Blow'], ['age', 42], ['role', 'clerk']\n  ],\n  [\n    ['firstName', 'Mary'], ['lastName', 'Jenkins'], ['age', 36], ['role', 'manager']\n  ]\n]\n</code></pre>\n<p>Dado que la entrada, el valor devuelto debe verse como esto:</p>\n<pre><code class=\"language-js\">[\n    {firstName: 'Joe', lastName: 'Blow', age: 42, role: 'clerk'},\n    {firstName: 'Mary', lastName: 'Jenkins', age: 36, role: 'manager'}\n]\n</code></pre>\n<p>Tenga en cuenta que la entrada puede tener un número diferente de filas o llaves\ndiferentes de la muestra dada.</p>\n<p>Por ejemplo, digamos que el departamento de recursos humanos agrega un campo\n\"tshirtSize\" a cada registro de empleado. Su código debería acomodarse de manera\nflexible.</p>"
                },
                "pt": {
                  "title": "transformEmployeeData",
                  "body": "<p>Escreva uma função chamada \"transformEmployeeData\" que transforma alguns dados\nde funcionários de um formato para outro.</p>\n<p>O argumento ficará assim:</p>\n<pre><code class=\"language-javascript\">[\n  [\n    ['firstName', 'Joe'], ['lastName', 'Blow'], ['age', 42], ['role', 'clerk']\n  ]\n  [\n    ['firstName', 'Mary'], ['lastName', 'Jenkins'], ['age', 36 ], ['role', 'manager']\n  ]\n]\n</code></pre>\n<p>Dada a entrada, o valor de retorno deve ficar assim:</p>\n<pre><code class=\"language-javascript\">[\n    {firstName: 'Joe', lastName: 'Blow', age: 42, role: 'clerk'},\n    {firstName: 'Mary', lastName: 'Jenkins', age: 36, role: 'manager'}\n]\n</code></pre>\n<p>Observe que a entrada pode ter um número diferente de linhas ou chaves\ndiferentes da amostra fornecida.</p>\n<p>Por exemplo, digamos que o departamento de recursos humanos inclua um campo\n\"tshirtSize\" em cada registro de funcionário. Seu código deve ser flexível para\ntratar essa situação.</p>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/transformEmployeeData.js": "const transformEmployeeData = (array) => {\n  // your code here\n};\n\nmodule.exports = transformEmployeeData;\n",
                "/solution/transformEmployeeData.js": "const transformEmployeeData = (array) => {\n  const arrayMain = [];\n\n  for (let i = 0; i < array.length; i += 1) {\n    const arr = array[i];\n    const obj = {};\n\n    for (let j = 0; j < arr.length; j += 1) {\n      /* eslint-disable-next-line prefer-destructuring */\n      obj[arr[j][0]] = arr[j][1];\n    }\n\n    arrayMain.push(obj);\n  }\n\n  return arrayMain;\n};\n\nmodule.exports = transformEmployeeData;\n",
                "/test/transformEmployeeData.spec.js": "const { assert } = require('chai');\nconst transformEmployeeData = require('../solution/transformEmployeeData');\n\ndescribe('transformEmployeeData()', () => {\n  it(\"debería regresar [{a: 1, b: 2, c: true}, {a: 10, b: 20, c: false}], para [[['a', 1], ['b', 2], ['c', true]],[['a', 10], ['b', 20], ['c', false]]]\", () => {\n    const array = [\n      [\n        ['a', 1], ['b', 2], ['c', true],\n      ],\n      [\n        ['a', 10], ['b', 20], ['c', false],\n      ],\n    ];\n    const hasil = [\n      { a: 1, b: 2, c: true },\n      { a: 10, b: 20, c: false },\n    ];\n    assert.deepEqual(transformEmployeeData(array), hasil);\n  });\n\n  it(\"debería regresar [{firstName: 'Joe', lastName: 'Blow', age: 42, role: 'clerk'}, {firstName: 'Mary', lastName: 'Jenkins', age: 36, role: 'manager'}], para [[['firstName', 'Joe'], ['lastName', 'Blow'], ['age', 42], ['role', 'clerk']],[['firstName', 'Mary'], ['lastName', 'Jenkins'], ['age', 36], ['role', 'manager']]]\", () => {\n    const array = [\n      [\n        ['firstName', 'Joe'], ['lastName', 'Blow'], ['age', 42], ['role', 'clerk'],\n      ],\n      [\n        ['firstName', 'Mary'], ['lastName', 'Jenkins'], ['age', 36], ['role', 'manager'],\n      ],\n    ];\n    const hasil = [\n      {\n        firstName: 'Joe', lastName: 'Blow', age: 42, role: 'clerk',\n      },\n      {\n        firstName: 'Mary', lastName: 'Jenkins', age: 36, role: 'manager',\n      },\n    ];\n    assert.deepEqual(transformEmployeeData(array), hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "convert-object-to-list",
              "prefix": "10",
              "path": "topics/javascript/05-objects/06-practice/10-convert-object-to-list",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "convertObjectToList",
                  "body": "<p>Escribe una función llamada <code>convertObjectToList</code> que convierte un objeto\nliteral en una array de arrays, como esto:</p>\n<p>Argumento:</p>\n<pre><code class=\"language-js\">{\n  name: 'Holly',\n  edad: 35,\n  papel: 'productor'\n}\n</code></pre>\n<p>Valor de retorno:</p>\n<pre><code class=\"language-js\">[['name', 'Holly'], ['edad', 35], ['rol', 'productor']]\n</code></pre>\n<p>Ten en cuenta que tu función debe ser capaz de manejar cualquier objeto como\neste, no sólo la muestra exacta proporcionada anteriormente.</p>\n<p>Por ejemplo, también debería ser capaz de manejar esto, o cualquier otro objeto\nque contiene pares llave-valor simples.</p>\n<pre><code class=\"language-js\">{\n  species: 'canino',\n  name: 'Bowser',\n  weight: 45\n}\n</code></pre>"
                },
                "pt": {
                  "title": "convertObjectToList",
                  "body": "<p>Escreva uma função chamada \"convertObjectToList\" que converte um objeto literal\nem um vetor de vetores, como neste exemplo:</p>\n<p>Argumento:</p>\n<pre><code class=\"language-javascript\">{\n  name: 'Holly',\n  edad: 35,\n  papel: 'productor'\n}\n</code></pre>\n<p>Valor devolvido:</p>\n<pre><code class=\"language-javascript\">[['name', 'Holly'], ['edad', 35], ['rol', 'productor']]\n</code></pre>\n<p>Tenha em mente que sua função deve ser capaz de manipular qualquer objeto como\neste, não apenas a amostra exata fornecida acima.</p>\n<p>Por exemplo, você também deve conseguir manipular a entrada abaixo ou qualquer\noutro objeto que contenha pares de chave-valor simples.</p>\n<pre><code class=\"language-javascript\">{\n  species: 'canino',\n  name: 'Bowser',\n  weight: 45\n}\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/convertObjectToList.js": "const convertObjectToList = (obj) => {\n  // your code here\n};\n\nmodule.exports = convertObjectToList;\n",
                "/solution/convertObjectToList.js": "const convertObjectToList = (obj) => {\n  const arr = [];\n  const arrKeys = Object.keys(obj);\n\n  for (let i = 0; i < arrKeys.length; i += 1) {\n    arr.push([arrKeys[i], obj[arrKeys[i]]]);\n  }\n\n  return arr;\n};\n\nmodule.exports = convertObjectToList;\n",
                "/test/convertObjectToList.spec.js": "const { assert } = require('chai');\nconst convertObjectToList = require('../solution/convertObjectToList');\n\ndescribe('convertObjectToList()', () => {\n  it(\"debería regresar [['a', 1], ['b', 'c'], ['d', true], ['e', 10]], para { a: 1, b: 'c', d: true, e: 10 }\", () => {\n    const obj = {\n      a: 1,\n      b: 'c',\n      d: true,\n      e: 10,\n    };\n    const hasil = [['a', 1], ['b', 'c'], ['d', true], ['e', 10]];\n\n    assert.deepEqual(convertObjectToList(obj), hasil);\n  });\n\n  it(\"debería regresar [['name', 'Holly'], ['age', 35], ['role', 'producer']], para { name: 'Holly', age: 35, role: 'producer' }\", () => {\n    const obj = {\n      name: 'Holly',\n      age: 35,\n      role: 'producer',\n    };\n    const hasil = [['name', 'Holly'], ['age', 35], ['role', 'producer']];\n\n    assert.deepEqual(convertObjectToList(obj), hasil);\n  });\n});\n"
              }
            },
            {
              "slug": "get-sum-of-all-elements-at-property",
              "prefix": "11",
              "path": "topics/javascript/05-objects/06-practice/11-get-sum-of-all-elements-at-property",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getSumOfAllElementsAtProperty",
                  "body": "<p>Escribe una función llamada <code>getSumOfAllElementsAtProperty</code>.</p>\n<p>Dado un objeto y una key, <code>getSumOfAllElementsAtProperty</code> devuelve la suma de\ntodos los elementos del array.</p>\n<p>Notas:</p>\n<ul>\n<li>Si el array está vacío, debe devolver <code>0</code>.</li>\n<li>Si la propiedad en la key dada no es un array, debe devolver <code>0</code>.</li>\n<li>Si no hay ninguna propiedad en la key dada, debe devolver <code>0</code>.</li>\n</ul>\n<pre><code class=\"language-js\">const obj = {\n  key: [4, 1, 8],\n};\n\nconst output = getSumOfAllElementsAtProperty(obj, 'key');\nconsole.log(output); // => 13\n</code></pre>"
                },
                "pt": {
                  "title": "getSumOfAllElementsAtProperty",
                  "body": "<p>Escreva uma função chamada \"getSumOfAllElementsAtProperty\".</p>\n<p>Dado um objeto e uma chave, \"getSumOfAllElementsAtProperty\" devolve a soma de\ntodos os elementos da matriz.</p>\n<p>Notas:</p>\n<ul>\n<li>Se o <em>array</em> estiver vazio, ela deve devolver 0.</li>\n<li>Se a propriedade na chave fornecida não for um <em>array</em>, ela deverá devolver 0.</li>\n<li>Se não houver nenhuma propriedade na chave fornecida, ela deverá devolver 0.</li>\n</ul>\n<pre><code class=\"language-javascript\">const obj = {\n  key: [4, 1, 8],\n};\n\nconst output = getSumOfAllElementsAtProperty(obj, 'key');\nconsole.log(output); // -> 13\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getSumOfAllElementsAtProperty.js": "const getSumOfAllElementsAtProperty = (obj, key) => {\n  // your code here\n};\n\nmodule.exports = getSumOfAllElementsAtProperty;\n",
                "/solution/getSumOfAllElementsAtProperty.js": "const getSumOfAllElementsAtProperty = (obj, key) => {\n  let sum = 0;\n  const array = obj[key];\n\n  if (Array.isArray(array) && (array.length > 0)) {\n    [sum] = array;\n\n    for (let i = 1; i < array.length; i += 1) { sum += array[i]; }\n  }\n\n  return sum;\n};\n\nmodule.exports = getSumOfAllElementsAtProperty;\n",
                "/test/getSumOfAllElementsAtProperty.spec.js": "const { assert } = require('chai');\nconst getSumOfAllElementsAtProperty = require('../solution/getSumOfAllElementsAtProperty');\n\ndescribe('getSumOfAllElementsAtProperty()', () => {\n  it(\"debería regresar 0, para { key: Badddlyyyy } y 'key'\", () => {\n    const obj = {\n      koy: 'Badddlyyyy',\n    };\n    const output = getSumOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 0);\n  });\n\n  it(\"debería regresar 0, para { koy: 'nope' } y 'key'\", () => {\n    const obj = {\n      koy: [],\n    };\n    const output = getSumOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 0);\n  });\n\n  it(\"debería regresar 0, para { key: [] } y 'key'\", () => {\n    const obj = {\n      key: [],\n    };\n    const output = getSumOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 0);\n  });\n\n  it(\"debería regresar 35, para { key: [10, 11, 15, -1] } y 'key'\", () => {\n    const obj = {\n      key: [10, 11, 15, -1],\n    };\n    const output = getSumOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 35);\n  });\n\n  it(\"debería regresar 13, para { key: [4, 1, 8] } y 'key'\", () => {\n    const obj = {\n      key: [4, 1, 8],\n    };\n    const output = getSumOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 13);\n  });\n});\n"
              }
            },
            {
              "slug": "get-product-of-all-elements-at-property",
              "prefix": "12",
              "path": "topics/javascript/05-objects/06-practice/12-get-product-of-all-elements-at-property",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getProductOfAllElementsAtProperty",
                  "body": "<p>Escribe una función llamada <code>getProductOfAllElementsAtProperty</code>.</p>\n<p>Dado un objeto y una key, <code>getProductOfAllElementsAtProperty</code> devuelve el\nproducto de todos los elementos del array.</p>\n<p>Notas:</p>\n<ul>\n<li>Si el array está vacío, debe devolver 0.</li>\n<li>Si la propiedad en la key dada no es un array, debe devolver 0.</li>\n<li>Si no hay ninguna propiedad en la key dada, debe devolver 0.</li>\n</ul>\n<pre><code class=\"language-js\">const obj = {\n  key: [1, 2, 3, 4],\n};\n\nconst output = getProductOfAllElementsAtProperty(obj, 'key');\nconsole.log(output); // => 24\n</code></pre>"
                },
                "pt": {
                  "title": "getProductOfAllElementsAtProperty",
                  "body": "<p>Escreva uma função chamada <code>getProductOfAllElementsAtProperty</code>.</p>\n<p>Dado um objeto e uma chave, <code>getProductOfAllElementsAtProperty</code> retorna o\nproduto de todos os elementos do <em>array</em>.</p>\n<p>Notas:</p>\n<ul>\n<li>Se o <em>array</em> estiver vazio, ela deve devolver 0.</li>\n<li>Se a propriedade na chave fornecida não for um <em>array</em>, ela deverá devolver 0.</li>\n<li>Se não houver nenhuma propriedade na chave fornecida, ela deverá devolver 0.</li>\n</ul>\n<pre><code class=\"language-javascript\">const obj = {\n  key: [1, 2, 3, 4],\n};\n\nconst output = getProductOfAllElementsAtProperty(obj, 'key');\nconsole.log(output); // -> 24\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/getProductOfAllElementsAtProperty.js": "const getProductOfAllElementsAtProperty = (obj, key) => {\n  // your code here\n};\n\nmodule.exports = getProductOfAllElementsAtProperty;\n",
                "/solution/getProductOfAllElementsAtProperty.js": "const getProductOfAllElementsAtProperty = (obj, key) => {\n  let product = 0;\n  const array = obj[key];\n\n  if (Array.isArray(array) && (array.length > 0)) {\n    [product] = array;\n\n    for (let i = 1; i < array.length; i += 1) { product *= array[i]; }\n  }\n\n  return product;\n};\n\nmodule.exports = getProductOfAllElementsAtProperty;\n",
                "/test/getProductOfAllElementsAtProperty.spec.js": "const { assert } = require('chai');\nconst getProductOfAllElementsAtProperty = require('../solution/getProductOfAllElementsAtProperty');\n\ndescribe('getProductOfAllElementsAtProperty()', () => {\n  it(\"debería regresar 0, para { koy: [1, 2, 3] } y 'key'\", () => {\n    const obj = {\n      koy: [1, 2, 3],\n    };\n    const output = getProductOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 0);\n  });\n\n  it(\"debería regresar 0, para { key: 'nope' } y 'key'\", () => {\n    const obj = {\n      key: 'nope',\n    };\n    const output = getProductOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 0);\n  });\n\n  it(\"debería regresar 0, para { key: [] } y 'key'\", () => {\n    const obj = {\n      key: [],\n    };\n    const output = getProductOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 0);\n  });\n\n  it(\"debería regresar 24, para { key: [1, 2, 3, 4] } y 'key'\", () => {\n    const obj = {\n      key: [1, 2, 3, 4],\n    };\n    const output = getProductOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 24);\n  });\n\n  it(\"debería regresar 60, para { key: [1, 5, 6, 2, 1] } y 'key'\", () => {\n    const obj = {\n      key: [1, 5, 6, 2, 1],\n    };\n    const output = getProductOfAllElementsAtProperty(obj, 'key');\n\n    assert.deepEqual(output, 60);\n  });\n});\n"
              }
            },
            {
              "slug": "add-object-property",
              "prefix": "13",
              "path": "topics/javascript/05-objects/06-practice/13-add-object-property",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "addObjectProperty",
                  "body": "<p>Escribe una función llamada <code>addObjectProperty</code>.</p>\n<p>Dado dos objetos y una llave, <code>addObjectProperty</code> establece una nueva propiedad\nen el primer objeto en la llave dada. El valor de esta nueva propiedad es el\nsegundo objeto completo.</p>\n<pre><code class=\"language-js\">const person1 = {\n  name: 'Joe Blow',\n  role: 'schlub',\n};\n\nconst person2 = {\n  name: 'Mr. Burns',\n  role: 'supervisor',\n};\n\naddObjectProperty(person1, 'manager', person2);\nconsole.log(person1.manager); // => { name: 'Mr. Burns', role: 'supervisor' }\n</code></pre>"
                },
                "pt": {
                  "title": "addObjectProperty",
                  "body": "<p>Escreva uma função chamada \"addObjectProperty\".</p>\n<p>Dados dois objetos e uma chave, \"addObjectProperty\" define uma nova propriedade\nno primeiro objeto na chave determinada. O valor dessa nova propriedade é o\nsegundo objeto completo.</p>\n<pre><code class=\"language-javascript\">const person1 = {\n  name: 'Joe Blow',\n  role: 'schlub',\n};\n\nconst person2 = {\n  name: 'Mr. Burns',\n  role: 'supervisor',\n};\n\naddObjectProperty(person1, 'manager', person2);\nconsole.log(person1.manager);\n// --> { name: 'Mr. Burns', role: 'supervisor' }\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/addObjectProperty.js": "const addObjectProperty = (obj1, key, obj2) => {\n  // your code here\n};\n\nmodule.exports = addObjectProperty;\n",
                "/solution/addObjectProperty.js": "const addObjectProperty = (obj1, key, obj2) => Object.assign(obj1, { [key]: obj2 });\n\nmodule.exports = addObjectProperty;\n",
                "/test/addObjectProperty.spec.js": "const { assert } = require('chai');\nconst addObjectProperty = require('../solution/addObjectProperty');\n\ndescribe('addObjectProperty(obj1, key, obj2)', () => {\n  it('debería asignar obj2 en obj1[key]', () => {\n    const person1 = { name: 'Medina', role: 'Euuuuhhh' };\n    const person2 = { name: 'Fadel', role: 'Aaaahhhh' };\n\n    addObjectProperty(person1, 'bawahan', person2);\n\n    assert.deepEqual(person1.bawahan, person2);\n  });\n});\n"
              }
            },
            {
              "slug": "add-full-name-property",
              "prefix": "14",
              "path": "topics/javascript/05-objects/06-practice/14-add-full-name-property",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "addFullNameProperty",
                  "body": "<p>Escribe una función llamada <code>addFullNameProperty(person)</code>.</p>\n<p>Dado un objeto <code>person</code> con una propiedad <code>firstName</code> y una propiedad\n<code>lastName</code>, <code>addFullNameProperty(person)</code> debe retornar un nuevo objeto con las\nmismas propiedades que el objeto recibido pero con una propiedad más <code>fullName</code>,\ncuyo valor debe ser una cadena (string) con el nombre y el apellido separados\npor un espacio.</p>\n<pre><code class=\"language-js\">const person = {\n  firstName: 'Jade',\n  lastName: 'Smith',\n};\n\nconst personWithFullName = addFullNameProperty(person);\n\nconsole.log(personWithFullName.fullName); // => 'Jade Smith'\nconsole.log(personWithFullName.firstName); // => 'Jade'\nconsole.log(personWithFullName.lastName); // => 'Smith'\n</code></pre>"
                },
                "pt": {
                  "title": "addFullNameProperty",
                  "body": "<p>Escreva uma função chamada \"addFullNameProperty\".</p>\n<p>Dado um objeto que tem uma propriedade <code>firstName</code> e uma propriedade <code>lastName</code>,\n<code>addFullNameProperty(person)</code> retorna um novo objeto com as mesmas propriedades\nque o objeto recebido, mas com mais uma propriedade <code>fullName</code> cujo valor é\numa string com o nome e sobrenome separados por um espaço.</p>\n<pre><code class=\"language-javascript\">const person = {\n  firstName: 'Jade',\n  lastName: 'Smith',\n};\n\nconst personWithFullName = addFullNameProperty(person);\n\nconsole.log(personWithFullName.fullName); // => 'Jade Smith'\nconsole.log(personWithFullName.firstName); // => 'Jade'\nconsole.log(personWithFullName.lastName); // => 'Smith'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/addFullNameProperty.js": "const addFullNameProperty = (obj) => {\n  // your code here\n};\n\nmodule.exports = addFullNameProperty;\n",
                "/solution/addFullNameProperty.js": "const addFullNameProperty = obj => ({\n  ...obj,\n  fullName: `${obj.firstName} ${obj.lastName}`,\n});\n\nmodule.exports = addFullNameProperty;\n",
                "/test/addFullNameProperty.spec.js": "const { assert } = require('chai');\nconst addFullNameProperty = require('../solution/addFullNameProperty');\n\ndescribe('addFullNameProperty()', () => {\n  it('debería regresar \"Kemal Mahmud\", para {firstName: \"Kemal\", lastName: \"Mahmud\"}', () => {\n    const person = { firstName: 'Kemal', lastName: 'Mahmud' };\n    const personWithFullName = addFullNameProperty(person);\n\n    assert.ok(personWithFullName !== person);\n    assert.equal(personWithFullName.firstName, 'Kemal');\n    assert.equal(personWithFullName.lastName, 'Mahmud');\n    assert.equal(personWithFullName.fullName, 'Kemal Mahmud');\n  });\n});\n"
              }
            }
          ]
        }
      ]
    },
    {
      "slug": "strings",
      "intl": {
        "es": {
          "title": "Strings (cadenas de caracteres)"
        },
        "pt": {
          "title": "Strings"
        }
      },
      "prefix": "06",
      "parts": [
        {
          "prefix": "01",
          "slug": "strings",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Strings",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Aprender las posibilidades y flexibilidad que ofrecen los <code>strings</code></li>\n</ul>\n<p>Esta lección es una traducción casi literal de\n<a href=\"https://javascript.info/string\">https://javascript.info/string</a>,\naquí el <a href=\"https://github.com/iliakan/javascript-tutorial-en/blob/master/1-js/05-data-types/03-string/article.md\">fuente</a></p>\n<hr>\n<p>En JavaScript, los tipos de dato <em>texto</em>, se guardan como <em>tiras de caracteres</em>,\nmás popularmente conocidas como <code>strings</code>.</p>\n<h2>Comillas (<em>Quotes</em>)</h2>\n<p>Recordemos los tipos de comillas que tenemos.</p>\n<p>Los <code>Strings</code> pueden encerrarse en comillas simples (<em>single quotes</em>),\ndobles (<em>doble quotes</em>)\no tildes invertidas (<em>backticks</em>):</p>\n<pre><code class=\"language-js\">const single = 'single-quoted';\nconst double = \"double-quoted\";\nconst backticks = `backticks`;\n\n</code></pre>\n<p>Las comillas simples y dobles, son básicamente lo mismo.\nLas tildes invertidas en cambio,\nnos permiten embeber (interpolar) cualquier expresión dentro de un string:</p>\n<pre><code class=\"language-js\">const greeting = 'Mundo';\nconsole.assert(`Hola ${greeting}` === 'Hola Mundo');\n\nconst sqrt = Math.sqrt(7);\nconsole.assert(`sqrt(7) ~ ${sqrt.toFixed(2)}` === 'sqrt(7) ~ 2.65');\n\nconst sum = (a, b) => a + b;\nconsole.assert(`1 + 2 = ${sum(1, 2)}` === '1 + 2 = 3');\n\nconsole.assert(`${'Hola'.concat(` ${'Mun'.concat('do')}`)}!` === 'Hola Mundo!');\n\n</code></pre>\n<p>Otra ventaja de usar tildes invertidas, es que nos permiten\ndefinir textos multi línea:</p>\n<pre><code class=\"language-js\">const guestList = `Guests:\n * John\n * Pete\n * Mary\n`;\n\nconsole.assert(guestList === 'Guests:\\n * John\\n * Pete\\n * Mary\\n');\n\n</code></pre>\n<p>Si intentamos usar comillas simples o dobles para hacer lo mismo,\nhabrá un error</p>\n<pre><code class=\"language-js\">let guestList = \"Guests:  // Error: Unexpected token ILLEGAL\n* John\";\n</code></pre>\n<p>Las comillas simples y dobles las hemos heredado de\nlos lenguajes tradicionales, donde no se contemplaban\nla interpolación de variables o los strings de más\nde una línea.</p>\n<p>Las tildes invertidas aparecieron mucho después y por lo tanto\nson más versátiles.</p>\n<h2>Caracteres especiales</h2>\n<p>Como vimos antes, es posible crear un <em>multiline string</em>\nusando comillas simples, gracias a un caracter especial, llamado\n<em>\"newline character\"</em>, que se representa asi <code>\\n</code>,\ny representa un salto de línea:</p>\n<pre><code class=\"language-js\">console.assert(\n  `Guests:\n * John\n * Pete\n * Mary` === 'Guests:\\n * John\\n * Pete\\n * Mary',\n);\n\nconsole.assert(\n  `Hello\nWorld` === 'Hello\\nWorld',\n);\n\n</code></pre>\n<p>Hay otros caracteres especiales, que no son tan comunes. Aca la lista:</p>\n<p>| Caracter | Descripción |\n|-----------|-------------|\n|<code>\\'</code>|Single quote\n|<code>\\\"</code>|Double quote\n|<code>\\\\</code>|Backslash\n|<code>\\b</code>|Backspace\n|<code>\\f</code>|Form feed\n|<code>\\n</code>|Newline\n|<code>\\r</code>|Carriage return\n|<code>\\t</code>|Horizontal tab\n|<code>\\ddd</code>|Secuencia octal (3 digitos: ddd)\n|<code>\\xdd</code>|Secuencia hexadecimal (2 digitos: dd)\n|<code>\\uNNNN</code>|Símbolo unicode con código hexadecimal</p>\n<p>Algunos ejemplos con Unicode:</p>\n<pre><code class=\"language-js\">console.assert('\\u00A9' === '©');\nconsole.assert('\\u{1F60D}' === '😍');\n</code></pre>\n<p>Todos los caracteres especiales, comienzan con la barra invertida <code>\\</code>.\nTambién se la llama <em>\"escape character\"</em>.</p>\n<pre><code class=\"language-js\">console.assert('I\\'m the Walrus!' === \"I'm the Walrus!\");\n</code></pre>\n<p>Ten cuenta que sólo usamos la barra invertida para que el intérprete de\nJavaScript entienda lo que le queremos decir. Una vez en memoria, el <code>\\</code>\ndesaparece.</p>\n<p>¿Qué hacemos si necesitamos mostras una barra invertida? Usamos <code>\\\\</code>:</p>\n<pre><code class=\"language-js\">alert( `The backslash: \\\\` ); // The backslash: \\\n</code></pre>\n<h2><code>String.length</code></h2>\n<p>La propiedad <code>length</code> guarda la longitud del <code>String</code>:</p>\n<pre><code class=\"language-js\">console.assert('My\\n'.length === 3);\n</code></pre>\n<p>Nota que los caracteres especiales, a pesar de estar compuestos por 2\ncaracteres, cuentan como un sólo caracter.</p>\n<h2>Accediendo caracteres específicos</h2>\n<p>Para obtener el caracter de la posición <code>pos</code>, usamos corchetes <code>[pos]</code> o el\nmétodo <code>str.charAt(pos)</code>.</p>\n<pre><code class=\"language-js\">let str = `Hello`;\n\nconsole.assert(str[0] === 'H');\nconsole.assert(str.charAt(0) === 'H');\nconsole.assert(str[1000] === undefined);\nconsole.assert(str.charAt(1000) === '');\n\n/* el último caracter */\nconsole.assert(str[str.length - 1] === 'o');\n</code></pre>\n<h2>Immutabilidad</h2>\n<p>En JavaScript, a los <code>Strings</code> <strong>no se puede modificar su valor</strong>.\nInclusive si lo intentamos, no podremos.</p>\n<pre><code class=\"language-js\">str = 'Hi';\nstr[0] = 'P';\nconsole.assert(str[0] === 'H'); /* No cambió */\n</code></pre>\n<p>La forma usual de lograr esto es creando un nuevo string\npisando al anterior:</p>\n<pre><code class=\"language-js\">str = 'Hi';\nstr = `P${str[1]}`; /* replazamos */\n\nconsole.assert(str === 'Pi');\n</code></pre>\n<h2>Mayúsculas / minúsculas</h2>\n<pre><code class=\"language-js\">console.assert('Interface'.toUpperCase() === 'INTERFACE');\nconsole.assert('Interface'.toLowerCase() === 'interface');\nconsole.assert('Interface'[0].toLowerCase() === 'i');\n</code></pre>\n<h2>Substrings</h2>\n<h3>str.indexOf</h3>\n<pre><code class=\"language-js\">str = 'Widget with id';\n\nconsole.assert(str.indexOf('Widget') === 0);\nconsole.assert(str.indexOf('widget') === -1);\nconsole.assert(str.indexOf('id') === 1);\n</code></pre>\n<p><code>String.indexOf</code> funciona de manera análoga a <code>Array.indexOf</code>:\nrecibe un segundo parámetro opcional, que nos permite comenzar\nla búsqueda a partir de una posición en particular.</p>\n<pre><code class=\"language-js\">console.assert(str.indexOf('id', 2) === 12);\n</code></pre>\n<p>Veamos como sería si queremos todas las ocurrencias:</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\nstr = 'As sly as a fox, as strong as an ox';\n\nconst target = 'as'; // texto a buscar\nconst result = [];\n\nlet pos = 0;\nwhile (true) {\n  const foundPos = str.indexOf(target, pos);\n  if (foundPos === -1) break; // ya no hay mas ocurrencias\n\n  result.push(foundPos);\n  pos = foundPos + 1; // siguiente posición\n}\n\nconsole.assert(equal(\n  result,\n  [7, 17, 27],\n));\n</code></pre>\n<p>Asi como en <code>Arrays</code>, también existen los métodos <code>lastIndexOf(pos)</code>\ny <code>lastIndexOf</code>.</p>\n<h3><code>includes</code>, <code>startsWith</code>, <code>endsWith</code></h3>\n<pre><code class=\"language-js\">console.assert('Widget with id'.includes('Widget'));\nconsole.assert(!'Hello'.includes('Bye'));\n</code></pre>\n<p>También cuenta con un segundo parámetro opcional</p>\n<pre><code class=\"language-js\">console.assert('Midget'.includes('id'));\nconsole.assert(!'Midget'.includes('id', 3));\nconsole.assert('Widget'.startsWith('Wid'));\nconsole.assert('Widget'.endsWith('get'));\n</code></pre>\n<h2>Obteniendo substrings</h2>\n<p>Hay 3 métodos en Javascript que nos permiten obtener substrings:\n<code>substring</code>, <code>substr</code> and <code>slice</code>.</p>\n<p><code>str.slice(start [, end])</code>\n: Devuelve parte del string comenzando en <code>start</code>\nhasta (pero sin incluir) <code>end</code>.</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.slice(1, 4) === 'tri');\nconsole.assert(str.slice(0, 1) === 's');\n</code></pre>\n<p>Si no hay segundo parámetro, corre hasta el final del string.</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.slice(2) === 'ringify');\n</code></pre>\n<p>Valores negativos para <code>start/end</code> también son posibles.\nQuiere decir que la posición se cuenta comenzando por el final:</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.slice(-4, -1) === 'gif');\n\n</code></pre>\n<p><code>str.substring(start [, end])</code>\n: Devuelve el substring <em>entre</em> <code>start</code> y <code>end</code>.</p>\n<p>Es casi idéntico a <code>slice</code>, pero permite valores\nde <code>start</code> mayores que <code>end</code>.</p>\n<pre><code class=\"language-js\">str = 'stringify';\n\nconsole.assert(str.substring(2, 6) === 'ring');\nconsole.assert(str.substring(6, 2) === 'ring');\n</code></pre>\n<p>Con <code>slice</code> no funciona:</p>\n<pre><code class=\"language-js\">console.assert(str.slice(2, 6) === 'ring');\nconsole.assert(str.slice(6, 2) === '');\n</code></pre>\n<p><code>str.substr(start [, length])</code>\n: Devuelve parte del string comenzando desde <code>start</code>, <code>length</code> caracteres.</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.substr(2, 4) === 'ring');\n</code></pre>\n<p>El primer argumento puede ser negativo,\npara contar desde el final:</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.substr(-4, 2) === 'gi');\n</code></pre>\n<p>En resumen:</p>\n<p>| método | selecciona... | argumentos negativos |\n|--------|---------------|----------------------|\n|<code>slice(start, end)</code>|desde <code>start</code> hasta <code>end</code> (excluye <code>end</code>)|permite negativos|\n|<code>substring(start, end)</code>|entre <code>start</code> y <code>end</code>|los interpreta como <code>0</code>|\n|<code>substr(start, length)</code>|desde <code>start</code>, <code>length</code> caracteres|permite <code>start</code> negativo|</p>\n<blockquote>\n<p>Todos los anteriores realizan la misma tarea, pero debemos tener en cuenta que\n<code>substr</code> no es parte de las especificación del <code>core</code> de JavaScript, sino del\n<em>Anexo</em> B, que cubre funcionalidades exclusivas de los navegadores. Pero en la\npráctica funciona en todos los entornos.</p>\n</blockquote>\n<h2>Comparando strings</h2>\n<p>Los strings son comparados caracter por caracter en orden alfabético.</p>\n<p>Pero existen algunos casos raros:</p>\n<ol>\n<li>\n<p>Las minúsculas son siempre <em>\"mayores\"</em> que las mayúsculas:</p>\n<pre><code class=\"language-js\">console.assert('a' > 'Z');\n</code></pre>\n</li>\n<li>\n<p>Los caracteres con signos diacríticos, son mayores que todos los otros\ncaracteres:</p>\n<pre><code class=\"language-js\">console.assert('Ñandu' > 'Zebra');\n</code></pre>\n</li>\n</ol>\n<p>Para entender lo que sucede, veamos un poco como se representan internamente\nlos strings en JavaScript</p>\n<p>Los strings se codifican usando <a href=\"https://en.wikipedia.org/wiki/UTF-16\">UTF-16</a>.\nEsto quiere decir que a cada caracter, le corresponde un código numérico.\nContamos con métodos especiales que nos permite ir y venir entre un caracter\ny el código que lo representa.</p>\n<p><code>str.codePointAt(pos)</code>: Devuelve el código del caracter en la posición <code>pos</code>:</p>\n<pre><code class=\"language-js\">console.assert('z'.codePointAt(0) === 122);\nconsole.assert('Z'.codePointAt(0) === 90);\n</code></pre>\n<p><code>String.fromCodePoint(code)</code>: Crea un string a partir del <code>code</code> numérico:</p>\n<pre><code class=\"language-js\">console.assert(String.fromCodePoint(90) === 'Z');\n</code></pre>\n<p>Ahora veamos cuáles son los caracteres con códigos entre <code>65..220</code> (el\nalfabeto):</p>\n<pre><code class=\"language-js\">let alphabet = '';\nfor (let i = 65; i &#x3C;= 122; i += 1) {\n  alphabet += String.fromCodePoint(i);\n}\n\nconsole.assert(\n  alphabet === 'ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz',\n);\n</code></pre>\n<p>Ahora se ve claro por qué <code>a > Z</code>.</p>\n<h2>Resumen</h2>\n<ul>\n<li>Hay 3 tipos de comillas. Las tildes invertidas no permiten definir strings\nmultilineales e interpolar valores.</li>\n<li>Los Strings en JavaScript se codifican usando UTF-16.</li>\n<li>Existen caracteres especiales como <code>\\n</code>.</li>\n<li>Para obtener un caracter espec[ifico usamos: <code>[]</code>.</li>\n<li>Para obtener un substring, usamos: <code>slice</code> o <code>substring</code>.</li>\n</ul>\n<p>Quedan varios métodos bien útiles:</p>\n<ul>\n<li><code>str.trim()</code> -- quita espacios extras del comienzo y fin del string.</li>\n<li><code>str.repeat(n)</code> -- repite el string <code>n</code> veces.</li>\n<li>... mucho más. chequea <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/String\">Strings en MDN</a>\npara más detalles.</li>\n</ul>\n<p>Los <code>Strings</code> además tienen métodos para buscar y reemplazar usando <em>expresiones\nregulares</em>, pero eso queda para otra oportunidad.</p>\n<hr>\n<h2>Recursos sugeridos</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/UTF-16\">UTF-16</a></li>\n<li><a href=\"https://ascii.cl/es/\">ASCII</a></li>\n<li><a href=\"https://javascript.info/string#internals-unicode\">Js Strings Internals y Unicode</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/template_strings\">Usos de las tildes invertidas</a></li>\n</ul>"
            },
            "pt": {
              "title": "Strings",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Aprender as possibilidades e flexibilidade que as <code>strings</code> nos oferecem</li>\n</ul>\n<p>Este conteúdo foi quase uma tradução literal de\n<a href=\"https://javascript.info/string\">https://javascript.info/string</a>, aqui a\n<a href=\"https://github.com/iliakan/javascript-tutorial-en/blob/master/1-js/05-data-types/03-string/article.md\">fonte</a></p>\n<hr>\n<p>Em JavaScript, todos os <em>textos</em> são do tipo <code>string</code>. Até apenas um caractere é\ndo tipo <code>string</code>.</p>\n<h2>Quotes (Aspas)</h2>\n<p>Vamos lembrar o tipo de aspas que temos.</p>\n<p>As <code>strings</code> podem ser aspas simples (<em>single quotes</em>), duplas (<em>double quotes</em>)\nou crase (<em>backticks</em>):</p>\n<pre><code class=\"language-js\">const single = 'single-quoted';\nconst double = \"double-quoted\";\nconst backticks = `backticks`;\n\n</code></pre>\n<p>As aspas simples e duplas, são basicamente a mesma coisa. A crase tem uma\ndiferença, nos permite colocar (interpolar) qualquer expressão dentro de uma\nstring:</p>\n<pre><code class=\"language-js\">const greeting = 'Mundo';\nconsole.assert(`Olá ${greeting}` === 'Olá Mundo');\n\nconst sqrt = Math.sqrt(7);\nconsole.assert(`sqrt(7) ~ ${sqrt.toFixed(2)}` === 'sqrt(7) ~ 2.65');\n\nconst sum = (a, b) => a + b;\nconsole.assert(`1 + 2 = ${sum(1, 2)}` === '1 + 2 = 3');\n\nconsole.assert(`${'Olá'.concat(` ${'Mun'.concat('do')}`)}!` === 'Olá Mundo!');\n\n</code></pre>\n<p>Outra vantagem de usar crase, é o que nós permite criar textos com múltiplas\nlinhas:</p>\n<pre><code class=\"language-js\">const guestList = `Guests:\n * John\n * Pete\n * Mary\n`;\n\nconsole.assert(guestList === 'Guests:\\n * John\\n * Pete\\n * Mary\\n');\n\n</code></pre>\n<p>Se tentarmos usar aspas simples ou duplas para fazer o mesmo, dará um erro:</p>\n<pre><code class=\"language-js\">let guestList = \"Guests:  // Error: Unexpected token ILLEGAL\n* John\";\n</code></pre>\n<p>As aspas simples ou duplas foram herdadas de linguagem tradicionais, onde não se\ncontemplam a interpolação de variáveis ou as <code>strings</code> de mais de uma linha.</p>\n<p>As crases apareceram muito depois e por isso são muito mais versáteis.</p>\n<h2>Caracteres especiais</h2>\n<p>Como vimos antes, é possível criar um <em>multiline string</em> usando aspas simples,\ngraças a um caractere especial, chamado <em>newline character</em>, que é representado\npor <code>\\n</code>, e isso adiciona uma nova linha:</p>\n<pre><code class=\"language-js\">console.assert(\n  `Guests:\n * John\n * Pete\n * Mary` === 'Guests:\\n * John\\n * Pete\\n * Mary',\n);\n\nconsole.assert(\n  `Hello\nWorld` === 'Hello\\nWorld',\n);\n\n</code></pre>\n<p>Existe outros caracteres especiais, que não são tão comuns. Aqui está a lista:</p>\n<p>| Caractere | Descrição |\n|-----------|-------------|\n|<code>\\'</code>|Single quote\n|<code>\\\"</code>|Double quote\n|<code>\\\\</code>|Backslash\n|<code>\\b</code>|Backspace\n|<code>\\f</code>|Form feed\n|<code>\\n</code>|Newline\n|<code>\\r</code>|Carriage return\n|<code>\\t</code>|Horizontal tab\n|<code>\\ddd</code>|Secuencia octal (3 digitos: ddd)\n|<code>\\xdd</code>|Secuencia hexadecimal (2 digitos: dd)\n|<code>\\uNNNN</code>|Símbolo unicode con código hexadecimal</p>\n<p>Alguns exemplos com Unicode:</p>\n<pre><code class=\"language-js\">console.assert('\\u00A9' === '©');\nconsole.assert('\\u{1F60D}' === '😍');\n</code></pre>\n<p>Todos os caracteres especiais, começam com a barra invertida <code>\\</code>. Também chamado\nde <em>escape character</em>.</p>\n<pre><code class=\"language-js\">console.assert('I\\'m the Walrus!' === \"I'm the Walrus!\");\n</code></pre>\n<p>Note que só usamos a barra invertida apenas para que o intérprete do JavaScript\nentenda o que queremos dizer. Uma vez na memória, o <code>\\</code> desaparece.</p>\n<p>O que fazemos se precisamos mostrar uma barra invertida? Usamos <code>\\\\</code>:</p>\n<pre><code class=\"language-js\">alert( `The backslash: \\\\` ); // The backslash: \\\n</code></pre>\n<h2><code>String.length</code></h2>\n<p>A propriedade <code>length</code> retorna o tamanho da <code>String</code>:</p>\n<pre><code class=\"language-js\">console.assert('My\\n'.length === 3);\n</code></pre>\n<p>Note que os caracteres especiais, apesar de serem compostos por 2 caractes,\ncontam apenas um.</p>\n<h2>Acessando caracteres específicos</h2>\n<p>Para obter o caractere da posição <code>pos</code>, usamos os colchetes <code>[pos]</code> ou o\nmétodo <code>str.charAt(pos)</code>.</p>\n<pre><code class=\"language-js\">let str = `Hello`;\n\nconsole.assert(str[0] === 'H');\nconsole.assert(str.charAt(0) === 'H');\nconsole.assert(str[1000] === undefined);\nconsole.assert(str.charAt(1000) === '');\n\n/* o último caractere */\nconsole.assert(str[str.length - 1] === 'o');\n</code></pre>\n<h2>Imutabilidade</h2>\n<p>Em JavaScript, as <code>string</code> <strong>não podem alterar o seu valor</strong>. Inclusive se\ntentarmos, não conseguimos.</p>\n<pre><code class=\"language-js\">str = 'Hi';\nstr[0] = 'P';\nconsole.assert(str[0] === 'H'); /* No cambió */\n</code></pre>\n<p>A forma mais comum de fazer isso é criando uma nova <code>string</code> e passando a\nanterior:</p>\n<pre><code class=\"language-js\">str = 'Hi';\nstr = `P${str[1]}`; /* substituímos */\n\nconsole.assert(str === 'Pi');\n</code></pre>\n<h2>Maiúscula / minúscula</h2>\n<pre><code class=\"language-js\">console.assert('Interface'.toUpperCase() === 'INTERFACE');\nconsole.assert('Interface'.toLowerCase() === 'interface');\nconsole.assert('Interface'[0].toLowerCase() === 'i');\n</code></pre>\n<h2>Substrings</h2>\n<h3>str.indexOf</h3>\n<pre><code class=\"language-js\">str = 'Widget with id';\n\nconsole.assert(str.indexOf('Widget') === 0);\nconsole.assert(str.indexOf('widget') === -1);\nconsole.assert(str.indexOf('id') === 1);\n</code></pre>\n<p><code>String.indexOf</code> funciona de maneira análoga <code>Array.indexOf</code>: recebe um segundo\nparâmetro opcional, que nós permite começar a buscar a partir de uma posição\nparticular.</p>\n<pre><code class=\"language-js\">console.assert(str.indexOf('id', 2) === 12);\n</code></pre>\n<p>Vejamos como seriam todas as ocorrências:</p>\n<pre><code class=\"language-js\">const equal = (one, other) => JSON.stringify(one) === JSON.stringify(other);\n\nstr = 'As sly as a fox, as strong as an ox';\n\nconst target = 'as'; // texto a buscar\nconst result = [];\n\nlet pos = 0;\nwhile (true) {\n  const foundPos = str.indexOf(target, pos);\n  if (foundPos === -1) break; // já não há mais ocorrências\n\n  result.push(foundPos);\n  pos = foundPos + 1; // próxima posição\n}\n\nconsole.assert(equal(\n  result,\n  [7, 17, 27],\n));\n</code></pre>\n<p>Assim como no <code>Array</code>, também existem os métodos <code>lastIndexOf(pos)</code> e\n<code>lastIndexOf</code>.</p>\n<h3><code>includes</code>, <code>startsWith</code>, <code>endsWith</code></h3>\n<pre><code class=\"language-js\">console.assert('Widget with id'.includes('Widget'));\nconsole.assert(!'Hello'.includes('Bye'));\n</code></pre>\n<p>Também conta com um segundo parâmetro opcional</p>\n<pre><code class=\"language-js\">console.assert('Midget'.includes('id'));\nconsole.assert(!'Midget'.includes('id', 3));\nconsole.assert('Widget'.startsWith('Wid'));\nconsole.assert('Widget'.endsWith('get'));\n</code></pre>\n<h2>Obtendo substrings</h2>\n<p>Existem 3 métodos no JavaScript que nos permitem obter substring: <code>substring</code>,\n<code>substr</code> e <code>slice</code>.</p>\n<p><code>str.slice(start [, end])</code>: Retorna parte da string começando com <code>start</code> até\n(mas sem incluir) <code>end</code>.</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.slice(1, 4) === 'tri');\nconsole.assert(str.slice(0, 1) === 's');\n</code></pre>\n<p>Se não passar o segundo parâmetro, a função vai até o final da <code>string</code>.</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.slice(2) === 'ringify');\n</code></pre>\n<p>Valores negativamos para <code>start/end</code> também são possível. Isso quer dizer que a\nposição é contada a partir do final:</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.slice(-4, -1) === 'gif');\n\n</code></pre>\n<p><code>str.substring(start [, end])</code>: Retorna a substring entre <code>start</code> e <code>end</code>.</p>\n<p>É quase idêntico a <code>slice</code>, mas permite valores de <code>start</code> maiores que <code>end</code>.</p>\n<pre><code class=\"language-js\">str = 'stringify';\n\nconsole.assert(str.substring(2, 6) === 'ring');\nconsole.assert(str.substring(6, 2) === 'ring');\n</code></pre>\n<p>Com <code>slice</code> não funciona:</p>\n<pre><code class=\"language-js\">console.assert(str.slice(2, 6) === 'ring');\nconsole.assert(str.slice(6, 2) === '');\n</code></pre>\n<p><code>str.substr(start [, end])</code>: Retorna parte da <code>string</code> começando do <code>start</code> até\no <code>end</code>.</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.substr(2, 4) === 'ring');\n</code></pre>\n<p>O primeiro argumento pode ser negativo e assim irá contar desde o final:</p>\n<pre><code class=\"language-js\">str = 'stringify';\nconsole.assert(str.substr(-4, 2) === 'gi');\n</code></pre>\n<p>Em resumo:</p>\n<p>| método | seleciona... | argumentos negativos |\n|--------|---------------|----------------------|\n|<code>slice(start, end)</code>|desde <code>start</code> até <code>end</code> (exclui <code>end</code>)|permite negativos|\n|<code>substring(start, end)</code>|entre <code>start</code> e <code>end</code>|interpreta como <code>0</code>|\n|<code>substr(start, length)</code>|desde <code>start</code>, <code>length</code> caracteres|permite <code>start</code> negativo|</p>\n<blockquote>\n<p>Todos os anteriores realizam  a mesma tarefa, mas devemos ter em conta que\n<code>substr</code> não é parte das especificação do <code>core</code> do JavaScript, mas o <em>Anexo</em>\nB, que cobre funcionalidades exclusivas dos navegadores. Mas a prática\nfunciona para todo o entorno.</p>\n</blockquote>\n<h2>Comparando strings</h2>\n<p>As <code>strings</code> são comparadas caractere por caractere em ardem alfabética.</p>\n<p>Mas existem alguns casos raros:</p>\n<ol>\n<li>\n<p>As minúsculas são sempre <em>maiores</em> que as maiúsculas:</p>\n<pre><code class=\"language-js\">console.assert('a' > 'Z');\n</code></pre>\n</li>\n<li>\n<p>Os caracteres com sinais diacríticos, são maiores que todos os outros\ncaracteres:</p>\n<pre><code class=\"language-js\">console.assert('Ñandu' > 'Zebra');\n</code></pre>\n</li>\n</ol>\n<p>Para entender o que acontece, vejamos um pouco como representam internamente as\n<code>strings</code> em JavaScript.</p>\n<p>As <code>strings</code> se codificam usando <a href=\"https://pt.wikipedia.org/wiki/UTF-16\">UTF-16</a>.\nIsso significa que cada caractere possui um código numérico. Nós temos métodos\nespeciais que nos permitem ir e vir entre um caractere e o código que o\nrepresenta.</p>\n<p><code>str.codePointAt(pos)</code>: Retorna o código do caractere na posição <code>pos</code>:</p>\n<pre><code class=\"language-js\">console.assert('z'.codePointAt(0) === 122);\nconsole.assert('Z'.codePointAt(0) === 90);\n</code></pre>\n<p><code>String.fromCodePoint(code)</code>: Criar uma <code>string</code> a partir do <code>code</code> numérico:</p>\n<pre><code class=\"language-js\">console.assert(String.fromCodePoint(90) === 'Z');\n</code></pre>\n<p>Agora vejamos qual são os caracteres com códigos dentre <code>65..220</code> (o alfabeto):</p>\n<pre><code class=\"language-js\">let alphabet = '';\nfor (let i = 65; i &#x3C;= 122; i += 1) {\n  alphabet += String.fromCodePoint(i);\n}\n\nconsole.assert(\n  alphabet === 'ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz',\n);\n</code></pre>\n<p>Agora está claro porque <code>a > Z</code>.</p>\n<h2>Resumo</h2>\n<ul>\n<li>Tem 3 tipos de aspas. As crases nos permitem definir <code>strings</code> multilinhas e\ninterpolar valores.</li>\n<li>As <code>strings</code> em JavaScript se codificam usando UTF-16.</li>\n<li>Existem caracteres especiais como <code>\\n</code>.</li>\n<li>Para obter um caractere específico usamos: <code>[]</code>.</li>\n<li>Para obter uma substring, usamos: <code>slice</code> ou <code>substring</code>.</li>\n</ul>\n<p>Existem vários métodos úteis:</p>\n<ul>\n<li><code>str.trim()</code> -- retira os espaços extras do começo e final da <code>string</code>.</li>\n<li><code>str.repeat(n)</code> -- repete a <code>string</code> <code>n</code> vezes.</li>\n<li>... muito mais. leia no <a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/String\">Strings no\nMDN</a>\npara mais detalhes.</li>\n</ul>\n<p>As <code>strings</code> também têm métodos para pesquisar e substituir usando expressões\n<em>regular</em>, mas isso é para outra chance.</p>\n<hr>\n<h2>Recursos sugeridos</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/UTF-16\">UTF-16</a></li>\n<li><a href=\"https://ascii.cl/es/\">ASCII</a></li>\n<li><a href=\"https://javascript.info/string#internals-unicode\">Js Strings Internals e\nUnicode</a></li>\n<li><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/template_strings\">Uso da\ncrase</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "practice",
          "type": "practice",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Retos de código",
              "body": ""
            },
            "pt": {
              "title": "Desafios de código",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "currency-amount",
              "prefix": "01",
              "path": "topics/javascript/06-strings/02-practice/01-currency-amount",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Montos sin moneda",
                  "body": "<p>Dado un arreglo de montos en distintas monedas, retornar solo los valores sin\nimportar la moneda.</p>\n<blockquote>\n<p>Las monedas participantes solo son pesos chilenos ($ CLP), pesos mexicanos\n($ MXN) y soles (S/. PEN).</p>\n</blockquote>\n<p>Ejemplo:</p>\n<pre><code class=\"language-javascript\">const output = currencyAmount([ '$ 600 CLP', '$ 1000 MXN', 'S/. 200 PEN' ]);\n\nconsole.log(ouput); // -> [ 600, 1000, 200 ]\n</code></pre>"
                },
                "pt": {
                  "title": "Montantes sem moeda",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Dado um <code>array</code> de valores em diferentes moedas, retorne apenas os valores sem\nimportar a moeda.</p>\n<blockquote>\n<p>As moedas participantes são apenas pesos chilenos ($ CLP), pesos mexicanos\n($ MXN) e soles (S/. PEN).</p>\n</blockquote>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">const output = currencyAmount([ '$ 600 CLP', '$ 1000 MXN', 'S/. 200 PEN' ]);\n\nconsole.log(ouput); // -> [ 600, 1000, 200 ]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/currencyAmount.js": "const currencyAmount = (amounts) => {\n\n};\n\nmodule.exports = currencyAmount;\n",
                "/solution/currencyAmount.js": "const currencyAmount = amounts => amounts.map(amount => Number(amount.replace(/(\\$|S\\/\\.)|(CLP|MXN|PEN)/g, '')));\n\nmodule.exports = currencyAmount;\n",
                "/test/currencyAmount.spec.js": "const Assert = require('chai').assert;\nconst currencyAmount = require('../solution/currencyAmount');\n\ndescribe('currencyAmount()', () => {\n  it('debería regresar los montos cuando es un arreglo de montos enteros en monedas variadas', () => {\n    const amounts = ['$ 600 CLP', '$ 1000 MXN', 'S/. 200 PEN'];\n    const output = currencyAmount(amounts);\n    Assert.deepEqual(output, [600, 1000, 200]);\n  });\n\n  it('debería regresar los montos cuando es un arreglo de montos reales en monedas variadas', () => {\n    const amounts = ['$ 825.50 CLP', '$ 999.99 MXN', 'S/. 500.25 PEN'];\n    const output = currencyAmount(amounts);\n    Assert.deepEqual(output, [825.50, 999.99, 500.25]);\n  });\n\n  it('debería regresar los montos cuando es un arreglo de montos reales con una sola moneda', () => {\n    const amounts = ['$ 600 MXN', '$ 100.50 MXN', '$ 1349.99 MXN'];\n    const output = currencyAmount(amounts);\n    Assert.deepEqual(output, [600, 100.50, 1349.99]);\n  });\n\n  it('debería regresar un arreglo vacío cuando es un arreglo vacíơ', () => {\n    const amounts = [];\n    const output = currencyAmount(amounts);\n    Assert.deepEqual(output, []);\n  });\n});\n"
              }
            },
            {
              "slug": "first-and-last-to-upper",
              "prefix": "02",
              "path": "topics/javascript/06-strings/02-practice/02-first-and-last-to-upper",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Convertir a Mayúsculas",
                  "body": "<p>Implementa una función que capitalice la primera y última letra de un <em>string</em>.</p>\n<p>Sigue los pasos a continuación para que completes el programa.</p>\n<ol>\n<li>Seleccione la primera y ultima letra y utilice la función\n<code>String.prototype.toUpperCase</code>.</li>\n<li>Componer la nueva cadena y retornarla.</li>\n</ol>"
                },
                "pt": {
                  "title": "Conversor de Maiúsculas",
                  "body": "<ul>\n<li>Environment: <code>js</code></li>\n</ul>\n<hr>\n<p>Implemente uma função de capitalize a primeira e a última letra de uma <em>string</em>.</p>\n<p>Siga os passos abaixo para completar o programa:</p>\n<ol>\n<li>Selecione a primeira e a última letra e utilize a função\n<code>String.prototype.toUpperCase</code>.</li>\n<li>Componha a nova <code>string</code> e devolva-a.</li>\n</ol>"
                }
              },
              "files": {
                "/boilerplate/.eslintrc": "{\n  \"rules\": {\n    \"no-unused-vars\": \"off\"\n  }\n}\n",
                "/boilerplate/firstAndLastToUpper.js": "const firstAndLastToUpper = (str) => {\n\n};\n\nmodule.exports = firstAndLastToUpper;\n",
                "/solution/firstAndLastToUpper.js": "const firstAndLastToUpper = (str) => {\n  const firstLetter = str.charAt(0).toUpperCase();\n  const length = str.length - 1;\n  const lastletter = str.charAt(length).toUpperCase();\n  const result = firstLetter + str.slice(1, length) + lastletter;\n  return result;\n};\n\nmodule.exports = firstAndLastToUpper;\n",
                "/test/firstAndLastToUpper.spec.js": "const Assert = require('chai').assert;\nconst firstAndLastToUpper = require('../solution/firstAndLastToUpper');\n\ndescribe('firstAndLastToUpper()', () => {\n  it('debería retornar en mayúsculas la primer y última letra de un string', () => {\n    Assert.deepEqual(firstAndLastToUpper('murcielago'), 'MurcielagO');\n    Assert.deepEqual(firstAndLastToUpper('sol'), 'SoL');\n    Assert.deepEqual(firstAndLastToUpper('abecedario'), 'AbecedariO');\n  });\n\n  it('debería retornar \"\" si no se le ingresa ningún parametro', () => {\n    Assert.deepEqual(firstAndLastToUpper(''), '');\n  });\n});\n"
              }
            }
          ]
        }
      ]
    },
    {
      "slug": "built-ins",
      "intl": {
        "es": {
          "title": "Built-ins (standard library)"
        },
        "pt": {
          "title": "Built-ins (bibliotecas padrão)"
        }
      },
      "prefix": "07",
      "parts": [
        {
          "prefix": "01",
          "slug": "intro",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Objetos preconstruidos",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<p>En esta unidad aprenderemos:</p>\n<ul>\n<li>¿Qué son los objetos globales, objetos preconstruidos o librerías estándar en\nJavaScript?</li>\n<li>¿Por qué utilizarlos?</li>\n</ul>\n<hr>\n<h3>JavaScript, indagando en el núcleo del lenguaje</h3>\n<p>Todos los lenguajes de programación tienen objetos preconstruidos (built-in)\nque ofrecen funcionalidad común más allá de lo que es el lenguaje en sí. Los\nobjetos preconstruidos nos permiten ahorrar tiempo con funcionalidad disponible\ncomo parte del entorno del lenguaje.</p>\n<p>JavaScript tiene muchos <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales\">objetos preconstruidos</a>.\nEl término \"objetos globales\" (u objetos preconstruidos estándar) no debe\nconfundirse con el objeto global en sí. Aquí, los objetos globales se refieren a\nobjetos en el <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/global_scope\">ámbito global</a>.\nEstos objetos y funciones que vienen con JavaScript pero que no son parte del\nlenguaje en sí, también se conocen como la <em>librería estándar</em> (standard\nlibrary) ya que siempre podemos contar con ellos. Son librerías que no tenemos\nque importar y siempre están disponibles, independientemente del entorno donde\nse ejecute nuestro código (navegador, node, ...).</p>\n<h3>¿Por qué usar la librería estándar?</h3>\n<p>Hay muchas funciones disponibles para ayudarte a escribir un programa bueno\ny eficiente. Como desarrolladores de software, nuestro trabajo es encontrar\nla solución más simple a un problema. \"Más simple\" es un poco vago, así que\nvamos a definirlo como \"funciona, es eficiente (suficiente), es relativamente\nfácil de entender y no tarda demasiado en implementarse\".</p>\n<p>¿Cuánto tardarías en escribir una función que corte una cadena o verifique si\nun número es positivo? Muchas funciones que encontraras en una librería\nestándar son probablemente triviales por naturaleza, pero tener un estándar\nacordado para hacer las cosas acelerará la implementación del código (habrá\nmenos instancias de \"¿hay una función para esto o debería codificarla yo\nmismo?\") Además otras personas que leen tu código pueden concentrarse en\naprender sobre las dependencias que realmente importan y no invertir su tiempo\nen entender librerías que consumes para una sola línea de código.</p>\n<h3>Ventajas más importantes de usar funciones de librería estándar</h3>\n<ul>\n<li>\n<p>Funcionan</p>\n<p>Una de las razones más importantes por las que debes usar las funciones de\nla librería estándar es simplemente porque funcionan, ya han pasado por\nmúltiples pruebas rigurosas y son fáciles de usar.</p>\n</li>\n<li>\n<p>Están optimizadas para el rendimiento</p>\n<p>Un grupo dedicado de desarrollo las mejora constantemente. En el proceso,\nestos equipos pueden crear el código más eficiente y optimizado para\nobtener el máximo rendimiento.</p>\n</li>\n<li>\n<p>Ahorran un considerable tiempo de desarrollo</p>\n<p>Dado que las funciones generales como imprimir en una pantalla, calcular la\nraíz cuadrada y muchas más ya están escritas. No debes preocuparte por\ncrearlas una vez más. Ahorrarás un tiempo valioso, además que tu código\npuede no ser siempre el más eficiente.</p>\n</li>\n<li>\n<p>Son soportadas en la mayoría de los navegadores</p>\n<p>Con las cambiantes necesidades del mundo real, se espera que tu aplicación\nfuncione siempre, en cualquier lugar, en cualquier dispositivo.\nEstas funciones de la biblioteca te ayudan a que tu aplicación funcione\nigual en todos los dispositivos. Esto ahorra tiempo, esfuerzo y hace que tu\nprograma sea compatible con otros navegadores.</p>\n</li>\n</ul>\n<h3>Ejemplo</h3>\n<p>Supongamos que quieres encontrar la raíz cuadrada de un número. Siempre puedes\nescribir tu propia pieza de código para encontrar la raíz cuadrada, pero este\nproceso lleva tiempo y puede no ser el más eficiente.</p>\n<p>Sin embargo, en la programación javascript puedes encontrar la raíz cuadrada\nsimplemente usando la función <code>Math.sqrt()</code>.</p>\n<h3>Algunos de los objetos preconstruidos más utilizados</h3>\n<ul>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array\">Array</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Object\">Object</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Function\">Function</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Boolean\">Boolean</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Number\">Number</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Math\">Math</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Date\">Date</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/String\">String</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/RegExp\">RegExp</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/JSON\">JSON</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Symbol\">Symbol</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Error\">Error</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/EvalError\">EvalError</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/InternalError\">InternalError</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/RangeError\">RangeError</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/ReferenceError\">ReferenceError</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/SyntaxError\">SyntaxError</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/TypeError\">TypeError</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/URIError\">URIError</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\">DataView</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Proxy\">Proxy</a></li>\n</ul>"
            },
            "pt": {
              "title": "Objetos pré-construídos",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>O que são os objetos globais, objetos pré-construídos ou bibliotecas em\nJavaScript?</li>\n<li>Porque utilizar?</li>\n</ul>\n<hr>\n<h3>JavaScript, investigando o núcleo da linguagem</h3>\n<p>Todas as linguagens de programação tem objetos pré-construídos (built-in) que\noferecem mais funcionalidades do que só a linguagem em si. Os objetos\npré-construídos nos permitem salvar tempo com funcionalidades disponíveis como\nparte da linguagem.</p>\n<p>JavaScript tem muitos <a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects\">objetos\npré-construídos</a>.</p>\n<p>O termo \"objetos globais\" (ou objetos padrão pré-construídos) não devem ser\nconfundidos com o objetivo global em si. Aqui, os objetos globais se referem a\nobjetos no <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/global_scope\">ámbito global</a>.\nEstes objetos e funções que já vem com o JavaScript mas que não são parte da\nlinguagem em si, também conhecidas como <em>biblioteca padrão</em>, já que sempre\npodemos contar com elas. São bibliotecas que não temos que importar e sempre\nestão disponíveis, independentemente do escopo onde o código é executado\n(navegador, node, ...).</p>\n<h3>Porque usar biblioteca padrão?</h3>\n<p>Existem muitas funcionalidades disponíveis para ajudar a escrever um programa\nbom e eficiente. Como desenvolvedor de software, nosso trabalho é encontrar a\nsolução mais simples a um problema. \"Mais simples\" é um pouco vago, vamos\ndefinir como \"é eficiente, relativamente fácil de entender, funciona e não\ndemora muito para implementar\".</p>\n<p>Quanto você levaria para escrever uma função que pegue cada numero de um <em>array</em>\ne veja se ele é positivo? Muitas funções que você encontrará em um biblioteca\npadrão são provavelmente triviais por natureza, mas já ter essas funções padrão\nvão acelerar a implementação do código (você vai falar menos vezes \"tem alguma\nfunção para isso, ou eu deveria fazer\"). Além disso outras pessoas que leem o\nseu código podem concentrar em aprender sobre as partes que realmente importam e\nnão perder o seu tempo tentando entender bibliotecas que fazem apenas uma linha\nde código.</p>\n<h3>Algumas vantagem de utilizar bibliotecas padrão</h3>\n<ul>\n<li>\n<p>Funcionam</p>\n<p>Uma das razões mais importantes do porque utilizar funções de uma biblioteca\npadrão é simplemente porque elas funcionam, elas já passaram por muitas provas\nde uso e são fáceis de usar.</p>\n</li>\n<li>\n<p>Estão otimizadas para rendimento</p>\n<p>Existe um grupo de desenvolvimento focado em melhorá-las constantemente. Um dos\nobjetivos dessa equipe é criar códigos mais eficientes e otimizados para obter\no máximo rendimento.</p>\n</li>\n<li>\n<p>Salvam um tempo considerável</p>\n<p>Dado que as funções gerais, como <em>\"printar\"</em> na tela, calcular uma raíz\nquadrada e muitas outras já estão escritas. Com isso você não precisa se\npreocupar em criar essas funções.</p>\n</li>\n<li>\n<p>São suportadas na maioria dos navegadores</p>\n<p>Você esperar que a sua aplicação funcione para sempre, em qualquer lugar e\ndispositivo. Mas no mundo real as coisas estão sempre mudando. Com essas\nfunções você terá uma garantia maior de que o seu código continuará\nfuncionando.</p>\n</li>\n</ul>\n<h3>Exemplo</h3>\n<p>Suponhamos que você quer encontrar a raíz quadrada de um número. Você sempre\npode escrever o seu próprio código para isso. Mas esse processo pode levar um\ntempo e pode não ser nada eficiente.</p>\n<p>No JavaScript você pode encontrar a raíz quadrada utilizando a\nfunção<code>Math.sqrt()</code>.</p>\n<h3>Alguns objetos pré-construídos mais utilizados</h3>\n<ul>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object\">Object</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Function\">Function</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Boolean\">Boolean</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Number\">Number</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Math\">Math</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Date\">Date</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/String\">String</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/RegExp\">RegExp</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/JSON\">JSON</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">Symbol</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Error\">Error</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/EvalError\">EvalError</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/InternalError\">InternalError</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\">RangeError</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\">ReferenceError</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\">SyntaxError</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/TypeError\">TypeError</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError\">URIError</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/DataView\">DataView</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a></p>\n</li>\n</ul>"
            }
          }
        }
      ]
    },
    {
      "slug": "async",
      "intl": {
        "es": {
          "title": "Asincronía"
        },
        "pt": {
          "title": "Asincronía"
        }
      },
      "prefix": "08",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Apertura",
              "body": "<h2>¿Por qué aprender esto?</h2>\n<p>Entender el concepto de <em>asincronía</em> y cómo manejar procesos asíncronos es\nfundamental para toda desarrollodora web. Todas las interacciones con el\nusuario, operaciones de red, eventos del navegador, ... son asíncronas. Esto\nquiere decir que tienen que <em>esperar</em> (a que ocurra un evento, a que recibamos\nuna respuesta por http, ...) para poder completar su trabajo.</p>\n<p>JavaScript es un lenguaje que permite manejar <em>asincronía</em> de una manera\nelegante gracias a su implementación de funciones y su naturaleza <em>non-blocking</em>\n(que no bloquea el hilo - thread - mientras espera a que se complete una tarea\nasíncrona). En esta unidad veremos <strong>callbacks</strong>, <strong>eventos</strong> y <strong>promesas</strong>\ncomo maneras de trabajar con tareas asíncronas.</p>\n<h2>Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Qué es una tarea asíncrona?</li>\n<li>Qué significa bloquear el <em>hilo</em> o <em>thread</em></li>\n<li>Qué es un <em>callback</em></li>\n<li>Qué es un <em>evento</em></li>\n<li>Cómo escuchar <em>eventos</em></li>\n<li>Cómo dejar de escuchar <em>eventos</em></li>\n<li>Qué es una promesa?</li>\n<li>Cómo usar promesas?</li>\n<li>Cómo implementar promesas nuevas</li>\n<li>Cómo encadenar promesas</li>\n</ul>"
            },
            "pt": {
              "title": "Abertura",
              "body": "<h2>Por que aprender isto?</h2>\n<p>Entender o conceito de <em>assincronia</em> e como manipular processos assíncronos é\nfundamental para toda desenvolvedora web. Todas as interações com o usuários,\noperações de rede, eventos do navegador, ... são assíncronas. Isso quer dizer\nque precisam <em>esperar</em> (que um evento ocorra, que recebamos uma resposta por\nhttp, ...) para poder completar o trabalho.</p>\n<p>JavaScript é uma linguagem que permite manipular <em>assincronia</em> de uma maneira\nelegante graças à sua implementação de funções e sua natureza <em>non-blocking</em>\n(que não bloqueia a <em>thread</em> enquanto espera que uma tarefa assíncrona seja\ncompletada). Nesta unidade veremos <strong>callbacks</strong>, <strong>eventos</strong> e <strong>promessas</strong>\ncomo maneiras de trabalhar com tarefas assíncronas.</p>\n<h2>Guia de perguntas e conceitos chave</h2>\n<p>Quando começamos a estudar um novo assunto, é útil termos uma ideia de conceitos\nmais importantes que vamos aprender e dos temas centrais a que devemos prestar\natenção especial.</p>\n<p>A seguir apresentamos uma série de perguntas que você deve ser capaz de\nresponder ao terminar esta unidade. Use estas perguntas como guia para orientar\nseu esforço de aprendizagem. Retorne a elas constantemente a medida que avança\npara validar que está indo na direção correta. Que este guia sirva como um\n\"checklist\" que você vai riscando conforme avança.</p>\n<ul>\n<li>O que é uma tarefa assíncrona?</li>\n<li>O que significa bloquear a <em>thread</em>?</li>\n<li>O que é um <em>callback</em>?</li>\n<li>O que é um <em>evento</em>?</li>\n<li>Como ouvir <em>eventos</em>?</li>\n<li>Como deixar de ouvir <em>eventos</em>?</li>\n<li>O que é uma promessa?</li>\n<li>Como usar promessas?</li>\n<li>Como implementar novas promessas?</li>\n<li>Como encadear promessas?</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "callbacks",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Callbacks",
              "body": "<p>En los diferentes lenguajes y estilos de programación siempre ha habido un\nproblema con el tiempo que toman las cosas en realizarse, quizá no en el sentido\nhumano, pero sí para una computadora, que puede ejecutar varios miles de\noperaciones por segundo. En especial esto sucede con operaciones como ir a\nbuscar cosas al disco duro, buscar información en alguna API de internet, o\nincluso esperar a que el usuario haga algo. Un estilo que triunfó en el pasado\nes el <code>síncrono</code> :</p>\n<pre><code class=\"language-js\">const fs = require('fs');\nconst contents = fs.readFileSync('assets/ajson.json').toString();\nconsole.log(contents);\n</code></pre>\n<p>En este estilo vemos que para imprimir el contenido del archivo, se debe esperar\na que <code>readFileSync</code> termine de leer, no muy eficiente desde el punto de vista\ndel usuario, que tiene que esperar que se complete la lectura para empezar\na ver algo en la pantalla, pero sí desde el punto de vista del programador, que\nsolo tiene que ocuparse de que esto funcione, y que con 3 lineas consigue\nobtener los datos, ... y que cada linea se ejecuta después de la otra, por lo\nque es fácil seguir mentalmente el programa.</p>\n<p>Con la llegada de Javascript, también se hizo popular un nuevo estilo de\nprogramación, llamado <code>asíncrono</code>:</p>\n<pre><code class=\"language-js\">const fs = require('fs');\n\nfs.readFile('assets/ajson.json', (err, buf) => {\n  console.log(buf.toString());\n});\n\nconsole.log('Espera mientras leemos el archivo...');\n</code></pre>\n<p>Con esta forma de programar no nos preocupamos de esperar los datos, podemos\nhacer otras cosas mientras, tales como informar al usuario de nuestro programa\nque algo se está haciendo a través de un mensaje (o barra de progreso si es que\nestamos en una página web). Para esto creamos una función, a la que comúnmente\nse le llama <em>callback</em>, que será la que se ejecute una vez que lleguen los datos\ndel proceso lento.</p>\n<h2>Lecturas complementarias</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function\">Callback function - MDN</a></li>\n</ul>"
            },
            "pt": {
              "title": "Callbacks",
              "body": "<p>As diferentes linguagens e estilos de programação sempre tiveram um problema com\no tempo que as coisas levam para serem realizadas, talvez não no sentido humano,\nmas sim para um computador, que pode executar milhões de operações por segundo.\nEm particular isso acontece com operações como buscar informação no disco\nrígido, buscar informação em alguma API da internet ou também esperar que o\nusuário faça algo. Um estilo que teve sucesso no passado é o modo <code>síncrono</code>:</p>\n<pre><code class=\"language-js\">const fs = require('fs');\nconst contents = fs.readFileSync('assets/ajson.json').toString();\nconsole.log(contents);\n</code></pre>\n<p>Nesse estilo vemos que para imprimir o conteúdo do arquivo, é preciso esperar\nque <code>readFileSync</code> termine de ler, o que não é muito eficiente do ponto de vista\ndo usuário que precisa esperar essa tarefa ser concluída para começar a ver algo\nna tela. Mas é eficiente do ponto de vista do programador, que só precisa se\npreocupar que o programa funcione e que com 3 linhas consiga obter os dados.\nCada linha é executada uma após a outra, o que torna o programa fácil de\nacompanhar.</p>\n<p>Com a chegada de JavaScript, também se popularizou um novo estilo de\nprogramação, chamado <code>assíncrono</code>:</p>\n<pre><code class=\"language-js\">const fs = require('fs');\n\nfs.readFile('assets/ajson.json', (err, buf) => {\n  console.log(buf.toString());\n});\n\nconsole.log('Espera enquanto leemos o arquivo...');\n</code></pre>\n<p>Com esta maneira de programar não nos preocupamos em esperar os dados. Podemos\nfazer outras coisas durante o processo, como informar o usuário que algo está\nsendo executado por meio de uma mensagem (ou barra de progresso se estivermos em\numa página web). Para isso criamos uma função, a qual comumente se chama\n<em>callback</em>, que será executada assim que os dados forem retornados do processo\nlento.</p>\n<h2>Leituras complementares</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/pt-BR/docs/Glossario/Callback_function\">Callback function -\nMDN</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "05",
          "slug": "promises",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Promesas",
              "body": "<p>Hasta ahora hemos visto el uso de <em>callbacks</em> para manejar tareas asíncronas. En\nesta lectura introducimos un tipo de dato nuevo (<code>Promise</code>), que está\nespecíficamente diseñado para encapsular operaciones asíncronas y poder\nencadenarlas.</p>\n<p>Cuando usamos <em>callbacks</em>, es común que nos encontremos con situaciones donde\nuna operación asícrona depende de que otra se haya completado, y así vamos\nanidando callbacks y es fácil perder el hilo de lo que se está\nejecutando en un momento determinado. Más aun si en la vida real comienzan a\nexistir <em>callbacks</em> para todo:</p>\n<pre><code class=\"language-js\">unProcesoLento(\n  (datos) => {\n    otroProcesoLento(\n      (otrosDatos) => {\n        yAunOtroProcesoLento(\n          (masDatos) => {\n            /*\n             * podemos seguir anidando callbacks...\n             */\n          }\n        );\n      }\n    );\n  }\n);\n</code></pre>\n<p>A esto se le llama el <strong>callback hell</strong> y ocurre cuando procesos lentos dependen\ndel resultado de los anteriores por lo que terminamos anidando una dentro de\notra las funciones que esperan por los datos que traen tales procesos.</p>\n<p>Para esto es que desde ES6 se crearon las <code>promesas</code> (<em>Promises</em> en inglés), que\nestán diseñadas para representar a esos datos que están, estarán en el futuro o\nsimplemente nunca llegarán (en caso de que haya alguna falla). Veamos un ejemplo\nde ellas:</p>\n<pre><code class=\"language-js\">const readFiles = require('read-files-promise');\n\nreadFiles([\n  'path/to/file0',\n  'path/to/file1',\n], { encoding: 'utf8' })\n  .then((buffers) => {\n    buffers;\n  })\n  .catch((error) => {\n    console.log('Falló este proceso muy lento');\n  });\n</code></pre>\n<p>Mucho mejor, aunque se vean más lineas hay grandes diferencias con el\nacercamiento de <em>callbacks</em>, el primero es que hay un espacio para la función\nque recibirá los datos y otro para la que ejecutará el código de emergencia en\ncaso de falla, pero la principal es que las promesas pueden anidarse como lo\nveremos en el siguiente ejemplo :</p>\n<pre><code class=\"language-js\">const readFiles = require('read-files-promise');\n\nreadFiles(['path/to/file0'], { encoding: 'utf8' })\n  .then((buffers) => {\n    buffers; // [ContenidoDeArchivo0]\n\n    return readFiles(['path/to/file1'], { encoding: 'utf8' });\n  })\n  .then((buffers) => {\n    buffers; // [ContenidoDeArchivo1]\n  })\n  .catch((error) => {\n    console.log(\"Fallamos al leer archivos\")\n  });\n</code></pre>\n<p>Ahora si, mucho más ordenado, claro y manteniendo la funcionalidad, en donde el\notroProcesoLento depende de los datos del primer proceso lento. Notar que\nmantenemos solo una función de emergencia en caso de error para ambos procesos\nlo que ayuda en reducir el código basura y de estar pendientes de qué función en\nla cadena falló, cosa que tendría que haberse replicado en cada uno de los\n<em>callbacks</em> del <strong>callback hell</strong>.</p>\n<p>Ahora que sabemos el por qué de las promesas, veamos su creación y uso más\ndetallado.</p>\n<h2>Creación de Promises</h2>\n<p>En esta sección nos ponemos del lado del programador de procesos lentos, por lo\nque necesitamos una forma de ordenar nuestro trabajo para que los otros\nprogramadores usen nuestro proceso lento. Veamos\nuna promesa cualquiera por dentro y analicemos las partes que la componen, para\nasí entender cómo crearlas nosotros mismos.</p>\n<pre><code class=\"language-js\">let procesoLento = new Promise((resolve, reject) => {\n  let datos = {};\n  //...\n  //muchas lineas de código\n  //...\n  if (error) {\n    //uh oh, las cosas no salieron tan bien\n    reject(new Error('Fallamos, lo siento'));\n  }\n  //...\n  resolve(datos);\n});\n</code></pre>\n<h3>new Promise</h3>\n<p>Lo primero es la creación de una promesa a través del código\n<code>new Promise(...)</code>, como puedes ver es un objeto que representa a este dato\nque puede estar inmediatamente, en el futuro o simplemente no estar. Este objeto\npara ser creado recibe un <em>callback</em>, pero no como todos, sino que uno especial\nque tiene dos parámetros que veremos a continuación.</p>\n<h4>Parámetro resolve</h4>\n<p>El primer parámetro del <em>callback</em> la promesa es una función especial que\nllamaremos cuando el trabajo lento que hacemos se termina. Con esto se da por\nterminada la promesa y los datos que queramos retornar se ponen como parámetros\nde <code>resolve</code>.</p>\n<h4>Parámetro reject</h4>\n<p>Nuestro trabajo lento puede fallar, es obvio que todo puede fallar (muchas\ngracias Murphy), por esto tenemos que tener una forma de comunicar que nuestro\nproceso lento tuvo un error. Las promesas vienen al rescate y nos proveen de\n<code>reject</code>, una función que podemos llamar en caso de error y que recibe como\nparámetro... si ya lo adivinaron, un error de javascript.</p>\n<h2>Uso de promesas</h2>\n<p>El uso común es tal cuál como mostramos en el ejemplo anterior de código, pero\nahora que estamos viendo con más detalle, expliquemos cada uno de los\ncomponentes del uso de la promesa que vimos con nuestro <em>procesoLento</em> y\n<em>otroProcesoLento</em>.</p>\n<h3>then</h3>\n<p><code>then</code> es una función que el usuario de la promesa provee para cuando el proceso\nlento terminó de ejecutarse correctamente. El número de parámetros que recibe\nson variables y dependen del creador (es muy importante la comunicación entre\nustedes programadoras), generalmente retornan un único parámetro con los datos\nresultantes.\nSi queremos anidar promesas, tal como vimos anteriormente, es importante al\nfinal de esta función retornar otra promesa. Si en cambio queremos retornar un\nvalor para el siguiente paso, lo haremos de la siguiente forma:</p>\n<pre><code class=\"language-js\">  //... mucho código antes ...\n  return Promise.resolve(dato);\n}.then(\n  (dato) => {\n    // Acá podemos usar el dato que retornamos en el then anterior\n  }\n);\n</code></pre>\n<h3>catch</h3>\n<p><code>catch</code> en tanto, es una función que será ejecutada en caso de que <strong>en\ncualquier paso de la cadena de then haya una falla</strong>. Esto es muy importante,\npuesto que concentra todo el manejo de errores en solo una parte, aliviando a la\nprogramadora de tener que manejar errores en cada uno de los <em>callbacks</em>.</p>\n<h2>Estado de promesas</h2>\n<p>Una promesa puede encontrarse en estos estados:</p>\n<ul>\n<li><strong>pending</strong>: Estado inicial, ni terminada exitosamente o rechazada.</li>\n<li><strong>fulfilled</strong>: operación exitosa.</li>\n<li><strong>rejected</strong>: operación fallida o rechazada.</li>\n<li><strong>settled</strong>: la Promise ha sido exitosa o rechazada, pero no está pendiente.</li>\n</ul>\n<h2>Lecturas complemenentarias</h2>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises\">Promises - Jake Archibald - Google Developers</a></li>\n</ul>"
            },
            "pt": {
              "title": "Promesas",
              "body": "<p>Até agora vimos o uso de <em>callbacks</em> para manipular tarefas assíncronas. Nesta\nleitura introduzimos um tipo novo de dado (<code>Promise</code>), que é especificamente\nprojetado para encapsular operações assíncronas e poder encadeá-las.</p>\n<p>Quando usamos <em>callbacks</em>, é comum nos depararmos com situações onde uma\noperação assíncrona depende de que outra tenha sido completada e assim vamos\nencadeando <em>callbacks</em> e é fácil perder o fio da meada do que está sendo\nexecutado em um momento determinado. Mais ainda assim na vida real começam a\nexistir <em>callbacks</em> para tudo:</p>\n<pre><code class=\"language-js\">umProcessoLento(\n  (dados) => {\n    outroProcessoLento(\n      (outrosDados) => {\n        eAindaOutroProcessoLento(\n          (maisDados) => {\n            /*\n             * podemos seguir encadeando callbacks...\n             */\n          }\n        );\n      }\n    );\n  }\n);\n</code></pre>\n<p>Isto se chama <strong>callback hell</strong> e ocorre quando processos lentos dependem do\nresultado de outros anteriores e acabamos encadeando uma dentro da outra as\nfunções que esperam os dados que vêm desses processos.</p>\n<p>Para isso é que desde ES6 se criaram as <code>promessas</code> (<em>Promises</em> en inglês), que\nsão projetadas para representar esses dados que estão chegando, chegarão ou\nsimplesmente nunca cheguem (no caso de acontecer alguma falha). Vejamos um\nexemplo delas:</p>\n<pre><code class=\"language-js\">const readFiles = require('read-files-promise');\n\nreadFiles([\n  'path/to/file0',\n  'path/to/file1',\n], { encoding: 'utf8' })\n  .then((buffers) => {\n    buffers;\n  })\n  .catch((error) => {\n    console.log('Falha neste processo muito lento');\n  });\n</code></pre>\n<p>Muito melhor, embora vejamos mais linhas, há grandes diferenças com a abordagem\nde <em>callbacks</em>. O primeiro é que há um espaço para a função que receberá os\ndados e outro para a que executará o código de emergência em caso de falha, mas\na principal é que as promessas podem ser encadeadas como veremos no próximo\nexemplo:</p>\n<pre><code class=\"language-js\">const readFiles = require('read-files-promise');\n\nreadFiles(['path/to/file0'], { encoding: 'utf8' })\n  .then((buffers) => {\n    buffers; // [ConteudoDeArquivo0]\n\n    return readFiles(['path/to/file1'], { encoding: 'utf8' });\n  })\n  .then((buffers) => {\n    buffers; // [ConteudoDeArquivo1]\n  })\n  .catch((error) => {\n    console.log(\"Falhamos em ler os arquivos\")\n  });\n</code></pre>\n<p>Agora sim, muito mais ordenado, claro e mantendo a funcionalidade, em que o\n<code>outroProcessoLento</code> depende dos dados do primeiro processo lento. Observe que\nmantivemos somente uma função de emergência no caso de um erro acontecer para\nambos os processos, o que ajuda em reduzir o código poluído e de ser dependente\nda função que falhou na cadeia, coisa que teria que ser replicada em cada um dos\n<em>callbacks</em> do <strong>callback hell</strong>.</p>\n<p>Agora que sabemos o porquê das promessas, vamos ver como criá-las e usá-las.</p>\n<h2>Criação de <em>Promises</em></h2>\n<p>Nesta seção nos colocamos ao lado do programador de processos lentos, motivo\npelo qual precisamos de uma forma de ordenar nosso trabalho para que os outros\nprogramadores usem nosso processo lento. Vejamos um processo qualquer por dentro\ne analisemos as partes que o compõem, para assim entendermos como podemos\ncriá-las.</p>\n<pre><code class=\"language-js\">let processoLento = new Promise((resolve, reject) => {\n  let dados = {};\n  //...\n  //muitas linhas de código\n  //...\n  if (error) {\n    //uh oh, as coisas não foram tão bem\n    reject(new Error('Aconteceu um erro, sinto muito.'));\n  }\n  //...\n  resolve(dados);\n});\n</code></pre>\n<h3><em>new Promise</em></h3>\n<p>A primeira coisa é a criação de uma promessa por meio do código <code>new Promise(...)</code>. Como você pode ver, é um objeto que representa esse dado que pode\nestar agora, no futuro ou simplesmente não estar. Para ser criado esse objeto\nrecebe um <em>callback</em>, mas não como todos e sim com um especial que tem dois\nparâmetros que veremos a seguir.</p>\n<h4>Parâmetro <em>resolve</em></h4>\n<p>O primeiro parâmetro do <em>callback</em> da promessa é uma função especial que será\ninvocada quando o trabalho lento que estamos fazendo termina. Com isso a\npromessa termina e os dados que queremos retornar se toram parâmetros de\n<code>resolve</code>.</p>\n<h4>Parâmetro <em>reject</em></h4>\n<p>Nosso trabalho lento pode falhar e é óbvio que tudo pode falhar (muito obrigado\nMurphy) e por isso temos que ter uma forma de comunicar que nosso processo lento\nteve um erro. As promessas vêm ao resgate e nos fornecem <code>reject</code>, uma função\nque podemos chamar no case de erro e que recebe como parâmetros... se já\nadivinhou, um erro de JavaScript.</p>\n<h2>Uso de promessas</h2>\n<p>O uso comum é tal qual como mostramos no exemplo anterior de código, mas agora\nque estamos vendo com mais detalhe, expliquemos cada um dos componentes de uso\nda promessa que vimos com nosso <em>processoLento</em> e <em>outroProcessoLento</em>.</p>\n<h3><em>then</em></h3>\n<p><code>then</code> é uma função que o usuário da promessa fornece para quando o processo\nlento termina de ser executado corretamente. O número de parâmetros que recebe\nsão variáveis e depende do criador (é muito importante a comunicação entre vocês\nprogramadoras), geralmente retornam um único parâmetro com os dados resultantes.\nSe queremos encadear promessas, tal como vimos anteriormente, é importante ao\nfinal desta função retornar outra promessa. Se ao contrário queremos retornar um\nvalor para o passo seguinte, faremos da seguinte forma:</p>\n<pre><code class=\"language-js\">  //... muito código antes...\n  return Promise.resolve(dado);\n}.then(\n  (dado) => {\n    // Aqui podemos usar o dado que retornamos no 'then' anterior\n  }\n);\n</code></pre>\n<h3>catch</h3>\n<p><code>catch</code> no entanto é uma função que será executada no caso de que <strong>haja uma\nfalha em qualquer passo da cadeia</strong>. Isto é muito importante, porque concentra\ntoda a manipulação de erros em só uma parte, aliviando a programadora de ter que\ntratar erros em cada um dos <em>callbacks</em>.</p>\n<h2>Estado de promessas</h2>\n<p>Uma promessa pode estar nestes estados:</p>\n<ul>\n<li><strong>pending</strong>: Estado inicial, nem terminada com sucesso nem fracassada.</li>\n<li><strong>fulfilled</strong>: operação ocorreu com sucesso.</li>\n<li><strong>rejected</strong>: operação com erro ou recusada.</li>\n<li><strong>settled</strong>: a <em>Promise</em> teve sucesso ou fracasso, mas não está pendente.</li>\n</ul>\n<h2>Leituras complementares</h2>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises\">Promises - Jake Archibald - Google\nDevelopers</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "08",
          "slug": "closing",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Cierre",
              "body": "<h2>Resumen</h2>\n<p>Llegamos al final de la unidad ;-)</p>\n<h2>Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Qué es una tarea asíncrona?</li>\n<li>Qué significa bloquear el <em>hilo</em> o <em>thread</em></li>\n<li>Qué es un <em>callback</em></li>\n<li>Qué es un <em>evento</em></li>\n<li>Cómo escuchar <em>eventos</em></li>\n<li>Cómo dejar de escuchar <em>eventos</em></li>\n<li>Qué es una promesa?</li>\n<li>Cómo usar promesas?</li>\n<li>Cómo implementar promesas nuevas</li>\n<li>Cómo encadenar promesas</li>\n</ul>"
            },
            "pt": {
              "title": "Encerramento",
              "body": "<h2>Resumo</h2>\n<p>Chegamos ao final da unidade ;-)</p>\n<h2>Respondamos juntas às perguntas da abertura</h2>\n<ul>\n<li>O que é uma tarefa assíncrona?</li>\n<li>O que significa bloquear a <em>thread</em>?</li>\n<li>O que é um <em>callback</em>?</li>\n<li>O que é um <em>evento</em>?</li>\n<li>Como ouvir <em>eventos</em>?</li>\n<li>Como deixar de ouvir <em>eventos</em>?</li>\n<li>O que é uma promessa?</li>\n<li>Como usar promessas?</li>\n<li>Como implementar novas promessas?</li>\n<li>Como encadear promessas?</li>\n</ul>"
            }
          }
        }
      ]
    },
    {
      "slug": "errors",
      "intl": {
        "es": {
          "title": "Errores"
        },
        "pt": {
          "title": "Erros"
        }
      },
      "prefix": "09",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Apertura",
              "body": "<h2>¿Por qué aprender esto?</h2>\n<p>El manejo de errores quizás no sea el tema más sexy dentro de la programación,\npero es sin duda uno de los más importantes. Un buen manejo de errores no solo\nnos garantiza mejor uso de nuestro código sino que nos debería ayudar a entender\nexcepciones, dónde ocurrieron y por qué.</p>\n<h2>Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Qué es el modo estricto en JavaScript</li>\n<li>Qué es un <code>Error</code> y tipos de errores</li>\n<li>Cómo usar <code>try...catch</code> para manejar errores</li>\n<li>Cómo manejar errores en callbacks</li>\n<li>Cómo manejar errores en promesas</li>\n</ul>"
            },
            "pt": {
              "title": "Abertura",
              "body": "<h2>Por que aprender?</h2>\n<p>O tratamento de erros talvez não seja o tema mais sexy dentro da programação,\nporém é sem dúvida um dos mais importantes. O bom tratamento dos erros não\napenas garante um uso melhor do código, como também nos ajuda a entender\nexceções, onde estão ocorrendo e porquê.</p>\n<h2>Guia de perguntas e conceitos-chave</h2>\n<p>Quando começamos a estudar um tema novo, é útil ter uma ideia dos conceitos mais\nimportantes do que vamos aprender e dos temas centrais onde devemos prestar mais\natenção.</p>\n<p>A seguir apresentamos uma série de perguntas que você deve ser capaz de\nresponder ao término dessa unidade. Utilize estas perguntas como guia para\norientar seus esforços de aprendizagem. Volte a elas constantemente à medida em\nque avança para validar se está avançando na direção correta. Elas devem servir\ncomo um \"checklist\" que você marca enquanto vai avançando.</p>\n<ul>\n<li>O que é o modo estrito no JavaScript</li>\n<li>O que é um <code>Error</code> e tipos de erros</li>\n<li>Como usar <code>try...catch</code> para tratar erros</li>\n<li>Como tratar erros em callbacks</li>\n<li>Como tratar erros em promessas (promises)</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "strict-mode",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Modo Estricto",
              "body": "<p>El modo estricto realiza cambios en la semántica normal de javascript. Un\naspecto importante es que el modo estricto elimina errores silenciosos, lo que\nobligó a escribir un código mejor y no cometer errores.</p>\n<p>La directiva <code>use strict</code> es una directiva que no supone una instrucción de\ncódigo, sino que indica el modo en que el navegador debe ejecutar el código\nJavaScript.</p>\n<p>Podríamos hablar de dos modos de ejecución JavaScript: <code>normal mode</code>, que es el\nque hemos estudiado hasta ahora, y el <code>strict mode</code>, que vamos a explicar.</p>\n<h2>Invocando el modo estricto</h2>\n<p>Para invocar el modo estricto, sólo tienes que escribir <code>'use strict';</code> en tu\narchivo JavaScript. Por ejemplo:</p>\n<pre><code class=\"language-js\">'use strict';\n</code></pre>\n<p>Ahora que ya sabe cómo invocar el modo estricto, vamos a ver un ejemplo rápido.</p>\n<pre><code class=\"language-js\">'use strict';\nfoo = 'Alexandra'; // Uncaught ReferenceError: foo is not defined\n</code></pre>\n<p>Ahora que estamos usando el <em>modo estricto</em> esto resulta en un error, que nos\ndice que <code>foo</code> no está definida. Es necesario declarar la variable antes de\nusarla.</p>\n<pre><code class=\"language-js\">'use strict';\nconst foo = 'Guilherme'; // It works!\n</code></pre>\n<p>El modo estricto cambia la sintáxis y el comportamiento en tiempo de ejecución.\nLos cambios generalmente caen dentro de estas categorías: cambios que convierten\nerratas en errores (como errores de sintáxis o en tiempo de ejecución), cambios\nque simplifican como una variable particular es calculada, cambios que\nsimplifian el uso de eval y arguments, cambios que hacen más fácil escribir\nJavaScript \"seguro\", y cambios que anticipan la evolución futura de EMACScript.</p>\n<h2>Convirtiendo erratas en errores</h2>\n<p>El modo estricto cambia algunos errores de sintáxis tolerados en modo no\nestricto y los convierte en errores.  JavaScript fue diseñado de modo que fuera\nfácil para programadores novatos, y puede haber operaciones que deberían ser\nerrores pero son tratadas como libres de error. A veces esto sirve para\nsolucionar el problema en el momento, pero puede crear problemas más graves\nen el futuro. El modo estricto trata las erratas como errores, para que puedan\nser descubiertas y subsanadas inmediatamente.</p>\n<p>En primer lugar, el modo estricto hace imposible crear variables globales por\naccidente. En JavaScript no estricto, si se escribe mal una variable en una\nasignación, se creará una nueva propiedad en el objeto globlal y el código\ncontinuará \"trabajando\" como si nada (aunque es posible que el código así\nescrito falle en el futuro, en concreto, en JavaScript más moderno). En modo\nestricto, cualquier asignación que produzca variables globales por accidente\nlanzará un error.</p>\n<p>En segundo lugar, el modo estricto lanza una excepción en asignaciones que de\notro modo fallarían silenciosamente. Por ejemplo, NaN es una variable que no\npuede ser asignada. En un código normal, asignar a <code>NaN</code> un valor no tiene\nefectos; el programador no recibe ningún mensaje de error. En cambio, en modo\nestricto, si se intenta asignar un valor a <code>NaN</code>, el programador recibirá una\nexepción. Cualquier asignación que falle silenciosamente en código normal\n(asignaciones a una propiedad de no escritura, asignaciones a una propiedad get,\nasignaciones a una nueva propiedad o a un objecto no extendible) lanzará una\nexcepción en modo estricto:</p>\n<pre><code class=\"language-js\">'use strict';\n// Asignación a un no-escritura global\nvar undefined = 5; // TypeError: \"undefined\" is read-only\nvar Infinity = 5; // TypeError: \"Infinity\" is read-only\n\n// Asignación a una propiedad de no-escritura\nconst obj1 = {};\nObject.defineProperty(obj1, 'x', { value: 42, writable: false });\nobj1.x = 9; // lanza un TypeError\n\n// Asignación a una propiedad de tipo getter\nconst obj2 = { get x() { return 17; } };\nobj2.x = 5; // lanza un TypeError\n\n// Asignación a una nueva propiedad en un objeto no-extendible\nconst fixed = {};\nObject.preventExtensions(fixed);\nfixed.newProp = 'ohai'; // lanza un TypeError\n</code></pre>\n<p>En tercer lugar, el modo estricto lanza una excepción al intentar eliminar\npropiedades no eliminables (mientra que en código normal el intento no tendría\nningún efecto):</p>\n<pre><code class=\"language-js\">'use strict';\ndelete Object.prototype; // lanza TypeError\n</code></pre>"
            },
            "pt": {
              "title": "Modo Estrito",
              "body": "<p>O modo estrito realiza mudanças na semântica normal do JavaScript. Um aspecto\nimportante disso é que o modo estrito elimina erros silenciosos, forçando a\nescrita de um código melhor.</p>\n<p>O comando <code>use strict</code> não significa uma instrução de código, apenas indica ao\nnavegador o modo como deve executar o código JavaScript.</p>\n<p>Poderíamos falar de dois modos de execução do JavaScript: <code>normal mode</code>, que é\ncomo temos estudado até agora, e o <code>strict mode</code> que é o que vamos aprender.</p>\n<h2>Chamando o modo estrito</h2>\n<p>Para chamar o modo estrito, você deve apenas escrever <code>'use strict';</code>em seu\narquivo JavaScript. Por exemplo:</p>\n<pre><code class=\"language-js\">'use strict';\n</code></pre>\n<p>Agora que você sabe como chamar o modo estrito, vamos ver um exemplo rápido.</p>\n<pre><code class=\"language-js\">'use strict';\nfoo = 'Alexandra'; // Uncaught ReferenceError: foo is not defined\n</code></pre>\n<p>Agora que estamos utilizando o <em>modo estrito</em> o JavaScript nos retorna um erro,\ndizendo que <code>foo</code> não está definida. É necessário declarar a variável antes de\nutilizá-la.</p>\n<pre><code class=\"language-js\">'use strict';\nconst foo = 'Guilherme'; // Funciona!\n</code></pre>\n<p>O modo estrito modifica a sintaxe e o comportamento durante a execução. As\nmudanças geralmente caem dentro das seguintes categorias: modificações que\nconvertem erratas em erros (como erros de sintaxe ou no tempo de execução), que\nsimplificam como uma variável em particular é calculada, que simplificam o uso\ndo eval() e argumentos, que tornam mais fácil a escrita de JavaScript \"seguro\" e\nque antecipam a evolução futura do ECMAScript.</p>\n<h2>Convertendo erratas em erros</h2>\n<p>O modo estrito modifica alguns erros de sintaxe tolerados no modo normal e os\nconverte em erros. O JavaScript foi desenvolvido de um modo que o tornasse mais\nfácil para programadoras iniciantes, dessa forma podem existir operações que\ndeveriam ser erros, porém são tratadas como livres de erros. Algumas vezes isso\né útil para solucionar um problema no momento, porém pode criar problemas mais\ngraves no futuro. O modo estrito trata estas erratas como erros, para que possam\nser encontradas e resolvidas imediatamente.</p>\n<p>Em primeiro lugar, o modo estrito impossibilita a criação de variáveis globais\npor acidente. No modo não estrito do JavaScript, uma variável declarada de forma\nincorreta criará uma nova propriedade no objeto global e o código continuará\nrodando como se nada tivesse acontecido (ainda que seja possível que o código\nfalhe no futuro, em uma versão mais moderna do JS). No modo estrito, qualquer\ndeclaração de produza variáveis globais por acidente resultará em erro.</p>\n<p>Em segundo lugar, o modo estrito gera uma exceção para declarações que de outro\nmodo falhariam silenciosamente. Por exemplo, NaN é uma variável que não pode ser\ndeclarada. Em um código normal, declarar um valor como <code>NaN</code> não tem efeito; a\nprogramadora não recebe nenhuma mensagem de erro. Ao invés disso, no modo\nestrito, ao tentar atribuir <code>NaN</code> como valor, a programadora receberá uma\nexceção. Qualquer declaração que falhe silenciosamente no código normal\n(declarações a uma propriedade do tipo \"somente leitura\", a uma propriedade get,\nadicionar propriedades a objetos não extensíveis) resultará em uma exceção no\nmodo estrito:</p>\n<pre><code class=\"language-js\">'use strict';\n// atribuição global\nvar undefined = 5; // TypeError: \"undefined\" is read-only\nvar Infinity = 5; // TypeError: \"Infinity\" is read-only\n\n// Atribuição a uma propriedade somente leitura\nconst obj1 = {};\nObject.defineProperty(obj1, 'x', { value: 42, writable: false });\nobj1.x = 9; // gera um TypeError\n\n// Atribuição a uma propriedade do tipo getter\nconst obj2 = { get x() { return 17; } };\nobj2.x = 5; // gera um TypeError\n\n// Atribuição a uma nova propriedade de um objeto não extensível\nconst fixed = {};\nObject.preventExtensions(fixed);\nfixed.newProp = 'ohai'; // gera um TypeError\n</code></pre>\n<p>Em terceiro lugar, o modo estrito gera uma exceção ao tentar eliminar\npropriedades não elimináveis (enquanto no código normal a tentativa não surtiria\nnenhum efeito):</p>\n<pre><code class=\"language-js\">'use strict';\ndelete Object.prototype; // gera um TypeError\n</code></pre>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "try-catch",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Try...catch",
              "body": "<p>JavaScript soporta un conjunto compacto de sentencias específicamente para el\nmanejo de flujo, que pueden ser utilizadas para incorporar mayor interactividad\na tus aplicaciones.</p>\n<p>La guía de referencia de JavaScript contiene detalles exhaustivos sobre las\nsentencias mencionadas en este capítulo. El punto y coma (<code>;</code>) se utiliza para\nseparar sentencias de código JavaScript.</p>\n<p>En Javascript cualquier expresión es también una sentencia. Una sentencia\ncondicional es un conjunto de comandos que se ejecutan si una condición es\nverdadera. JavaScript soporta dos sentencias condicionales: <code>if...else</code> y\n<code>switch</code>.</p>\n<p>A través de toda la formación que a este minuto has recibido, ya sabes cuáles\nson las sentencias condicionales, además conoces los bucles o loops, que\npertenecen a toda el área de control de flujo en JavaScript, en ésta parte me\ngustaría más contarte a cerca de las sentencias de manejo de excepciones.\nPrácticamente cualquier objeto puede ser lanzado (<em>thrown</em> en inglés) en\nJavaScript. Sin embargo, no todos los objetos lanzados son creados igual.\nMientras que es bastante común lanzar números o strings como errores,\nfrecuentemente es más efectivo utilizar uno de los tipos de excepciones\nespecíficamente creados para este proposito:</p>\n<h2>Sentencia throw</h2>\n<p>Utiliza la sentencia throw para lanzar una excepción. Cuando lanzas un\nexcepción, se especifica la expresión que contiene el valor para ser lanzado:</p>\n<pre><code class=\"language-js\">throw expresión;\n</code></pre>\n<p>Puedes lanzar cualquier expresión, no solo expresiones de un tipo especifico. En\nel siguente código lanzamos varias excepciones de varios tipos:</p>\n<pre><code class=\"language-js\">throw \"Error2\";   // Tipo string\nthrow 42;         // Tipo número\nthrow true;       // Tipo booleano\nthrow {toString: function() { return \"¡Soy un objeto!\"; } };\n</code></pre>\n<p>Puedes especificar un objeto cuando lanzas una excepción. A continuación, puedes\nhacer referencia a las propiedades del objeto en un bloque catch. En el\nsiguiente ejemplo se crea un objeto myUserException del tipo UserException y lo\nusa en la sentencia throw.</p>\n<pre><code class=\"language-js\">// Crear un tipo de objeto UserException\nfunction UserException (aviso){\n  this.aviso=aviso;\n  this.nombre=\"UserException\";\n}\n\n// Make the exception convert to a pretty string when used as a string\n// (e.g. by the error console)\nUserException.prototype.toString = function () {\n  return this.nombre + ': \"' + this.aviso + '\"';\n}\n\n// Create an instance of the object type and throw it\nthrow new UserException(\"Value too high\");\n</code></pre>\n<h2>try...catch</h2>\n<p>La sentencia <code>try...catch</code> marca un bloque de instrucciones a intentar que\npueden causar alguna excepción, y declarar una o más respuestas en caso de que\nuna excepción sea arrojada. Si una excepción es arrojada, la sentencia\n<code>try...catch</code> se encarga de atraparla.</p>\n<p>La sentencia <code>try...catch</code> consiste en un bloque <code>try</code>, el cuál contiene una o\nmás instrucciones, y ninguno o varios bloques <code>catch</code>, conteniendo sentencias\nque especifican que hacer si una excepción es arrojada en un bloque <code>try</code>. Se\ndesea que las instrucciones dentro del bloque <code>try</code> se ejecuten con éxito, de\ncaso contrario caerán en el bloque <code>catch</code> para ser controladas. Si ninguna\ninstrucción dentro del bloque <code>try</code> (o en una función llamada dentro del bloque\ntry) arroja una excepción, el control pasa inmediatamente al bloque <code>catch</code>. Si\nninguna excepción es arrojada en el bloque <code>try</code>, el bloque <code>catch</code> es ignorado.\nPor último se ejecuta el bloque <code>finally</code> luego de que los bloques <code>try</code> y\n<code>catch</code> hayan sido ejecutados, pero antes de las instrucciones que se encuentren\nluego de la sentencia <code>try...catch</code>.</p>\n<p>El siguiente ejemplo usa la sentencia <code>try...catch</code>. El ejemplo llama a una\nfunción que retorna el nombre de un mes desde un arreglo basado en un valor\npasado como argumento a la función. Si el valor no corresponde con el número de\nun mes (entre <code>1</code> y <code>12</code>), una excepción es arrojada con el valor\n<code>'InvalidMonthNo'</code> y las instrucciones en el bloque catch le asignarán a la\nvariable <code>monthName</code> el valor de <code>'unknown'</code>.</p>\n<pre><code class=\"language-js\">function getMonthName (mo) {\n  mo = mo - 1; // Ajusta el indice del arreglo para el arreglo de meses (1=Jan, 12=Dec)\n  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',\n                'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  if (months[mo] != null) {\n    return months[mo];\n  } else {\n    throw 'InvalidMonthNo'; //Arroja la palabra \"InvalidMonthNo\" al ocurrir una excepción\n  }\n}\n\ntry { // instrucciones a probar\n  monthName = getMonthName(myMonth); // La función puede arrojar una excepción\n}\ncatch (e) {\n  monthName = 'unknown';\n  logMyErrors(e); // Pasa el objeto de la excepción a un manejador de errores\n}\n</code></pre>\n<h2>El bloque catch</h2>\n<p>Un bloque <code>catch</code> es usado para manejar todas las excepciones que pueden ser\ngeneradas en el bloque <code>try</code>.</p>\n<p>El bloque <code>catch</code> especifica un identificar (catchID en la sintaxis anterior)\nque mantiene el valor especificado por la sentencia <code>throw</code>; puedes usar este\nidentificador para obtener información acerca de la excepción que fue arrojada.\nJavaScript crea este identificador cuando ha entrado en el bloque <code>catch</code>; el\nidentificador dura mientras dure el bloque <code>catch</code>; después de que el bloque\n<code>catch</code> termine su ejecución, el identificador ya no está disponible.</p>\n<p>Por ejemplo, el siguiente código arroja una excepción. Cuando la excepción\nocurre, el control es transferido al bloque <code>catch</code>.</p>\n<pre><code class=\"language-js\">try {\n  throw \"myException\" // genera una excepción\n}\ncatch (e) {\n  // instrucciones para manejar cualquier excepción generada\n  logMyErrors(e) // Pasa el objeto de excepción a un manejador de errores\n}\n</code></pre>"
            },
            "pt": {
              "title": "Try...catch",
              "body": "<p>O JavaScript suporta um conjunto compacto de declarações específicas para o\nmanejo de fluxo, que podem ser utilizadas para incorporar uma maior\ninteratividade entre suas aplicações.</p>\n<p>A documentação do JavaScript contem muitos detalhes sobre as declarações\nmencionadas nesta unidade. O ponto e vírgula (;) é utilizado para separar\nsentenças no código JavaScript.</p>\n<p>No JavaScript, qualquer expressão é também uma sentença. Uma sentença\ncondicional é um conjunto de comandos que são executados caso uma condição seja\nverdadeira. São suportados dois tipos se sentenças condicionais: <code>if...else</code> e\n<code>switch</code>.</p>\n<p>Com todo o conteúdo que estudamos até agora, você já sabe quais são as sentenças\ncondicionais e também conhece os loops, que pertencem à parte de controle de\nfluxo no JavaScript. A partir de agora vamos falar sobre as sentenças para\ntratamento de exceções. Praticamente qualquer objeto pode ser lançado (<em>thrown</em>\nem inglês) no JavaScript. Porém, nem todos os objetos lançados são criados da\nmesma forma. Embora seja bastante comum o lançamento de números ou strings como\nerros, normalmente é mais eficiente utilizar um dos tipos de exceção criados\nespecificamente com este propósito:</p>\n<h2>Sentença throw</h2>\n<p>Utilize a sentença throw para gerar uma exceção, especificando a expressão que\ncontém o valor a ser lançado:</p>\n<pre><code class=\"language-js\">throw expresión;\n</code></pre>\n<p>Pode lançar qualquer expressão, não apenas de um tipo específico. No código\nabaixo utilizamos expressões de vários tipos:</p>\n<pre><code class=\"language-js\">throw \"Error2\";   // Tipo string\nthrow 42;         // Tipo número\nthrow true;       // Tipo booleano\nthrow {toString: function() { return \"¡Soy un objeto!\"; } };\n</code></pre>\n<p>É possível especificar um objeto para gerar a exceção. Em seguida, pode-se\nreferenciar as propriedades deste objeto em um bloco catch. No exemplo seguinte,\né criado o objeto myUserException do tipo UserException, que é utilizado na\nsentença throw.</p>\n<pre><code class=\"language-js\">// Cria um tipo de objeto UserException\nfunction UserException (aviso){\n  this.aviso=aviso;\n  this.nome=\"UserException\";\n}\n\n// Make the exception convert to a pretty string when used as a string\n// (e.g. by the error console)\nUserException.prototype.toString = function () {\n  return this.nombre + ': \"' + this.aviso + '\"';\n}\n\n// Create an instance of the object type and throw it\nthrow new UserException(\"Value too high\");\n</code></pre>\n<h2>try...catch</h2>\n<p>A sentença <code>try...catch</code> marca um bloco de instruções que podem causar alguma\nexceção, e declara uma ou mais respostas caso a exceção seja gerada. Neste caso,\na sentença <code>try...catch</code> trata de interceptá-la.</p>\n<p>A <code>try...catch</code> consiste em um bloco <code>try</code>, que contém uma ou mais instruções, e\nnenhum a vários blocos <code>catch</code>, contendo sentenças que especificam o que fazer\nse uma exceção é pega no bloco <code>try</code>. É desejável que as instruções dentro do\nbloco <code>try</code> sejam executadas com êxito, caso contrário cairão no bloco <code>catch</code>\npara serem controladas. Se nenhuma instrução dentro do bloco <code>try</code> (ou em uma\nfunção chamada dentro do bloco) gera uma exceção, o controle passa imediatamente\npara o bloco <code>catch</code>. Caso nenhuma exceção seja gerada no bloco <code>try</code>, o bloco\n<code>catch</code> é ignorado. Por último, se executa o bloco <code>finally</code> assim que os blocos\nanteriores tenham sido executados, mas antes das instruções que estão em seguida\nao <code>try...catch</code>.</p>\n<p>O exemplo abaixo utiliza a sentença <code>try...catch</code>. O exemplo chama uma função\nque retorna o nome de um mês a partir de um array baseado em um valor que foi\npassado como argumento para a função. Se o valor não corresponde com o número de\num mês (de <code>1</code> a <code>12</code>), a exceção é gerada com o valor <code>'InvalidMonthNo'</code> e as\ninstruções no bloco <code>catch</code> atribuirão à variável <code>monthName</code> o valor de\n<code>unknown</code>.</p>\n<pre><code class=\"language-js\">function getMonthName (mo) {\n  mo = mo - 1; // Ajusta o índice do array para o array de meses (1=Jan, 12=Dec)\n  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',\n                'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  if (months[mo] != null) {\n    return months[mo];\n  } else {\n    throw 'InvalidMonthNo'; //Lança o termo \"InvalidMonthNo\" ao ocorrer uma exceção\n  }\n}\n\ntry { // instruções a testar\n  monthName = getMonthName(myMonth); // A função pode gerar uma exceção\n}\ncatch (e) {\n  monthName = 'unknown';\n  logMyErrors(e); // Passa o objeto da exceção para o tratamento do erro\n}\n</code></pre>\n<h2>O bloco catch</h2>\n<p>Um bloco <code>catch</code> é utilizado para tratar todas as exceções que possam ser\ngeradas no bloco <code>try</code>.</p>\n<p>O bloco <code>catch</code> especifica um identificador (catchID na sintaxe anterior) que\nmantém o valor especificado pela sentença <code>throw</code>; este identificador pode ser\nutilizado para obter informações a respeito da exceção gerada. O JavaScript cria\neste identificador ao entrar no bloco <code>catch</code>; o identificador se mantém na\nduração do bloco <code>catch</code>; após o término da execução do bloco <code>catch</code>, o\nidentificador já não estará mais disponível.</p>\n<p>Por exemplo, o seguinte código gera uma exceção. Quando a exceção ocorre, o\ncontrole é transferido para o bloco <code>catch</code>.</p>\n<pre><code class=\"language-js\">try {\n  throw \"myException\" // gera uma exceção\n}\ncatch (e) {\n  // instruções para tratar qualquer exceção gerada\n  logMyErrors(e) // Passa o objeto de exceção para o tratamento de erros\n}\n</code></pre>"
            }
          }
        },
        {
          "prefix": "03",
          "slug": "callbacks",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Errores en callbacks",
              "body": "<p>En la lectura anterior hemos visto como la sentencia <code>try...catch</code> nos permite\nenvolver código que podría resultar en una excepción y así evitar que la\nexcepción haga que se termine la ejecución de nuestro programa.</p>\n<p>Pero qué pasa cuando ocurre un error en una operación asíncrona? Veamos un\nejemplo. Imaginemos que en un script escrito para Node.js tenemos una función\nque se llama <code>getLatestNodeInfo()</code>, y que esta función es asíncrona (tiene que\nhacer una consulta por HTTP para ver cuál es la versión más reciente de\nNode.js), así que recibe un <em>callback</em> como argumento.</p>\n<pre><code class=\"language-js\">getLatestNodeInfo((err, data) => {\n  if (err) {\n    return console.error(err);\n  }\n\n  console.log(data);\n});\n</code></pre>\n<p>En el mundo de Node.js es muy común que los callbacks tengan esta firma\n<code>(err, data)</code>, dónde el primer argumento es un error (en caso de que haya\nocurrido uno) y el segundo argumento es la <code>data</code> o el <em>resultado</em> en caso de\nque la operación se complete satisfactoriamente.</p>\n<p>A la hora de implementar funciones asíncronas, donde vamos a comunicar el\n<em>resultado</em> a través de un <em>callback</em>, evitamos arrojar errores con <code>throw</code> y en\nvez los comunicamos como argumento a una función callback. Esto va a permitir\n\"atrapar\" un error asíncrono (que ha ocurrido en otro contexto de ejecución) y\nmanejar errores que de otra forma no podríamos.</p>\n<p>Considera la siguiente implementación de la función <code>getLatestNodeInfo()</code>:</p>\n<pre><code class=\"language-js\">const http = require('http');\n\nconst getLatestNodeInfo = (cb) =>\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      throw new Error(`Request Failed. Status Code: ${statusCode}`);\n    }\n\n    // ...\n\n  }).on('error', cb);\n</code></pre>\n<p>En esta implementación (incompleta todavía - e incorrecta por ahora) estamos\nlanzando un error con <code>throw</code> dentro de un <em>callback</em>. Viendo esta sentencia\n<code>throw</code> unx podría pensar que podemos usar <code>try...catch</code> para atrapar el error.\nAlgo así:</p>\n<pre><code class=\"language-js\">// intento fallido de atrapar error lanzado con `throw` dentro de un callback\ntry {\n  getLatestNodeInfo(() => {\n    // ...\n  });\n} catch (err) {\n  console.log('error atrapado con try...catch', err);\n}\n</code></pre>\n<p>En este caso, si se da la condición del error (puedes cambiar\n<code>statusCode !== 200</code> a <code>statusCode === 200</code> temporalmente para probar el error),\nveremos que la excepción NO es atrapada en el bloque <code>catch</code>, sino que termina\nla ejecución de nuestro programa sin que tengamos la oportunidad de manejar el\nerror. Esto es porque la excepción se está arrojando desde un callback que se\nejecuta en otro contexto, más adelante en el tiempo. Este <code>try...catch</code> solo\natraparía errores que pudieran ocurrir en la parte síncrona de la función, antes\nde hacer el request.</p>\n<p>Es por esto que las funciones asíncronas evitan arrojar errores con <code>throw</code> y\nsiempre comunican errores a través de argumentos pasados a <em>callbacks</em>, ya sea\nen un <em>callback</em> con varios argumentos donde el primero es el posible error, o\nen <em>callbacks</em> dedicados, como por ejemplo el <em>handler</em> que le pasamos a request\nen el ejemplo anterior:</p>\n<pre><code class=\"language-js\">http\n  .get(url, successCallback)\n  .on('error', errorCallback);\n</code></pre>\n<p>Ahora sí, completemos nuestra implementación de <code>getLatestNodeInfo()</code>, pero esta\nvez pasando los errores a través del <em>callback</em> recibido del usuario en vez de\nusar <code>throw</code>. Nótese también que la implementación hace uso de <code>try...catch</code>\ninternamente para atrapar errores que pudieran ocurrir durante el <em>parseado</em> de\nla data recibida (usando <code>JSON.parse()</code>), lo cual es una operación síncrona y\nqueremos evitar que arroje un error, ya que no podría manejarse desde fuera de\nnuestra función. Para solucionar esto, primero atrapamos el error y después lo\ndevlolvemos como argumento al <em>callback</em>.</p>\n<pre><code class=\"language-js\">const getLatestNodeInfo = (cb) =>\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      return cb(new Error(`Request Failed. Status Code: ${statusCode}`));\n    } else if (!/^application\\/json/.test(headers['content-type'])) {\n      return cb(new Error(`Bad content-type. Expected application/json but got ${contentType}`));\n    }\n\n    let rawData = '';\n    resp.setEncoding('utf8');\n    resp.on('data', (chunk) => { rawData += chunk; });\n    resp.on('end', () => {\n      try {\n        const parsedData = JSON.parse(rawData);\n        cb(null, parsedData.shift());\n      } catch (err) {\n        cb(err);\n      }\n    });\n  }).on('error', cb);\n</code></pre>\n<p>Esta nueva implementación nos asegura que los errores que puedan ocurrir en\nnuestra función siempre se pasen como argumentos al <em>callback</em> recibido por el\nusuario.</p>"
            },
            "pt": {
              "title": "Erros em callbacks",
              "body": "<p>Na unidade anterior vimos como a sentença <code>try...catch</code> nos permite cercar\ncódigo que poderia resultar em uma exceção e assim evitar que a exceção\ninterrompa a execução do programa.</p>\n<p>Porém, o que acontece quando o erro ocorre em uma operação assíncrona? Vejamos\num exemplo. Vamos imaginar que em um script escrito para Node.js temos uma\nfunção chamada <code>getLatestNodeInfo()</code>, e que esta é uma função assíncrona (deve\nhaver uma consulta por HTTP para verificar qual é a versão mais recente do\nNode.js) que recebe um <em>callback</em> como argumento.</p>\n<pre><code class=\"language-js\">getLatestNodeInfo((err, data) => {\n  if (err) {\n    return console.error(err);\n  }\n\n  console.log(data);\n});\n</code></pre>\n<p>No mundo do Node.js é muito comum que os callbacks tenham esta sintaxe <code>(err, data)</code>, onde o primeiro argumento é um erro (caso ocorra algum) e o segundo\nargumento é a <code>data</code> ou o <em>resultado</em> caso a operação se complete com sucesso.</p>\n<p>Ao implementar funções assíncronas, onde vamos comunicar o <em>resultado</em> através\nde um <em>callback</em>, evitamos lançar erros com <code>throw</code>; ao invés disso, os\ncomunicamos como argumento a uma função callback. Isto nos permite \"prender\" um\nerro assíncrono (que ocorreu em outro contexto de execução) e tratar erros que\nde outra forma não poderíamos.</p>\n<p>Considere a seguinte implementação da função <code>getLatestNodeInfo()</code>:</p>\n<pre><code class=\"language-js\">const http = require('http');\n\nconst getLatestNodeInfo = (cb) =>\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      throw new Error(`Request Failed. Status Code: ${statusCode}`);\n    }\n\n    // ...\n\n  }).on('error', cb);\n</code></pre>\n<p>Nesta implementação (por enquanto incompleta e incorreta) estamos lançando um\nerro com <code>throw</code> dentro de uma <em>callback</em>. Vendo a sentença <code>throw</code>, poderíamos\npensar que é possível usar <code>try...catch</code> para cercar o erro. Algo assim:</p>\n<pre><code class=\"language-js\">// tentativa falha de pegar o erro lançado com `throw` dentro de uma callback\ntry {\n  getLatestNodeInfo(() => {\n    // ...\n  });\n} catch (err) {\n  console.log('erro pego com try...catch', err);\n}\n</code></pre>\n<p>Neste caso, se ocorrer a condição do erro (pode-se mudar <code>statusCode !== 200</code>\npara <code>statusCode === 200</code> temporariamente para causar o erro), vemos que a\nexceção não é pega no bloco <code>catch</code>; a execução do programa termina sem que\ntenhamos a oportunidade de tratar o erro. Isto se dá porque a exceção está sendo\njogada a partir de uma callback que se executa em outro contexto, mais adiante\nno tempo. Este <code>try...catch</code> só pega erros que possam ocorrer na parte síncrona\nda função, antes que seja feito o request.</p>\n<p>É por isso que as funções assíncronas evitam lançar erros com <code>throw</code> e sempre\ncomunicam os erros através de argumentos passados a <em>callbacks</em>, seja em uma\ncallback com vários argumentos onde o primeiro seja o possível erro, ou em\ncallbacks dedicadas, como por exemplo o <em>handler</em> que passamos por request no\nexemplo anterior:</p>\n<pre><code class=\"language-js\">http\n  .get(url, successCallback)\n  .on('error', errorCallback);\n</code></pre>\n<p>Agora sim, completemos nossa implementação de <code>getLatestNodeInfo()</code>, porém dessa\nvez passando os erros através da <em>callback</em> recebida do usuário ao invés de\nutilizar <code>throw</code>. Nota-se também que a implementação utiliza <code>try...catch</code>\ninternamente para cercar erros que poderiam acontecer durante o <em>parseamento</em> da\ndata recebida (utilizando <code>JSON.parse()</code>), que é uma operação síncrona que\ndevemos evitar que gere um erro, já que não poderia ser tratado de fora da\nfunção. Para solucionar isso, primeiro pegamos o erro e depois o devolvemos como\nargumento para a <em>callback</em>.</p>\n<pre><code class=\"language-js\">const getLatestNodeInfo = (cb) =>\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      return cb(new Error(`Request Failed. Status Code: ${statusCode}`));\n    } else if (!/^application\\/json/.test(headers['content-type'])) {\n      return cb(new Error(`Bad content-type. Expected application/json but got ${contentType}`));\n    }\n\n    let rawData = '';\n    resp.setEncoding('utf8');\n    resp.on('data', (chunk) => { rawData += chunk; });\n    resp.on('end', () => {\n      try {\n        const parsedData = JSON.parse(rawData);\n        cb(null, parsedData.shift());\n      } catch (err) {\n        cb(err);\n      }\n    });\n  }).on('error', cb);\n</code></pre>\n<p>Esta nova implementação nos assegura que os erros que possam ocorrer na função\nsempre sejam passados como argumentos para a <em>callback</em> recebida pelo usuário.</p>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "promises",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Errores en promesas",
              "body": "<p>A partir de ECMAScript 6, JavaScript incluye objetos <code>Promise</code> que nos permiten\ncontrolar el flujo de operaciones diferidas y asíncronas.</p>\n<p>Al igual que con los <em>callbacks</em>, a la hora de implementar <em>promesas</em> también\nevitamos arrojar errores con <code>throw</code>. En el caso de las promesas tenemos una\nserie de funciones dedicadas especícamente a manejar errores. Desde el punto de\nvista de la implementación de <em>promesas</em>, tenemos la función <code>reject</code> y en el\ncaso del consumo de promesas tenemos el método <code>promise.catch()</code>, así como la\nopción de un segundo argumento al método <code>promise.then(onSuccess, onError)</code>.</p>\n<p>Continuando con el ejemplo de la lectura anterior, modifiquemos nuestra\nimplementación de <code>getLatestNodeInfo()</code> para que retorne una promesa en vez de\nusar un simple <em>callback</em>:</p>\n<pre><code class=\"language-js\">const http = require('http');\n\nconst getLatestNodeInfo = () => new Promise((resolve, reject) => {\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      return reject(new Error(`Request Failed. Status Code: ${statusCode}`));\n    } else if (!/^application\\/json/.test(headers['content-type'])) {\n      return reject(new Error(`Bad content-type. Expected application/json but got ${contentType}`));\n    }\n\n    let rawData = '';\n    resp.setEncoding('utf8');\n    resp.on('data', (chunk) => { rawData += chunk; });\n    resp.on('end', () => {\n      try {\n        const parsedData = JSON.parse(rawData);\n        resolve(parsedData.shift());\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }).on('error', reject);\n});\n</code></pre>\n<p>En esta nueva implementación hemos reemplazado la invocaciones a <code>cb()</code> (el\n<em>callback</em> que recibíamos como argumento) con invocaciones a <code>reject()</code> (en los\ncasos de error) y <code>resolve()</code> (en caso de que completemos la tarea con éxito).\nEsto nos permitiría ahora invocar nuestra función <code>getLatestNodeInfo()</code> de la\nsiguiente manera:</p>\n<pre><code class=\"language-js\">getLatestNodeInfo()\n  .then(data => console.log(`Versión más reciente de Node.js: ${data.version}`))\n  .catch(err => console.error(err));\n</code></pre>\n<p>De forma equivalente podríamos haber escrito:</p>\n<pre><code class=\"language-js\">getLatestNodeInfo().then(\n  data => console.log(`Versión más reciente de Node.js: ${data.version}`),\n  err => console.error(err)\n);\n</code></pre>\n<h2>Manejo de errores en promesas encadenadas</h2>\n<p>Una de las grandes ventajas de las promesas es que podemos encadenarlas. Esto\nquiere decir que cuando invocamos el método <code>promise.then()</code> podemos retornar</p>\n<ul>\n<li>o un valor al que resuelve la promesa</li>\n<li>u otra promesa, que resolverá a otro valor</li>\n</ul>\n<p>El método <code>promise.then()</code> a su vez retorna una promesa sobre la cual podemos\nvolver a invocar <code>then</code> y recibe como argumento el valor al que haya resuelto\nel <code>then</code> anterior.</p>\n<p>Para ilustrar este concepto, modifiquemos otra vez nuestra implementación de\n<code>getLatestNodeInfo()</code> para que haga un poco menos de trabajo, y en vez de\nparsear el texto recibido con <code>JSON.parse</code> y de ahí seleccionar la última\nversión, hagamos que directamente devuelva el texto recibido. Aprovechamos a\ncambiarle el nombre a la función, ya que ahora ya no devuelve la última version\nsino info sobre todos los releases (en texto JSON sin parsear):</p>\n<pre><code class=\"language-js\">const getNodeReleases = () => new Promise((resolve, reject) => {\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      return reject(new Error(`Request Failed. Status Code: ${statusCode}`));\n    } else if (!/^application\\/json/.test(headers['content-type'])) {\n      return reject(new Error(`Bad content-type. Expected application/json but got ${contentType}`));\n    }\n\n    let rawData = '';\n    resp.setEncoding('utf8');\n    resp.on('data', (chunk) => { rawData += chunk; });\n    resp.on('end', () => resolve(rawData));\n  }).on('error', reject);\n});\n</code></pre>\n<p>Invoquemos nuestra nueva función <code>getNodeReleases()</code>:</p>\n<pre><code class=\"language-js\">getNodeReleases()\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n</code></pre>\n<p>Si no ocurre ningún error de red, esto debería resultar en que se invoque la\nfunción pasada a <code>.then()</code> con el texto recibido del request y no la pasada a\n<code>catch()</code>. El output debería ser algo así:</p>\n<pre><code class=\"language-text\">[\n{\"version\":\"v9.4.0\",\"date\":\"2018-01-10\",\"files\":[\"aix-ppc64\",\"headers\",\"linux-arm64\",\"linux-armv6l\",\"linux-armv7l\",\"linux-ppc64le\",\"linux-x64\",\"linux-x86\",\"osx-x64-pkg\",\"osx-x64-tar\",\"src\",\"sunos-x64\",\"sunos-x86\",\"win-x64-7z\",\"win-x64-exe\",\"win-x64-msi\",\"win-x64-zip\",\"win-x86-7z\",\"win-x86-exe\",\"win-x86-msi\",\"win-x86-zip\"],\"npm\":\"5.6.0\",\"v8\":\"6.2.414.46\",\"uv\":\"1.18.0\",\"zlib\":\"1.2.11\",\"openssl\":\"1.0.2n\",\"modules\":\"59\",\"lts\":false},\n{\"version\":\"v9.3.0\",\"date\":\"2017-12-12\",\"files\":[\"aix-ppc64\",\"headers\",\"linux-arm64\",\"linux-armv6l\",\"linux-armv7l\",\"linux-ppc64le\",\"linux-x64\",\"linux-x86\",\"osx-x64-pkg\",\"osx-x64-tar\",\"src\",\"sunos-x64\",\"sunos-x86\",\"win-x64-7z\",\"win-x64-exe\",\"win-x64-msi\",\"win-x64-zip\",\"win-x86-7z\",\"win-x86-exe\",\"win-x86-msi\",\"win-x86-zip\"],\"npm\":\"5.5.1\",\"v8\":\"6.2.414.46\",\"uv\":\"1.18.0\",\"zlib\":\"1.2.11\",\"openssl\":\"1.0.2n\",\"modules\":\"59\",\"lts\":false},\n...\n]\n</code></pre>\n<p>Ahora para recuperar la funcionalidad que teníamos antes, podemos encadenar\ninvocaciones a <code>.then()</code>, dónde cada una representa una transformación, que\npuede ser síncrona (simplemente retornando un valor) o asíncrona (retornando una\npromesa).</p>\n<pre><code class=\"language-js\">getNodeReleases()\n  .then(data => JSON.parse(data))\n  .then(data => data.shift())\n  .then(data => console.log(`Versión más reciente de Node.js: ${data.version}`))\n  .catch(err => console.error(err));\n</code></pre>\n<p>Lo interesante desde el punto de vista del manejo de errores es que solo\nnecesitamos un <code>.catch()</code>. Si cualquiera de los <code>.then()</code> retorna un error una\npromesa que resuelva a un error, directamente pasamos al <code>.catch()</code> (se hace\nun <em>corto circuito</em> que impide que los siguientes <code>.then()</code> se ejecuten).</p>\n<p>Para completar el ejemplo, re-implementemos la función <code>getLatestNodeInfo()</code>,\npero esta vez haciendo uso de nuestra nueva función <code>getNodeReleases()</code> y\nencadenando promesas.</p>\n<pre><code class=\"language-js\">const getLatestNodeInfo = () =>\n  getNodeReleases()\n    .then(data => JSON.parse(data))\n    .then(data => data.shift());\n</code></pre>\n<p>Esta nueva implementación simplemente encadena un par de transformaciones a\ntravés de promesas que resuelven directamente a un valor y retorna una promesa\nnueva, lo cual nos va a permitir usar la función <code>getLatestNodeInfo()</code> de la\nmisma manera que en el primer ejemplo de esta lectura:</p>\n<pre><code class=\"language-js\">getLatestNodeInfo()\n  .then(data => console.log(`Versión más reciente de Node.js: ${data.version}`))\n  .catch(err => console.error(err))\n</code></pre>\n<hr>\n<h2>Lecturas complemenentarias</h2>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises\">Promises - Jake Archibald - Google Developers</a></li>\n</ul>"
            },
            "pt": {
              "title": "Erros em promessas",
              "body": "<p>A partir do ECMAScript 6, o JavaScript incluiu objetos <code>Promise</code> que nos\npermitem controlar o fluxo de operações síncronas e assíncronas.</p>\n<p>Assim como com as <em>callbacks</em>, quando vamos implementar <em>promessas</em> também\nevitamos lançar erros com <code>throw</code>. No caso das promessas temos uma série de\nfunções dedicadas especialmente ao tratamento de erros. Do ponto de vista da\nimplementação de <em>promessas</em>, temos a função <code>reject</code> e no caso do consumo de\npromessas temos o mẽtodo <code>promise.catch()</code>, assim como a opção de um segundo\nargumento do método <code>promise.then(onSuccess, onError)</code>.</p>\n<p>Continuando com o exemplo da leitura anterior, modificamos nossa implementação\nde <code>getLatestNodeInfo()</code> para que retorne uma promessa ao invés de usar uma\n<em>callback</em> simples:</p>\n<pre><code class=\"language-js\">const http = require('http');\n\nconst getLatestNodeInfo = () => new Promise((resolve, reject) => {\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      return reject(new Error(`Request Failed. Status Code: ${statusCode}`));\n    } else if (!/^application\\/json/.test(headers['content-type'])) {\n      return reject(new Error(`Bad content-type. Expected application/json but got ${contentType}`));\n    }\n\n    let rawData = '';\n    resp.setEncoding('utf8');\n    resp.on('data', (chunk) => { rawData += chunk; });\n    resp.on('end', () => {\n      try {\n        const parsedData = JSON.parse(rawData);\n        resolve(parsedData.shift());\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }).on('error', reject);\n});\n</code></pre>\n<p>Nesta nova implementação nós substituímos as chamadas a <code>cb()</code> (a <em>callback</em> que\nrecebíamos como argumento) com chamadas para <code>reject()</code> (nos casos de erro) e\n<code>resolve()</code> (em caso de êxito). Isto no permite agora chamar nossa função\n<code>getLatestNodeInfo()</code> da seguinte maneira:</p>\n<pre><code class=\"language-js\">getLatestNodeInfo()\n  .then(data => console.log(`Versão mais recente de Node.js: ${data.version}`))\n  .catch(err => console.error(err));\n</code></pre>\n<p>Da mesma forma, poderíamos escrever:</p>\n<pre><code class=\"language-js\">getLatestNodeInfo().then(\n  data => console.log(`Versão mais recente de Node.js: ${data.version}`),\n  err => console.error(err)\n);\n</code></pre>\n<h2>Tratamento de erros em promessas encadeadas</h2>\n<p>Uma das grandes vantagens das promessas é que podemos encadeá-las. Isso quer\ndizer que, quando invocamos o método <code>promise.then()</code>, podemos retornar:</p>\n<ul>\n<li>ou um valor que resolve a promessa</li>\n<li>ou outra promessa, que resolverá outro valor</li>\n</ul>\n<p>O método<code>promise.then()</code>, por sua vez, retorna uma promessa sobre a qual podemos\ninvocar novamente <code>then</code> e recebe como argumento o valor resultado do <code>then</code>\nanterior.</p>\n<p>Para ilustrar este conceito, modifiquemos outra vez nossa implementação de\n<code>getLatestNodeInfo()</code> para que faça um pouco menos de trabalho, e ao invés de\nparsear o texto recebido com <code>JSON.parse</code> e de aí selecionar a última versão,\nfaçamos com que devolva diretamente o texto recebido. Aproveitamos para mudar o\nnome da função, que agora não devolve a última versão, mas sim informações sobre\ntodos os releases (em JSON sem parsear):</p>\n<pre><code class=\"language-js\">const getNodeReleases = () => new Promise((resolve, reject) => {\n  http.get('http://nodejs.org/dist/index.json', (resp) => {\n    const { statusCode, headers } = resp;\n\n    if (statusCode !== 200) {\n      return reject(new Error(`Request Failed. Status Code: ${statusCode}`));\n    } else if (!/^application\\/json/.test(headers['content-type'])) {\n      return reject(new Error(`Bad content-type. Expected application/json but got ${contentType}`));\n    }\n\n    let rawData = '';\n    resp.setEncoding('utf8');\n    resp.on('data', (chunk) => { rawData += chunk; });\n    resp.on('end', () => resolve(rawData));\n  }).on('error', reject);\n});\n</code></pre>\n<p>Vamos chamar nossa nova função <code>getNodeReleases()</code>:</p>\n<pre><code class=\"language-js\">getNodeReleases()\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n</code></pre>\n<p>Se não ocorrer nenhum erro de rede, isso deve resultar na invocação da função\npassada para <code>.then ()</code> com o texto recebido do request e não o último <code>catch ()</code>. A saída deve ser algo como isto:</p>\n<pre><code class=\"language-text\">[\n{\"version\":\"v9.4.0\",\"date\":\"2018-01-10\",\"files\":[\"aix-ppc64\",\"headers\",\"linux-arm64\",\"linux-armv6l\",\"linux-armv7l\",\"linux-ppc64le\",\"linux-x64\",\"linux-x86\",\"osx-x64-pkg\",\"osx-x64-tar\",\"src\",\"sunos-x64\",\"sunos-x86\",\"win-x64-7z\",\"win-x64-exe\",\"win-x64-msi\",\"win-x64-zip\",\"win-x86-7z\",\"win-x86-exe\",\"win-x86-msi\",\"win-x86-zip\"],\"npm\":\"5.6.0\",\"v8\":\"6.2.414.46\",\"uv\":\"1.18.0\",\"zlib\":\"1.2.11\",\"openssl\":\"1.0.2n\",\"modules\":\"59\",\"lts\":false},\n{\"version\":\"v9.3.0\",\"date\":\"2017-12-12\",\"files\":[\"aix-ppc64\",\"headers\",\"linux-arm64\",\"linux-armv6l\",\"linux-armv7l\",\"linux-ppc64le\",\"linux-x64\",\"linux-x86\",\"osx-x64-pkg\",\"osx-x64-tar\",\"src\",\"sunos-x64\",\"sunos-x86\",\"win-x64-7z\",\"win-x64-exe\",\"win-x64-msi\",\"win-x64-zip\",\"win-x86-7z\",\"win-x86-exe\",\"win-x86-msi\",\"win-x86-zip\"],\"npm\":\"5.5.1\",\"v8\":\"6.2.414.46\",\"uv\":\"1.18.0\",\"zlib\":\"1.2.11\",\"openssl\":\"1.0.2n\",\"modules\":\"59\",\"lts\":false},\n...\n]\n</code></pre>\n<p>Agora, para recuperar a funcionalidade que tínhamos antes, podemos encadear\nchamadas a <code>.then()</code>, onde cada uma representa uma transformação, que pode ser\nsíncrona (simplesmente retornando um valor) ou assíncrona (retornando uma\npromessa).</p>\n<pre><code class=\"language-js\">getNodeReleases()\n  .then(data => JSON.parse(data))\n  .then(data => data.shift())\n  .then(data => console.log(`Versão mais recente de Node.js: ${data.version}`))\n  .catch(err => console.error(err));\n</code></pre>\n<p>O interessante, do ponto de vista do tratamento de erros, é que só é necessário\num <code>.catch()</code>. Se qualquer um dos <code>.then ()</code> retornar um erro à promessa que\nresolve um erro, diretamente passamos para <code>.catch ()</code> (é feito um\n<em>curto-circuito</em> que impede o seguinte <code>.then ()</code> de executar).</p>\n<p>Para completar o exemplo, implantaremos novamente a função\n<code>getLatestNodeInfo()</code>, porém dessa vez fazendo uso de nessa nova função\n<code>getNodeReleases()</code> e encadeando promessas.</p>\n<pre><code class=\"language-js\">const getLatestNodeInfo = () =>\n  getNodeReleases()\n    .then(data => JSON.parse(data))\n    .then(data => data.shift());\n</code></pre>\n<p>Esta nova implementação simplesmente encadeia algumas transformações através de\npromessas que resolvem diretamente um valor e retornam uma promessa nova, o que\nnos permitirá usar a função <code>getLatestNodeInfo ()</code> da mesma forma que no\nprimeiro exemplo desta leitura:</p>\n<pre><code class=\"language-js\">getLatestNodeInfo()\n  .then(data => console.log(`Versión más reciente de Node.js: ${data.version}`))\n  .catch(err => console.error(err))\n</code></pre>\n<hr>\n<h2>Leituras complementares</h2>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises\">Promises - Jake Archibald - Google\nDevelopers</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "05",
          "slug": "practice",
          "type": "practice",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Ejercicios",
              "body": ""
            },
            "pt": {
              "title": "Exercícios",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "validate-string",
              "prefix": "01",
              "path": "topics/javascript/09-errors/05-practice/01-validate-string",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "validateString",
                  "body": "<p>Escribe una función que reciba un string como argumento y arroje los siguientes\nerrores:</p>\n<ul>\n<li><code>TypeError</code> con mensaje <code>El argumento str debe ser un string</code> cuando el\nargumento recibido no es de tipo <code>string</code>.</li>\n<li><code>RangeError</code> con mensaje <code>El argumento str debe tener al menos 4 caracteres</code>\ncuando el argumento recibido es un <code>string</code> de menos de 4 caracteres.</li>\n<li><code>RangeError</code> con mensaje\n<code>El argumento str debe tener un máximo de 10 caracteres</code> cuando el argumento\nrecibido tiene más de 10 caracteres.</li>\n</ul>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">// TypeError: El argumento str debe ser un string\nvalidateString();\n\n// RangeError: El argumento str debe tener al menos 4 caracteres\nvalidateString('');\nvalidateString('abc');\n\n// RangeError: El argumento str debe tener un máximo de 10 caracteres\nvalidateString('abcdefghijk');\nvalidateString('hola mundo cruel');\n</code></pre>"
                },
                "pt": {
                  "title": "validateString",
                  "body": "<p>Escreva uma função que receba uma string como argumento e lance os seguintes\nerros:</p>\n<ul>\n<li><code>TypeError</code> com a mensagem <code>O argumento str deve ser uma string</code> quando o\nargumento recebido não for do tipo <code>string</code>.</li>\n<li><code>RangeError</code> com a mensagem <code>O argumento str deve ter pelo menos 4 caracteres</code>\nquando o argumento recebido for uma <code>string</code> de menos de 4 caracteres.</li>\n<li><code>RangeError</code> com a mensagem <code>O argumento str deve ter no máximo 10 caracteres</code>\nquando o argumento recebido tiver mais de 10 caracteres.</li>\n</ul>\n<p>Exemplo:</p>\n<pre><code class=\"language-js\">// TypeError: O argumento str deve ser uma string\nvalidateString();\n\n// RangeError: O argumento str deve ter pelo menos 4 caracteres\nvalidateString('');\nvalidateString('abc');\n\n// RangeError: O argumento str deve ter no máximo 10 caracteres\nvalidateString('abcdefghijk');\nvalidateString('olá mundo cruel');\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/validateString.js": "module.exports = (str) => {\n  // ...\n};\n",
                "/solution/validateString.js": "module.exports = (str) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('El argumento str debe ser un string');\n  }\n\n  if (str.length < 4) {\n    throw new RangeError('El argumento str debe tener al menos 4 caracteres');\n  }\n\n  if (str.length > 10) {\n    throw new RangeError('El argumento str debe tener un máximo de 10 caracteres');\n  }\n\n  return str;\n};\n",
                "/test/validateString.spec.js": "const Assert = require('chai').assert;\nconst validateString = require('../solution/validateString');\n\n\ndescribe('validateString()', () => {\n  it('debería ser una función', () => {\n    Assert.equal(typeof validateString, 'function');\n  });\n\n  it('debería arrojar TypeError cuando argumento no es srting', () => {\n    Assert.throws(\n      () => validateString(),\n      TypeError,\n      'El argumento str debe ser un string',\n    );\n  });\n\n  it('debería arrojar RangeError cuando srting tiene menos de 4 caracteres', () => {\n    Assert.throws(\n      () => validateString(''),\n      RangeError,\n      'El argumento str debe tener al menos 4 caracteres',\n    );\n  });\n\n  it('debería arrojar RangeError cuando srting tiene más de 10 caracteres', () => {\n    Assert.throws(\n      () => validateString('abcdefghijk'),\n      RangeError,\n      'El argumento str debe tener un máximo de 10 caracteres',\n    );\n  });\n});\n"
              }
            },
            {
              "slug": "parse-json",
              "prefix": "02",
              "path": "topics/javascript/09-errors/05-practice/02-parse-json",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "parseJson",
                  "body": "<p>Implementa una función que reciba un string (en formato JSON) y retorne el JSON\nparseado (usando <code>JSON.parse</code>). La función no debe arrojar excepciones, a pesar\nde que <code>JSON.parse</code> puede arrojarlas. Si ocurriera una excepción al parsear el\nstring JSON, debemos evitar que se arroje el error y en vez hay que devolverlo\ncomo valor de retorno.</p>\n<h2>Ejemplo</h2>\n<pre><code class=\"language-js\">const result = parseJson('bad JSON');\nif (result instanceof Error) {\n  console.log('Ocurrión un error', err.message);\n}\n\n\nconst json = parseJson('{ \"foo\": true, \"bar\": \"baz\" }');\nconsole.log(json);\n// => { foo: true, bar: 'baz' }\n</code></pre>"
                },
                "pt": {
                  "title": "parseJson",
                  "body": "<p>Implementa uma função que receba uma string (no formato JSON) e retorne o JSON\nparseado (usando <code>JSON.parse</code>). A função não deve lançar exceções, porém\n<code>JSON.parse</code> poderá lançá-las. Se ocorrer uma exceção ao parsear a string JSON,\ndevemos evitar que seja lançado um erro, e sim devolvê-lo como valor de retorno.</p>\n<h2>Exemplo</h2>\n<pre><code class=\"language-js\">const result = parseJson('bad JSON');\nif (result instanceof Error) {\n  console.log('Ocorreu um erro', err.message);\n}\n\nconst json = parseJson('{ \"foo\": true, \"bar\": \"baz\" }');\nconsole.log(json);\n// => { foo: true, bar: 'baz' }\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/parseJson.js": "const parseJson = () => {\n  // Tu código acá\n};\n\nmodule.exports = parseJson;\n",
                "/solution/parseJson.js": "const parseJson = (str) => {\n  try {\n    return JSON.parse(str);\n  } catch (err) {\n    return err;\n  }\n};\n\nmodule.exports = parseJson;\n",
                "/test/parseJson.spec.js": "const Assert = require('chai').assert;\nconst parseJson = require('../solution/parseJson');\n\ndescribe('parseJson()', () => {\n  it('debería ser una función', () => {\n    Assert.equal(typeof parseJson, 'function');\n  });\n\n  it('debería devolver un error en vez de arrojarlo con JSON inválido', () => {\n    const result = parseJson();\n    Assert.ok(result instanceof  SyntaxError);\n  });\n\n  it('debería devolver JSON parseado cuando formato del string es ok', () => {\n    const result = parseJson('{ \"foo\": true, \"bar\": \"baz\" }');\n    Assert.deepEqual(result, { foo: true, bar: 'baz' });\n  });\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "07",
          "slug": "closing",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Cierre",
              "body": "<h2>Resumen</h2>\n<p>Llegamos al final de la unidad ;-)</p>\n<h2>Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Qué es el modo estricto en JavaScript</li>\n<li>Qué es un <code>Error</code> y tipos de errores</li>\n<li>Cómo usar <code>try...catch</code> para manejar errores</li>\n<li>Cómo manejar errores en callbacks</li>\n<li>Cómo manejar errores en promesas</li>\n</ul>"
            },
            "pt": {
              "title": "Encerramento",
              "body": "<h2>Resumo</h2>\n<p>Chegamos ao fim dessa unidade 😃</p>\n<h2>Vamos responder juntas às perguntas da abertura</h2>\n<ul>\n<li>O que é o modo estrito em JavaScript</li>\n<li>O que é um <code>Error</code> e tipos de erros</li>\n<li>Como usar <code>try...catch</code> para tratar erros</li>\n<li>Como tratar erros em callbacks</li>\n<li>Como tratar erros em promessas</li>\n</ul>"
            }
          }
        }
      ]
    },
    {
      "slug": "debugging",
      "intl": {
        "es": {
          "title": "Depuración (debugging)"
        },
        "pt": {
          "title": "Debugging"
        }
      },
      "prefix": "10",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Apertura: Debugging",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<p>En esta unidad aprenderemos sobre depuración (<code>debugging</code>):</p>\n<ul>\n<li>Por qué es importante saber depurar</li>\n<li>Qué debemos tener en cuenta para depurar código en JavaScript</li>\n<li>Qué herramienta del navegador nos puede ayudar a depurar código</li>\n</ul>\n<h2>Por qué aprender <code>debugging</code></h2>\n<p>La depuración es un aspecto importante en programación, trata de encontrar y\ncorregir diferentes tipos de errores que pueden suceder al momento de programar.</p>\n<h2>Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>¿Por qué es importante la depuración?</li>\n<li>¿Qué tipos de errores podemos encontrar en el desarrollo de software?</li>\n<li>¿Por qué es importante reconocer los mensajes de error? Identifica algunos\nque te hayan sucedido</li>\n<li>¿Qué es el Dev Tools?</li>\n<li>¿Qué son los breakpoints?</li>\n<li>¿Cómo depurar en el Dev Tools?</li>\n</ul>"
            },
            "pt": {
              "title": "Abertura: Debugging",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<p>Nesta unidade aprenderemos sobre depuração (<code>debugging</code>):</p>\n<ul>\n<li>Por que é importante saber depurar;</li>\n<li>O que devemos levar em conta para depurar código em JavaScript;</li>\n<li>Qual ferramenta do navegador pode nos ajudar a depurar código.</li>\n</ul>\n<h2>Por que aprender <code>debugging</code></h2>\n<p>A depuração é um aspecto importante em programação. Trata de encontrar e\ncorrigir diferentes tipos de erros que podem acontecer no momento de programar.</p>\n<h2>Guia de perguntas e conceitos chave</h2>\n<p>Quando começamos a estudar um tema novo, é útil termos uma ideia dos conceitos\nmais importantes que vamos aprender e dos temas centrais aos quais devemos\nprestar atenção especial.</p>\n<p>A seguir apresentamos uma série de perguntas que você deve ser capaz de\nresponder ao terminar esta unidade. Use estas perguntas como guia para orientar\nseu esforço de aprendizagem. Retorne a elas constantemente a medida que avança\npara validar que está indo na direção correta. Que este guia sirva como um\n\"checklist\" que você vai riscando conforme avança.</p>\n<ul>\n<li>Por que a depuração é importante?</li>\n<li>Que tipos de erros podemos encontrar no desenvolvimento de software?</li>\n<li>Por que é importante reconhecer as mensagens de erros? Identifique algumas que\nvocê já viu.</li>\n<li>O que é o Dev Tools?</li>\n<li>O que são <code>breakpoints</code>?</li>\n<li>Como depurar no Dev Tools?</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "intro",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "¿Qué es debugging?",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Representar gráficamente las distintas etapas de un proceso y sus iteraciones,\nfacilitando la comprensión de su funcionamiento.</li>\n<li>Conocer la utilidad  de los diagramas de flujo para analizar el proceso,\nproponer ideas, representar los controles, etc.</li>\n</ul>\n<hr>\n<p>Debugging es un proceso de identificación y resolución de errores (bugs). ¿A\nveces te has encontrado con la situación de realizar todo el código de un\nproyecto o script, luego lo pruebas y te das cuenta de que no funciona como\nesperabas? El paso siguiente, es volver a tu código y buscar la línea en la que\npuede estar fallando, ¿cierto?. Pues, dicho proceso es considerado <em>depuración</em>,\nencontrar ¿cuál es el error?, ¿porqué falla?, ¿cómo fue que falló?, ¿estará\nafectando otra parte del código?.</p>\n<p>Y su importancia, ya vista implícitamente, es que nos permite identificar\nerrores para ser solucionados, además de no ser víctimas de memes como:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*S6iw5QmBC2v_NbUzbrhwMw.jpeg\" alt=\"Curly Brace Bug\"></p>\n<h2>Tipos de Errores</h2>\n<p>Cuando hablamos de depuración, estamos hablando de errores y cuando programamos\nes muy probable que ocurran 2 tipos de errores: <em>errores de sintaxis</em> y\n<em>errores lógicos</em>.</p>\n<blockquote>\n<p>Un <strong>error de sintaxis</strong> se produce al escribir, incorrectamente, alguna parte\ndel código fuente de un programa. De forma que, dicho error impedirá, tanto al\ncompilador como al intérprete, traducir dicha instrucción, ya que, ninguno de\nlos dos entenderá qué le está diciendo el programador. — Wikipedia</p>\n</blockquote>\n<pre><code class=\"language-javascript\">/*\n * Errores de sintaxis\n */\n\n// Nombre de variable empezando con número\nconst 1cosa = 10;\n\n/*\n *\n * Error de operador:\n * = es asignación, mientras, == es comparación, y, === es comparación estricta\n *\n */\nif (numero = 0) {\n  console.log('Cero');\n} else if (numero > 0) {\n  /*\n   *\n   * Positivo debe de ir entre comillas debido a que es un string,\n   * y no una variable definida anteriormente\n   *\n   */\n  console.log(Positivo);\n} else {\n  /*\n   *\n   * `lo` no es un método del objeto `console`, el método deseado en este\n   * snippet es `console.log`\n   * Este tipo de errores que ocurren al momento de escribir es conocido\n   * como un `typo`\n   *\n   */\n  console.lo('Negativo');\n}\n</code></pre>\n<blockquote>\n<p>Los <strong>errores lógicos</strong> son errores que impiden que su programa haga lo que\nestaba previsto. Su código puede compilarse y ejecutarse sin errores, pero el\nresultado de una operación puede generar un resultado no esperado. — Microsoft\nDeveloper Network</p>\n</blockquote>\n<pre><code class=\"language-javascript\">/*\n * Error lógico\n */\n\n// Función que espera 2 números como parámetros para devolver la suma de ambos\nconst suma = (num1, num2) => num1 + num2;\n\n// Imaginemos que el número 1 es 6\nconst num1 = prompt('Ingrese el número 1');\n\n// Imaginemos que el número 2 es 4\nconst num2 = prompt('Ingrese el número 2');\n\nconst resultado = suma(num1, num2);\n\n// Resultado esperado: 10\n// Resultado obtenido: \"64\"\nconsole.log(resultado);\n\n/*\n *\n * El error que ocurre en este snippet es que todo lo que ingresa el usuario\n * mediante un prompt es un string, y debemos de considerarlo para obtener el\n * resultado que esperamos.\n * En este caso, tendríamos que convertir el tipo de dato de string a número.\n *\n */\n</code></pre>"
            },
            "pt": {
              "title": "O que é debugging?",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Representar graficamente as diferentes etapas de um processo e suas iterações,\nfacilitando a compreensão de seu funcionamento.</li>\n<li>Conhecer a utilidade dos diagramas de fluxo para analisar o processo, propor\nideias, representar os controles, etc.</li>\n</ul>\n<hr>\n<p><em>Debugging</em> é um processo de identificação e resolução de erros (<em>bugs</em>). Você\njá se deparou com a situação de programar todo o código de um projeto ou script,\ntestá-lo e perceber que não funciona como o esperado? O passo seguinte é\nretornar ao código e procurar a linha que pode estar errada, certo? Então, esse\nprocesso é chamado de <em>depuração</em>. Qual é o erro? Por que acontece o erro? Como\naconteceu o erro? Vai prejudicar outra parte do código?</p>\n<p>E sua importância, já vista implicitamente, é que permite identificar os erros a\nserem resolvidos e não ser vítimas de memes como esse:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*S6iw5QmBC2v_NbUzbrhwMw.jpeg\" alt=\"Curly Brace\nBug\"></p>\n<h2>Tipos de Erros</h2>\n<p>Quando falamos de depuração, estamos falando de erros e quando programamos é\nmuito provável que aconteçam dois tipos de erros: <em>erros de sintaxe</em> e <em>erros\nlógicos</em>.</p>\n<blockquote>\n<p>Um <strong>erro de sintaxe</strong> é gerado ao escrever, incorretamente, alguma parte do\ncódigo fonte do programa. Esse erro impedirá, tanto ao compilador como ao\nintérprete, traduzir aquela instrução, já que nenhum dos dois entenderá o que\no programador está dizendo. — Wikipedia</p>\n</blockquote>\n<pre><code class=\"language-javascript\">/*\n * Erros de sintaxe:\n */\n\n// Nome da variável começando com número\nconst 1cosa = 10;\n\n/*\n *\n * Erro de operador:\n * '=' é atribuição enquanto que '==' é comparação e '===' é comparação estrita.\n *\n */\nif (numero = 0) {\n  console.log('Zero');\n} else if (numero > 0) {\n  /*\n   *\n   * Positivo deve ser entre aspas pois é uma string\n   * e não uma variável definida anteriormente.\n   *\n   */\n  console.log(positivo);\n} else {\n  /*\n   *\n   * `lo` não é um método do objeto `console`. O método desejado neste\n   * snippet é `console.log`.\n   * Este tipo de erro que ocorre no momento de escrever é conhecido\n   * como um `typo`.\n   *\n   */\n  console.lo('Negativo');\n}\n</code></pre>\n<blockquote>\n<p>Os <strong>erros lógicos</strong> são erros que impedem que seu programa faça o que estava\nprevisto. Seu código pode compilar e executar sem erros, mas o resultado da\noperação pode gerar um resultado inesperado. — Microsoft Developer Network.</p>\n</blockquote>\n<pre><code class=\"language-javascript\">/*\n * Erro lógico\n */\n\n// Função que espera 2 números como parâmetros para retornar a soma de ambos.\nconst soma = (num1, num2) => num1 + num2;\n\n// Imaginemos que o número 1 é 6.\nconst num1 = prompt('Digite o número 1');\n\n// Imaginemos que o número 2 é 4.\nconst num2 = prompt('Digite o número 2');\n\nconst resultado = soma(num1, num2);\n\n// Resultado esperado: 10.\n// Resultado obtido: \"64\".\nconsole.log(resultado);\n\n/*\n *\n * O erro que acontece neste snippet é que tudo que o usuário digita por um prompt é\n * uma string e devemos considerar isso para obter o resultado desejado.\n * Neste caso, teríamos que converter o tipo de dado de string para número.\n *\n */\n</code></pre>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "error-messages",
          "type": "read",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Mensajes de error",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Conocer los tipos diferentes de mensajes de error y el vocabulario en esos\nmensajes para resolver problemas en el código.</li>\n</ul>\n<hr>\n<p>Todos comenten errores, incluso programadores con mucha experiencia.\nAfortunadamente, la consola del Dev Tools te dirá cuando tienes un error.\nPor otro lado, estos mensajes pueden ser difícil de comprender, y a veces\nno es tan obvio que significan. El propósito de este lectura es explorar algunos\nerrores comunes y sus significados, y así resuelvas problemas en el código.</p>\n<h2>Errores Comunes</h2>\n<p>Hay muchos tipos de errores, pero hay algunos que son muy comunes. Lee estas\nreferencias para comprender los errores más comunes.</p>\n<h3>ReferenceError: \"x\" is not defined</h3>\n<p><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Errors/Not_defined\">ReferenceError: \"x\" is not defined - MDN</a></p>\n<h3>SyntaxError: Unexpected token</h3>\n<p>Un \"token\" es una pieza pequeña del código. Por ejemplo, variables, funciones,\noperadores, y palabras claves (como <code>if</code> o <code>while</code>), todos son tokens.</p>\n<p>La palabra \"unexpected\" significa \"inesperado\", entonces si tienes un token\ninesperado, significa que el navegador estaba leyendo el código hasta que llegó\na algo que no debe estar ahí. Usualmente, esto significa que algo hace falta\n(como una coma o un <code>+</code>) justo antes del token inesperado.</p>\n<p><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Errors/Unexpected_token\">SyntaxError: Unexpected token - MDN</a></p>\n<p>Ejemplos:</p>\n<pre><code class=\"language-javascript\">const foo = 'Nicole's code';\n// SyntaxError: unexpected token: identifier\n</code></pre>\n<pre><code class=\"language-javascript\">const list = [1, 2,\n\nconst instruments = [\n  'Ukulele',\n  'Guitar',\n  'Piano'\n};\n// SyntaxError: expected expression, got keyword 'const'\n</code></pre>\n<pre><code class=\"language-javascript\">const data = [{foo: 'bar'} {bar: 'foo'}];\n// SyntaxError: missing ] after element list\n</code></pre>\n<p>A veces, en lugar de \"Unexpected Token\", verás algo como \"Unexpected Identifier\"\no \"Unexpected Number\". Estos son errores similares, y también casi siempre\nsignifica que olvidaste agregar algo justo antes del\ntoken inesperado. Afortunadamente, Chrome DevTools te dirá el número de la linea\ndonde tengas el error, y repl.it no solo te dirá el número de la linea, sino\ntambién te dirá el número de la columna.</p>\n<p><img src=\"img-line-number.png\" alt=\"repl.it screenshot\"></p>\n<h3>TypeError: \"x\" is not a function</h3>\n<p><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Errors/Not_a_function\">TypeError: \"x\" is not a function - MDN</a></p>\n<h3>SyntaxError: missing ) after argument list</h3>\n<p><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Errors/Missing_parenthesis_after_argument_list\">SyntaxError: missing ) after argument list - MDN</a></p>\n<h3>Assignment in Conditional Expression</h3>\n<p>\"Assignment in Conditional Expression\" no es un mensaje de error, es un mensaje\nde advertencia en repl.it.</p>\n<p>Significa que hay un operador de asignación (<code>=</code>) en una condicional, pero debe\nser un operador de comparación (<code>===</code>).</p>\n<p>Por ejemplo,</p>\n<pre><code class=\"language-javascript\">if (x = 5) {\n  console.log('x es 5.');\n}\n</code></pre>\n<h3>Otras notas</h3>\n<p>Es importante tener en cuenta que los mensajes de error pueden variar entre\nnavegadores. La guía de referencia MDN describe mensajes de Firefox - los\nmensajes de error en otros navegadores son similares, pero no exactamente el\nmismo. En este lectura, nos enfocamos en los mensajes de Chrome y repl.it.</p>\n<p><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Errors\">Referencia MDN de Errores</a></p>"
            },
            "pt": {
              "title": "Mensagens de erro",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Conhecer os diferentes tipos de mensagens de erro e o vocabulário dessas\nmensagens para resolver os problemas no código.</li>\n</ul>\n<hr>\n<p>Todos cometem erros, inclusive programadores com muita experiência. Felizmente,\no console de Dev Tools dirá quando um erro acontece. Por outro lado, estas\nmensagens podem ser difíceis de compreender e às vezes seus significados não são\ntão óbvios. O objetivo desta leitura é explorar alguns erros comuns e seus\nsignificados e assim resolver problemas no código.</p>\n<h2>Erros comuns</h2>\n<p>Há muitos tipos de erros, mas há alguns que são mais comuns. Leia estas\nreferências para compreender os erros mais comuns.</p>\n<h3>ReferenceError: \"x\" is not defined</h3>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Errors/N%C3%A3o_definido\">ReferenceError: \"x\" is not defined -\nMDN</a></p>\n<h3>SyntaxError: Unexpected token</h3>\n<p>Um \"token\" é uma peça pequena do código. Por exemplo, variáveis, funções,\noperadores e palavras chave (como <code>if</code> ou <code>while</code>), todos são tokens.</p>\n<p>A palavra \"unexpected\" significa \"inesperado\". Logo, se você tiver um token\ninesperado significa que o navegador estava lendo o código até que chegou a algo\nque não deveria esta ali. Usualmente isso significa que está faltando algo (como\numa vírgula ou um <code>+</code>) logo antes do token inesperado.</p>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Errors/Unexpected_token\">SyntaxError: Unexpected token -\nMDN</a></p>\n<p>Exemplos:</p>\n<pre><code class=\"language-javascript\">const foo = 'Nicole's code';\n// SyntaxError: unexpected token: identifier\n</code></pre>\n<pre><code class=\"language-javascript\">const list = [1, 2,\n\nconst instruments = [\n  'Ukulele',\n  'Guitar',\n  'Piano'.\n};\n// SyntaxError: expected expression, got keyword 'const'\n</code></pre>\n<pre><code class=\"language-javascript\">const data = [{foo: 'bar'} {bar: 'foo'}];\n// SyntaxError: missing ] after element list\n</code></pre>\n<p>Às vezes, ao invés de \"Unexpected Token\", será exibido algo como \"Unexpected\nIdentifier\" ou \"Unexpected Number\". Estes são erros similares e também quase\nsempre significam que você esqueceu de adicionar algo logo antes do token\ninesperado. Felizmente, Chrome DevTools dirá o número da linha na qual está o\nerro e <code>repl.it</code> dirá não só o número da linha como também o número da coluna.</p>\n<p><img src=\"https://user-images.githubusercontent.com/11894994/62891126-4d4a6a80-bd1b-11e9-9087-2f1c5dd898d6.png\" alt=\"repl.it screenshot\">.</p>\n<h3>TypeError: \"x\" is not a function</h3>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Errors/Not_a_function\">TypeError: \"x\" is not a function -\nMDN</a></p>\n<h3>SyntaxError: missing ) after argument list</h3>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Errors/Fata_par%C3%AAnteses_ap%C3%B3s_lista_argumento\">SyntaxError: missing ) after argument list -\nMDN</a></p>\n<h3>Assignment in Conditional Expression</h3>\n<p>\"Assignment in Conditional Expression\" não é uma mensagem de erro. É uma\nadvertência de <code>repl.it</code>.</p>\n<p>Significa que existe um operador de atribuição (<code>=</code>) em uma condição, mas\ndeveria ser um operador de comparação(<code>===</code>).</p>\n<p>Por exemplo,</p>\n<pre><code class=\"language-javascript\">if (x = 5) {\n  console.log('x es 5.');\n}\n</code></pre>\n<h3>Outras notas</h3>\n<p>É importante considerar que as mensagens de erros podem variar entre os\nnavegadores. O guia de referência do MDN descreve mensagens do Firefox. As\nmensagens de erros dos outros navegadores são similares, mas não exatamente as\nmesmas. Nesta leitura, focamos nas mensagens do Chrome e <code>repl.it</code>.</p>\n<p><a href=\"https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Errors\">Referência MDN de\nErros</a></p>"
            }
          }
        },
        {
          "prefix": "03",
          "slug": "code-challenges",
          "type": "practice",
          "duration": 60,
          "intl": {
            "es": {
              "title": "Retos de código",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>A continuación te presentamos una serie de retos que debes completar para\nponer tus conocimientos a prueba.</li>\n</ul>"
            },
            "pt": {
              "title": "Desafios de código",
              "body": "<h2>Objetivos</h2>\n<ul>\n<li>A seguir apresentamos uma série de desafios que você deve completar para\ntestar seus conhecimentos.</li>\n</ul>"
            }
          },
          "challenges": [
            {
              "slug": "say-hello",
              "prefix": "01",
              "path": "topics/javascript/10-debugging/03-code-challenges/01-say-hello",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "sayHello",
                  "body": "<p>Corrige los errores en la función y explique cuál fue el problema en un\ncomentario.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-javascript\">sayHello(); // --> 'Hola'\n</code></pre>"
                },
                "pt": {
                  "title": "sayHello",
                  "body": "<p>Corrija os erros na função e explique em um comentário qual foi o problema.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">sayHello(); // --> 'Olá'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/sayHello.js": "const sayHello = () => {\n  console.log(Hola);\n};\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * ESCRIBA SU RESPUESTA AQUÍ.\n */\n\nmodule.exports = sayHello;\n",
                "/solution/sayHello.js": "const sayHello = () => {\n  console.log('Hola');\n};\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * A la palabra 'hola' le faltaban comillas.\n */\n\nmodule.exports = sayHello;\n",
                "/test/sayHello.spec.js": "const Assert = require('chai').assert;\nconst sayHello = require('../solution/sayHello');\n\ndescribe('sayHello()', () => {\n  it('debería regresar undefined, para ()', () => {\n    Assert.deepEqual(sayHello(), undefined);\n  });\n});\n"
              }
            },
            {
              "slug": "create-array",
              "prefix": "02",
              "path": "topics/javascript/10-debugging/03-code-challenges/02-create-array",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "createArray",
                  "body": "<p>Corrige los errores en la función y explique cuál fue el problema en un\ncomentario.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const a = createArray();\nconsole.log(a); // --> [1, 2, 3]\n</code></pre>"
                },
                "pt": {
                  "title": "createArray",
                  "body": "<p>Corrija os erros na função e explique em um comentário qual foi o problema.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const a = createArray();\nconsole.log(a); // --> [1, 2, 3]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/createArray.js": "function createArray() {\n  const data = [1 2 3];\n}\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * ESCRIBA SU RESPUESTA AQUÍ.\n */\n\nmodule.exports = createArray;\n",
                "/solution/createArray.js": "function createArray() {\n  const data = [1, 2, 3];\n  return data;\n}\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * Al arreglo le faltaban dos comas.\n */\n\nmodule.exports = createArray;\n",
                "/test/createArray.spec.js": "const Assert = require('chai').assert;\nconst createArray = require('../solution/createArray');\n\ndescribe('createArray()', () => {\n  it('debería regresar [1, 2, 3], para ()', () => {\n    Assert.deepEqual(createArray(), [1, 2, 3]);\n  });\n});\n"
              }
            },
            {
              "slug": "calculate-tip",
              "prefix": "03",
              "path": "topics/javascript/10-debugging/03-code-challenges/03-calculate-tip",
              "createdAt": "2024-02-08T16:56:33.613Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "ReferenceError: calculateTip",
                  "body": "<p>Corrige los errores en la función y explique cuál fue el problema en un\ncomentario.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const tip = calculateTip(100);\nconsole.log(tip); // --> 15\n</code></pre>"
                },
                "pt": {
                  "title": "ReferenceError: calculateTip",
                  "body": "<p>Corrija os erros na função e explique em um comentário qual foi o problema.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">const tip = calculateTip(100);\nconsole.log(tip); // --> 15\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/calculateTip.js": "/* Regresa num1 por ciento de num2. */\nconst percent = (num1, num2) => num1 * 100 / num2;\n\nconst calculateTip = billAmount => percent(15, billAmount);\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * ESCRIBA SU RESPUESTA AQUÍ.\n */\n\nmodule.exports = calculateTip;\n",
                "/solution/calculateTip.js": "/* Regresa num1 por ciento de num2. */\nconst percent = (num1, num2) => num1 * num2 / 100;\n\nconst calculateTip = billAmount => percent(15, billAmount);\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * La variable en la línea 11 tiene el mismo nombre que la función en la línea\n * 2.\n */\n\nmodule.exports = calculateTip;\n",
                "/test/calculateTip.spec.js": "const Assert = require('chai').assert;\nconst calculateTip = require('../solution/calculateTip');\n\ndescribe('calculateTip()', () => {\n  it('debería regresar 15, para (100)', () => {\n    Assert.deepEqual(calculateTip(100), 15);\n  });\n\n  it('debería regresar 4.5, para (30)', () => {\n    Assert.deepEqual(calculateTip(30), 4.5);\n  });\n\n  it('debería regresar 0, para (0)', () => {\n    Assert.deepEqual(calculateTip(0), 0);\n  });\n\n  it('debería regresar 7.5, para (50)', () => {\n    Assert.deepEqual(calculateTip(50), 7.5);\n  });\n});\n"
              }
            },
            {
              "slug": "tell-fortune",
              "prefix": "04",
              "path": "topics/javascript/10-debugging/03-code-challenges/04-tell-fortune",
              "createdAt": "2024-02-08T16:56:33.613Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "tellFortune",
                  "body": "<p>Corrige los errores en la función y explique cuál fue el problema en un\ncomentario.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-javascript\">tellFortune('scientist', 'Boston');\n// --> 'In the year 2025, you will be a scientist and live in Boston.'\n</code></pre>"
                },
                "pt": {
                  "title": "tellFortune",
                  "body": "<p>Corrija os erros na função e explique em um comentário qual foi o problema.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-javascript\">tellFortune('scientist', 'Boston');\n// --> 'In the year 2025, you will be a scientist and live in Boston.'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/tellFortune.js": "function tellFortune(job, location) {\n  return 'In the year 2025, you will be a ' + job ' and live in ' + location + '.';\n}\n/**\n * ¿Cuál fue el problema con el código?\n *\n * ESCRIBA SU RESPUESTA AQUÍ.\n */\n\nmodule.exports = tellFortune;\n",
                "/solution/tellFortune.js": "function tellFortune(job, location) {\n  return 'In the year 2025, you will be a ' + job + ' and live in ' + location + '.';\n}\n/**\n * ¿Cuál fue el problema con el código?\n *\n * A la linea 2 le faltaba un plus.\n */\n\nmodule.exports = tellFortune;\n",
                "/test/tellFortune.spec.js": "const Assert = require('chai').assert;\nconst tellFortune = require('../solution/tellFortune');\n\ndescribe('tellFortune()', () => {\n  it('debería regresar \"In the year 2025, you will be a programmer and live in Lima.\", para (\"programmer\", \"Lima\")', () => {\n    Assert.deepEqual(tellFortune('programmer', 'Lima'), 'In the year 2025, you will be a programmer and live in Lima.');\n  });\n\n  it('debería regresar \"In the year 2025, you will be a scientist and live in Boston.\", para (\"scientist\", \"Boston\")', () => {\n    Assert.deepEqual(tellFortune('scientist', 'Boston'), 'In the year 2025, you will be a scientist and live in Boston.');\n  });\n\n  it('debería regresar \"In the year 2025, you will be a singer and live in Madrid.\", para (\"singer\", \"Madrid\")', () => {\n    Assert.deepEqual(tellFortune('singer', 'Madrid'), 'In the year 2025, you will be a singer and live in Madrid.');\n  });\n\n  it('debería regresar \"In the year 2025, you will be a farmer and live in Fiji.\", para (\"farmer\", \"Fiji\")', () => {\n    Assert.deepEqual(tellFortune('farmer', 'Fiji'), 'In the year 2025, you will be a farmer and live in Fiji.');\n  });\n});\n"
              }
            },
            {
              "slug": "what-to-wear",
              "prefix": "05",
              "path": "topics/javascript/10-debugging/03-code-challenges/05-what-to-wear",
              "createdAt": "2024-02-08T16:56:33.612Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "ReferenceError: whatToWear",
                  "body": "<p>Corrige los errores en la función y explique cuál fue el problema en un\ncomentario.</p>\n<p>Ejemplo de entrada:</p>\n<pre><code class=\"language-js\">const winterClothes = whatToWear('winter');\nconsole.log(winterClothes); // --> 'Bring a hat and gloves.'\n</code></pre>"
                },
                "pt": {
                  "title": "ReferenceError: whatToWear",
                  "body": "<p>Corrija os erros na função e explique em um comentário qual foi o problema.</p>\n<p>Exemplo de entrada:</p>\n<pre><code class=\"language-js\">const winterClothes = whatToWear('winter');\nconsole.log(winterClothes); // --> 'Bring a hat and gloves.'\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/whatToWear.js": "function whatToWear(season) {\n  if (season = 'spring') {\n    return 'Bring an umbrella.';\n  } else if (season = 'summer') {\n    return 'Wear sunglasses.';\n  } else if (season = 'autumn') {\n    return 'Wear a light jacket.';\n  } else if (season = 'winter') {\n    return 'Bring a hat and gloves.';\n  } else {\n    return 'Please enter a valid season.';\n  }\n}\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * ESCRIBA SU RESPUESTA AQUÍ.\n */\n\nmodule.exports = whatToWear;\n",
                "/solution/whatToWear.js": "function whatToWear(season) {\n  if (season === 'spring') {\n    return 'Bring an umbrella.';\n  } else if (season === 'summer') {\n    return 'Wear sunglasses.';\n  } else if (season === 'autumn') {\n    return 'Wear a light jacket.';\n  } else if (season === 'winter') {\n    return 'Bring a hat and gloves.';\n  } else {\n    return 'Please enter a valid season.';\n  }\n}\n\n/**\n * ¿Cuál fue el problema con el código?\n *\n * Usaba operador de asignación en vez de comparación.\n */\n\nmodule.exports = whatToWear;\n",
                "/test/whatToWear.spec.js": "\nconst Assert = require('chai').assert;\nconst whatToWear = require('../solution/whatToWear');\n\ndescribe('whatToWear()', () => {\n  it('debería regresar \"Bring an umbrella.\", para (\"spring\")', () => {\n    Assert.deepEqual(whatToWear('spring'), 'Bring an umbrella.');\n  });\n\n  it('debería regresar \"Wear sunglasses.\", para (\"summer\")', () => {\n    Assert.deepEqual(whatToWear('summer'), 'Wear sunglasses.');\n  });\n\n  it('debería regresar \"Wear a light jacket.\", para (\"autumn\")', () => {\n    Assert.deepEqual(whatToWear('autumn'), 'Wear a light jacket.');\n  });\n\n  it('debería regresar \"Bring a hat and gloves.\", para (\"winter\")', () => {\n    Assert.deepEqual(whatToWear('winter'), 'Bring a hat and gloves.');\n  });\n\n  it('debería regresar \"Please enter a valid season.\", para (\"foo\")', () => {\n    Assert.deepEqual(whatToWear('foo'), 'Please enter a valid season.');\n  });\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "04",
          "slug": "breakpoints",
          "type": "read",
          "duration": 40,
          "intl": {
            "es": {
              "title": "¿Cómo debuggear en JS?",
              "body": "<h2>Objetivos de Aprendizaje</h2>\n<ul>\n<li>Aprender a depurar a través del Dev Tools</li>\n<li>Aprender a usar el <code>debugger statement</code></li>\n</ul>\n<hr>\n<p>Para depurar en JavaScript podemos hacer uso de 2 herramientas: DevTools del\nnavegador y el debugger statement.</p>\n<h2>DevTools</h2>\n<p>El DevTools (así se llama en Chrome pero existe lo mismo en otros navegadores)\nes una herramienta usada para la inspección y depuración de todo lo que ocurre\nen nuestra aplicación web.</p>\n<p>Para acceder a ella existen diversos métodos, uno de los más sencillos es abrir\nla web app que deseas depurar, dar clic derecho en cualquier parte de dicha\npágina y seleccionar la opción <em>Inspect</em> o <em>Inspeccionar</em>.</p>\n<p>Por defecto, abrirá en una pestaña llamada Elements o Elementos; sin embargo,\npara hacer debug de nuestro código JavaScript debemos de cambiar a la pestaña\n<em>Sources</em> o <em>Fuente</em>.</p>\n<p>Probablemente, al ver el contenido de la pestaña <em>Sources</em>, solo verás un\narchivo HTML y ningún archivo JS por más que sepamos que si se está usando. Para\npoder visualizar los archivos JS que usa nuestra web app, solo es necesario\nrecargar la página.</p>\n<p>¿No te quedó claro lo anterior? No te preocupes, a continuación verás un GIF en\nel cual muestra todo lo mencionado anteriormente.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*JhVFiJNoGZAAmlnk00y6TA.gif\" alt=\"Chrome Dev Tools: Sources\"></p>\n<p>Para la depuración del código JS, podemos hacer uso de <strong>breakpoints</strong>, que son\npuntos donde queremos que nuestro código se detenga en tiempo de ejecución.</p>\n<p>En el siguiente ejemplo, tenemos un código que verifica si el número ingresado\npor un usuario es cero, positivo o negativo.</p>\n<pre><code class=\"language-javascript\">let number = prompt('Ingrese un número');\nnumber = Number(numero);\n\nif (number === 0) {\n  alert('Cero');\n} else if (number > 0) {\n  alert('Positivo');\n} else {\n  alert('Negativo');\n}\n</code></pre>\n<p>Para poner un breakpoint en el DevTools solo tienes que dar clic en el número\nque indica la línea de código donde queremos detener el script. Una vez puesto\nel breakpoint debemos de recargar la página para que se detenga donde le\nindicamos.</p>\n<p>Una vez detenido, la línea de código donde pusimos el breakpoint se sombreará,\nmientras que la web se pondrá opaco y mostrará un mensaje <em>Paused in debugger</em>\njunto a 2 botones, el primero (color azul) llamado <em>Resume Script Execution</em>\nhace referencia a seguir la ejecución hasta un siguiente breakpoint o hasta que\ntermine el script, y el segundo (color gris) llamado <em>Step over next function call</em>\nrefiere a seguir el flujo de ejecución del programa.</p>\n<p>A continuación puedes ver lo mencionado en un GIF:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*DbS6jAUYz3mPJjyv8MMU-w.gif\" alt=\"Chrome Dev Tools: Breakpoints\"></p>\n<p>Un par de botones que nos ayudan a depurar nuestro código son:\n<em>Step into next function call</em> y <em>Step out of current function</em>. El primero lo\nque nos permite es ingresar al código de una función que usamos en tiempo de\nejecución, mientras que el segundo nos permite salir de la función en la que\nnos encontramos depurando.</p>\n<p>En el siguiente ejemplo, si tuviéramos un breakpoint en la línea 8, y usáramos\nel botón de <em>Step over next function</em>, se iría hacia la línea 9; no obstante, si\nusamos el botón de <em>Step into next function call</em>, ingresaría a la línea de\ncódigo número 2 ya que es el código que está dentro de nuestra función.</p>\n<p>Es momento de probarlo:</p>\n<pre><code class=\"language-javascript\">function factorial(number) {\n  if (number === 1) {\n    return 1;\n  }\n  return number * factorial(number - 1);\n}\n\nconst result = factorial(5);\nconsole.log(result);\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*C3k9ZTu-q9i8GFB2P47muQ.gif\" alt=\"Chrome Dev Tools: Debugging\"></p>\n<h2>Debugger Statement</h2>\n<p>El segundo método para depurar un código es usando una palabra reservada en JS\nllamada <code>debugger</code>. Esta sentencia lo que nos permite es especificar en el\ncódigo la línea exacta donde queremos que se detenga nuestra aplicación web para\nser depurada.</p>\n<blockquote>\n<p>Nota: Para que el script se detenga en la sentencia debugger debemos de tener\nel Dev Tools abierto y luego recargar la página.</p>\n</blockquote>\n<p>A continuación una demostración usando el siguiente script:</p>\n<pre><code class=\"language-javascript\">const number = parseInt(prompt('Ingresa un número (del 1 al 10):'));\nconst randomNumber = Math.floor(Math.random() * 10);\n\ndebugger;\nif (randomNumber === number) {\n    console.log('Adivinaste!');\n} else {\n    console.log('Perdiste! El número es ' + randomNumber);\n}\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*RcPHfLBSK1Bh8FzfqJlqpQ.gif\" alt=\"Debugger statement\"></p>\n<h2>Ahora es tu turno</h2>\n<p>Para poner en práctica esta lectura, puedes depurar el siguiente código:</p>\n<pre><code class=\"language-javascript\">/*\n * Corrige el siguiente código de tal forma que obtengas el resultado esperado,\n * usa las técnicas de depuración que conoces para encontrar y solucionar\n * el error.\n */\n\nconst reverse = (text) => {\n  let reversedText = '';\n  const textLength = text.length;\n\n  for (let i = textLength; i > 0; i--) {\n    reversedText += text.charAt(i);\n  }\n\n  return reversedText;\n};\n\nconst result = reverse('Laboratoria');\n// Resultado actual: airotaroba\n// Resultado esperado: airotarobaL\nconsole.log(result);\n\n// HINT: Son 2 cambios para que quede correctamente ;)\n</code></pre>\n<p>Así que a partir de ahora…</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*znr2Wn2kXro7XkimgplRCg.jpeg\" alt=\"Debug all the things\"></p>"
            },
            "pt": {
              "title": "Como debuggar em JS?",
              "body": "<h2>Objetivos de Aprendizagem</h2>\n<ul>\n<li>Aprender a depurar com o Dev Tools.</li>\n<li>Aprender a usar o <code>debugger statement</code>.</li>\n</ul>\n<hr>\n<p>Para depurar em JavaScript podemos utilizar 2 ferramentas: DevTools do navegador\ne o <code>debugger statement</code>.</p>\n<h2>DevTools</h2>\n<p>O DevTools (é chamado assim no Chrome mas existe o mesmo em outros navegadores)\né uma ferramenta utilizada para inspecionar e depurar tudo o que acontece em\nnossa aplicação web.</p>\n<p>Para acessá-la existem diversos métodos. Um dos mais simples é abrir a página\nweb que você deseja depurar, clicar com o botão direito em qualquer parte da\npágina e selecionar a opção <em>Inspect</em> ou <em>Inspecionar</em>.</p>\n<p>Por padrão, será aberta uma aba chamada <em>Elements</em> ou <em>Elementos</em>; contudo, para\nfazer o debug de nosso código JavaScript devemos mudar para a aba <em>Sources</em> ou\n<em>Fonte</em>.</p>\n<p>Provavelmente, ao ver o conteúdo da aba <em>Sources</em>, você verá um arquivo HTML e\nnenhum arquivo JS por mais que saibamos o que estamos utilizando. Para poder\nvisualizar os arquivos JS que nossa web app utiliza, só é necessário recarregar\na página.</p>\n<p>Não ficou claro? Não se preocupe. Em seguida temos um GIF que mostra tudo o que\nmencionamos acima.</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*JhVFiJNoGZAAmlnk00y6TA.gif\" alt=\"Chrome Dev Tools:\nSources\"></p>\n<p>Para a depuração do código JS, podemos fazer uso de <strong>breakpoints</strong>, que são\npontos onde queremos que nosso código pare durante o tempo de execução.</p>\n<p>No exemplo a seguir, temos um código que verifica se o número digitado por um\nusuário é zero, positivo ou negativo.</p>\n<pre><code class=\"language-javascript\">let number = prompt('Digite um número');\nnumber = Number(numero);\n\nif (number === 0) {\n  alert('Zero');\n} else if (number > 0) {\n  alert('Positivo');\n} else {\n  alert('Negativo');\n}\n</code></pre>\n<p>Para adicionar um <em>breakpoint</em> no DevTools você só tem que clicar no número\nindicador da linha de código onde queremos parar o script. Uma vez colocado o\nbreakpoint, devemos recarregas a página para que pare onde indicamos.</p>\n<p>Uma vez parado, a linha de código onde colocamos o <em>breakpoint</em> ficará\ndestacada, enquanto que a página web ficará opaca e mostrará uma mensagem <em>Paused\nin debugger</em> ao lado de 2 botões. O primeiro (cor azul), chamado  <em>Resume Script\nExecution</em>, determina que a execução continue até o próximo <em>breakpoint</em> ou até\nque termine o script. O segundo (cor cinza), chamado <em>Step over next function\ncall</em>, continua a seguir o fluxo de execução do programa.</p>\n<p>A seguir você pode ver esse processo em um GIF:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*DbS6jAUYz3mPJjyv8MMU-w.gif\" alt=\"Chrome Dev Tools:\nBreakpoints\"></p>\n<p>Dois botões que nos ajudam a depurar nosso código são: <em>Step into next function\ncall</em> e <em>Step out of current function</em>. O primeiro permite entrar no código de\numa função em tempo de execução, enquanto o segundo permite sair da função na\nqual estamos depurando.</p>\n<p>No exemplo a seguir, se tivéssemos um breakpoint na linha 8, e usássemos o botão\n<em>Step over next function</em>, iríamos para a linha 9; contudo, se usamos o botão de\n<em>Step into next function call</em>, entraria na linha de código número 2 já que esse\né o código que está dentro de nossa função.</p>\n<p>Chegou a hora de testarmos:</p>\n<pre><code class=\"language-javascript\">function factorial(number) {\n  if (number === 1) {\n    return 1;\n  }\n  return number * factorial(number - 1);\n}\n\nconst result = factorial(5);\nconsole.log(result);\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*C3k9ZTu-q9i8GFB2P47muQ.gif\" alt=\"Chrome Dev Tools:\nDebugging\"></p>\n<h2>Debugger Statement</h2>\n<p>O segundo método para depurar um código é utilizando uma palavra reservada em JS\nchamada <code>debugger</code>. Esta palavra permite especificar no código a linha exata em\nque queremos que nosso aplicativo web seja depurado.</p>\n<blockquote>\n<p>Nota: Para que o script pare na palavra <code>debugger</code>, precisamos ter o Dev Tools\naberto e então recarregar a página.</p>\n</blockquote>\n<p>A seguir temos uma demonstração usando o seguinte script:</p>\n<pre><code class=\"language-javascript\">const number = parseInt(prompt('Digite um número (de 1 a 10):'));\nconst randomNumber = Math.floor(Math.random() * 10);\n\ndebugger;\nif (randomNumber === number) {\n    console.log('Adivinhou!');\n} else {\n    console.log('Perdeu! O número é ' + randomNumber);\n}\n</code></pre>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*RcPHfLBSK1Bh8FzfqJlqpQ.gif\" alt=\"Debugger\nstatement\"></p>\n<h2>Agora é sua vez</h2>\n<p>Para colocar em prática esta leitura, você pode depurar o código a seguir:</p>\n<pre><code class=\"language-javascript\">/*\n * Corrija o seguinte código de maneira que obtenha o resultado esperado.\n * Utilize as técnicas de depuração que você conhece para encontrar e resolver\n * o erro.\n */\n\nconst reverse = (text) => {\n  let reversedText = '';\n  const textLength = text.length;\n\n  for (let i = textLength; i > 0; i--) {\n   reversedText += text.charAt(i);\n  }\n\n  return reversedText;\n};\n\nconst result = reverse('Laboratoria');\n// Resultado atual: airotaroba\n// Resultado esperado: airotarobaL\nconsole.log(result);\n\n// HINT: São duas alterações para que fique correto ;)\n</code></pre>\n<p>Assim, a partir de agora...</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/800/1*znr2Wn2kXro7XkimgplRCg.jpeg\" alt=\"Debug all the\nthings\"></p>"
            }
          }
        },
        {
          "prefix": "05",
          "slug": "closing",
          "type": "read",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Cierre: Debugging",
              "body": "<h2>Agenda</h2>\n<h3>1. Responde a las preguntas del opening</h3>\n<ul>\n<li>¿Por qué es importante la depuración?</li>\n<li>¿Qué tipos de errores podemos encontrar en el desarrollo de software?</li>\n<li>¿Por qué es importante reconocer los mensajes de error? Identifica algunos\nque te hayan sucedido</li>\n<li>¿Qué es el Dev Tools?</li>\n<li>¿Qué son los breakpoints?</li>\n<li>¿Cómo depurar en el Dev Tools?</li>\n</ul>\n<h3>2. Sigue practicando</h3>\n<p><img src=\"http://s2.quickmeme.com/img/32/3231c171a34d1b88ab1768b1ba5ef9f0e9b035f523e197f2b99f83b7856826e3.jpg\" alt=\"Debugging is done\"></p>"
            },
            "pt": {
              "title": "Encerramento: Debugging",
              "body": "<h2>Agenda</h2>\n<h3>1. Responda às perguntas da abertura</h3>\n<ul>\n<li>Por que a depuração é importante?</li>\n<li>Que tipos de erros podemos encontrar no desenvolvimento de software?</li>\n<li>Por que é importante reconhecer as mensagens de erros? Identifique algumas que\nvocê já viu.</li>\n<li>O que é o Dev Tools?</li>\n<li>O que são <code>breakpoints</code>?</li>\n<li>Como depurar no Dev Tools?</li>\n</ul>"
            }
          }
        }
      ]
    },
    {
      "slug": "testing",
      "intl": {
        "es": {
          "title": "Testing / Pruebas"
        },
        "pt": {
          "title": "Testes"
        }
      },
      "prefix": "11",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Apertura",
              "body": "<h2>¿Por qué aprender esto?</h2>\n<p>Probar tu código es importante para garantizar que funcione como unx espera,\npero no solo eso, si no que escribir pruebas/tests desde el principio nos ayuda\na diseñar mejor nuestro código.</p>\n<p>Escribimos tests para:</p>\n<ol>\n<li>Encontrar problemas en la implementación</li>\n<li>Para evitar que problemas/bugs lleguen a producción</li>\n<li>Para probar/demostrar que un programa no tiene fallas</li>\n<li>Para averiguar la fiabilidad de nuestro código</li>\n<li>Para asegurar que un <em>producto</em> se comporte como esperamos</li>\n<li>Para detectar problemas pronto, lo que permite reducir el costo de\nmodificaciones</li>\n</ol>\n<p>En este curso pondremos especial énfasis en el diseño orientado a pruebas (<a href=\"https://en.wikipedia.org/wiki/Test-driven_development\">Test\nDriven Development - TDD</a>).\nEn esta unidad podrás seguir los pasos necesarios para escribir tus primeros\ntests y entender el valor tan grande que aportan.</p>\n<p>A lo largo del curso usaremos tests no solo en el <em>proyecto final</em> sino como\nherramienta para demostrar las diferentes características del lenguaje según\nvayamos avanzando.</p>\n<h2>Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Qué es un test?</li>\n<li>Qué es un framework de testing?</li>\n<li>Cómo escribir tests usando la interfaz BDD (<code>describe()</code>, <code>it()</code>, ...) de\n<code>mocha</code>.</li>\n<li>Cómo usar la librería standard de Node.js para aserciones con el módulo\n<code>assert</code>.</li>\n<li>Cómo usar las aserciones de <code>chai</code>.</li>\n<li>Cómo correr tests en un entorno de navegador de forma automatizada con\n<code>karma</code>.</li>\n</ul>"
            },
            "pt": {
              "title": "Abertura",
              "body": "<h2>Por que aprender isto?</h2>\n<p>Testar seu código é importante para garantir que funcione conforme o esperado,\nmas não somente isso. Escrever testes desde o início auxilia a criar e projetar\ncódigos melhores.</p>\n<p>Escrevemos testes para:</p>\n<ol>\n<li>Encontrar problemas na codificação;</li>\n<li>Evitar que problemas/bugs cheguem à produção;</li>\n<li>Para provar/demonstrar que um programa não possui falhas;</li>\n<li>Para verificar a confiabilidade de nosso código;</li>\n<li>Para garantir que um <em>produto</em> se comporte como esperamos;</li>\n<li>Para detectar problemas rapidamente, o que permite reduzir o custo de\nmodificações.</li>\n</ol>\n<p>Neste curso teremos uma ênfase especial no desenvolvimento orientado a testes\n(<a href=\"https://pt.wikipedia.org/wiki/Test_Driven_Development\">Test Drive Development -\nTDD</a>). Nesta unidade você\npoderá seguir os passos necessários para escrever seus primeiros testes e\nentender o valor inestimável que propiciam.</p>\n<p>Ao longo do curso usaremos testes não somente no <em>projeto final</em> mas também como\nferramentas para demonstrar as diferentes características da linguagem conforme\nformos avançando.</p>\n<h2>Guia de perguntas e conceitos chave</h2>\n<p>Quando começamos a estudar um novo assunto, é útil termos uma ideia de conceitos\nmais importantes que vamos aprender e dos temas centrais a que devemos prestar\natenção especial.</p>\n<p>A seguir apresentamos uma série de perguntas que você deve ser capaz de\nresponder ao terminar esta unidade. Use estas perguntas como guia para orientar\nseu esforço de aprendizagem. Retorne a elas constantemente a medida que avança\npara validar que está indo na direção correta. Que este guia sirva como um\n\"checklist\" que você vai riscando conforme avança.</p>\n<ul>\n<li>O que é um teste?</li>\n<li>O que é um <em>framework</em> de <em>testing</em>?</li>\n<li>Como escrever testes usando a interface BDD (<code>describe()</code>, <code>it()</code>, ...) do\n<code>mocha</code>?</li>\n<li>Como usar a biblioteca padrão de Node.js para atribuições com o módulo\n<code>assert</code>?</li>\n<li>Como usar as <em>asserts</em> do <code>chai</code>?</li>\n<li>Como executar testes no ambiente do navegador de forma automatizada com\n<code>karma</code>?</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "basics",
          "type": "read",
          "duration": 20,
          "intl": {
            "es": {
              "title": "Qué es un test?",
              "body": "<p>Cuando hablamos de <strong>tests</strong> (pruebas), podríamos ponernos a pensar en\nherramientas de testing, como <code>Mocha</code>, <code>Jest</code>, <code>Jasmine</code>, ... o metodologías de\ndesarrollo como TDD o BDD. Todo esto puede ser super confuso. En esta unidad\ntrataremos de desmitificar un poco este tema empezando desde el principio. Para\nello pensemos en pruebas simplemente como el acto de ejecutar algo en la\ncomputadora y después comprobar que efectivamente ocurrió lo que esperábamos.</p>\n<p>El test más sencillo posible:</p>\n<pre><code class=\"language-js\">const a = 5;\nconsole.log(a);\n</code></pre>\n<p>Podríamos decir que nuestro amigo <code>console.log</code> es la herramienta de testing más\nbásica de todas. Al imprimir un valor a la consola, lo podemos ver con nuestros\nojos y <em>comprobar</em> qué es ese valor (de una forma visual). Estamos probando (o\ncomprobando) que efectivamente la variable <code>a</code> tomó el valor <code>5</code>, que era\nexactamente lo que esperábamos.</p>\n<p>Este proceso nos permite ir viendo qué está ocurriendo en el código mientras lo\nescribimos. Usa <code>console.log</code>, y úsalo mucho. Pero obviamente tiene sus\nlimitaciones. En este caso dependemos de que una persona ejecute el comando, vea\nel <em>output</em> (salida) y en su cabeza haga la comprobación. Muy útil para uno\nmismo, pero no es automatizable ni escalable.</p>\n<p>Por suerte, somos programadorxs, así que podemos escribir un poco de código (y/o\nusar código de otrxs) para atacar estos problemas :rocket:</p>\n<hr>\n<p>Para seguir esta unidad, te recomendamos que crees una carpeta en algún lugar de\ntu computadora y vayas creando los archivos y codeando mientras avanzamos. Todo\nel código de esta lección lo puedes ejecutar con <code>node</code>.</p>\n<hr>\n<p>Ahora imaginemos que queremos una función que dado un caracter, nos diga si es\nuna vocal o no (debería retornar <code>true</code> para las vocales y <code>false</code> para\ncualquier otro caracter). Antes de implementar la función podríamos plantear\nunos <em>tests</em>. Crea un archivo con el nombre <code>isVowel.spec.js</code> y escribe el\nsiguiente código:</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`:\n\nconst isVowel = require('./isVowel');\n\nconsole.log('debería devolver true para letra a');\nif (isVowel('a') === true) {\n  console.log('✓ ok');\n} else {\n  console.error('✗ fail');\n}\n\nconsole.log('debería devolver false para letra b');\nif (isVowel('b') === false) {\n  console.log('✓ ok');\n} else {\n  console.error('✗ fail');\n}\n</code></pre>\n<p>Ejecutemos nuestros tests con <code>node</code> en la línea de comando:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\nmodule.js:557\n    throw err;\n    ^\n\nError: Cannot find module './isVowel'\n    at Function.Module._resolveFilename (module.js:555:15)\n    at Function.Module._load (module.js:482:25)\n    at Module.require (module.js:604:17)\n    at require (internal/module.js:11:18)\n    at Object.&#x3C;anonymous> (/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:1:79)\n    at Module._compile (module.js:660:30)\n    at Object.Module._extensions..js (module.js:671:10)\n    at Module.load (module.js:573:32)\n    at tryModuleLoad (module.js:513:12)\n    at Function.Module._load (module.js:505:3)\n</code></pre>\n<p>Como vemos recibimos un error: <code>Error: Cannot find module './isVowel'</code>. Los\nerrores pueden ser un poco crípticos al principio, y hay que aprender a\n<em>leerlos</em>. El mensaje de error en sí dice que no se pudo encontrar el módulo\n<code>./isVowel</code>, y debajo tenemos una serie de líneas con el\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack\">stack trace</a>,\nque nos muestra la pila de llamadas donde ocurrió el error. En este caso podemos\nver que se menciona nuestro script (<code>/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:1:79</code>),\ny al final de la ruta al archivo vemos que aparecen dos números separados por\ndos puntos (<code>:</code>). Estos números nos dicen en qué línea y qué columna (posición\ndentro de la línea) está el código en cuestión. La línea <code>1</code> contiene\n<code>require('./isVowel')</code>, que es la responsable del error.</p>\n<p>Esto es porque hemos tratado de importar un modulo del archivo <code>./isVowel.js</code> en\nel mismo directorio que nuestro script con los tests, pero obviamente no existe,\nasí que creémoslo y declaremos una función con el nombre <code>isVowel</code>:</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.js`\n\nconst isVowel = function (char) {\n  // ...\n};\n</code></pre>\n<p>Si volvemos a ejecutar los tests, ahora el output mostrado en la consola debería\nverse algo así:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\ndebería devolver true para letra a\n/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:4\nif (isVowel('a') !== true) {\n    ^\n\nTypeError: isVowel is not a function\n    at Object.&#x3C;anonymous> (/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:6:5)\n    at Module._compile (module.js:660:30)\n    at Object.Module._extensions..js (module.js:671:10)\n    at Module.load (module.js:573:32)\n    at tryModuleLoad (module.js:513:12)\n    at Function.Module._load (module.js:505:3)\n    at Function.Module.runMain (module.js:701:10)\n    at startup (bootstrap_node.js:194:16)\n    at bootstrap_node.js:618:3\n</code></pre>\n<p>Esto quiere decir que ahora sí se ha podido cargar el módulo (el error de antes\nya no aparece), pero ahora recibimos un nuevo error: <code>TypeError: isVowel is not a function</code>. Si nos fijamos en la línea justo abajo del mensaje de error, vemos\nque el error se produjo en el archivo <code>isVowel.spec.js</code> en la línea <code>6</code> y\ncolumna <code>5</code>). Si nos fijamos en el código, veremos que línea <code>6</code> y columna <code>5</code>\nes donde está <code>isVowel('a')</code>. En esta línea es la primera vez que invocamos la\nfunción <code>isVowel</code>, y parece que no es lo que esperábamos (una función, doh!).</p>\n<p>El motivo por el que vemos este error es porque a pesar de que hemos creado el\narchivo <code>isVowel.js</code> y hemos declarado una función con el nombre <code>isVowel</code>, no\nla hemos <em>exportado</em>.</p>\n<p>Más adelante veremos más detalles sobre como <em>exportar</em> usando tanto CommonJS\n(<code>require</code>, <code>module</code>, <code>module.exports</code>) como módulos de ES6 (<code>import</code>,\n<code>export</code>). Por ahora no vamos a detenernos con estos detalles. Lo importante por\nahora es saber que estamos ejecutando nuestro código con <code>node</code>, con lo cual\nvamos a usar el sistema de módulos de <code>node</code> (CommonJS). Cuando usamos este\nsistema, podemos <em>exportar</em> cualquier valor asignándolo a la propiedad <code>exports</code>\ndel objeto global <code>module</code> (<code>module.exports</code>). <code>Node.js</code> se encarga de que el\nobjeto <code>module</code> exista en el ámbito global.</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.js`\n\nconst isVowel = function (char) {\n  // ...\n};\n\nmodule.exports = isVowel;\n</code></pre>\n<p>Ejecutemos los <em>tests</em> una vez más:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\ndebería devolver true para letra a\n✗ fail\ndebería devolver false para letra b\n✗ fail\n</code></pre>\n<p>Yay! Finalmente nuestro script de tests corre sin <em>errores</em>, pero vemos que la\nimplementación de <code>isVowel()</code> todavía no pasa ninguno de los dos tests que\nescribimos.</p>\n<p>Ahora sí, implementamos la funcionalidad esperada en <code>isVowel()</code>:</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.js`\n\nconst isVowel = function (char) {\n  return ['a', 'e', 'i', 'o', 'u'].indexOf(char) > -1;\n};\n\nmodule.exports = isVowel;\n</code></pre>\n<p>Y volvemos a ejecutar los tests una vez más:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\ndebería devolver true para letra a\n✓ ok\ndebería devolver false para letra b\n✓ ok\n</code></pre>\n<hr>\n<h2>Lecturas complementarias</h2>\n<p><a href=\"https://martinfowler.com/bliki/UnitTest.html\">Unit Test - Martin Fowler</a></p>"
            },
            "pt": {
              "title": "O que é um teste?",
              "body": "<p>Quando falamos de <strong>tests</strong> (testes), poderíamos pensar em ferramentas de testes\ncomo <code>Mocha</code>, <code>Jest</code>, <code>Jasmine</code>, ... ou metodologias de desenvolvimento como TDD\nou BDD. Tudo isso pode ser muito confuso. Nesta unidade trataremos de\ndesmistificar um pouco este tema começando pelo princípio. Para tal, pensemos em\ntestes simplesmente como o ato de executar algo no computador e depois verificar\nque efetivamente aconteceu o que esperávamos.</p>\n<p>O teste mais simples possível:</p>\n<pre><code class=\"language-js\">const a = 5;\nconsole.log(a);\n</code></pre>\n<p>Poderíamos dizer que nosso amigo <code>console.log</code> é a ferramenta de testes mais\nbásica de todas. Ao imprimir um valor no console, podemos ver com nossos e olhos\ne <em>comprovar</em> que é esse o valor (de uma maneira visual). Estamos provando (ou\ncomprovando) que efetivamente a variável <code>a</code> recebeu o valor <code>5</code>, que era\nexatamente o que esperávamos.</p>\n<p>Este processo nos permite ver o que está acontecendo com o código enquanto o\nescrevemos. Utilize o <code>console.log</code> e utilize-o muito. Mas obviamente ele possui\nlimitações. Neste caso dependemos que uma pessoa execute o comando, veja o\n<em>output</em> (saída) e na sua cabeça faça a comprovação. Muito útil para a pessoa,\nmas não é automatizável nem escalável.</p>\n<p>Por sorte, somos programadoras e podemos escrever um pouco de código (e ou usar\ncódigo de outras) para resolver estes problemas.</p>\n<hr>\n<p>Para continuar nesta unidade, recomendamos que você crie uma pasta em algum\nlugar de seu computador e vá criando os arquivos e programando conforme\navançamos. Todo o código desta lição pode ser executado com <code>node</code>.</p>\n<hr>\n<p>Agora imaginemos que queiramos uma função que dado um caractere, ela nos diga se\né uma vogal ou não (deveria retornar <code>true</code> para as vogais e <code>false</code> para\nqualquer outro caractere). Antes de implementar a função poderíamos projetar\nalguns <em>tests</em>. Crie um arquivo com o nome <code>isVowel.spec.js</code> e escreva o código\na seguir:</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`:\n\nconst isVowel = require('./isVowel');\n\nconsole.log('Deveria retornar true para a letra a');\nif (isVowel('a') === true) {\n  console.log('✓ ok');\n} else {\n  console.error('✗ fail');\n}\n\nconsole.log('Deveria retornar false para a letra b');\nif (isVowel('b') === false) {\n  console.log('✓ ok');\n} else {\n  console.error('✗ fail');\n}\n</code></pre>\n<p>Executemos nossos testes com <code>node</code> na linha de comando:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\nmodule.js:557\n    throw err;\n    ^\n\nError: Cannot find module './isVowel'\n    at Function.Module._resolveFilename (module.js:555:15)\n    at Function.Module._load (module.js:482:25)\n    at Module.require (module.js:604:17)\n    at require (internal/module.js:11:18)\n    at Object.&#x3C;anonymous> (/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:1:79)\n    at Module._compile (module.js:660:30)\n    at Object.Module._extensions..js (module.js:671:10)\n    at Module.load (module.js:573:32)\n    at tryModuleLoad (module.js:513:12)\n    at Function.Module._load (module.js:505:3)\n</code></pre>\n<p>Como podemos ver, recebemos um erro: <code>Error: Cannot find module './isVowel'</code>. Os\nerros podem ser um pouco enigmáticos no início e você precisa aprender a\n<em>lê-los</em>. A mensagem de erro em diz que não foi possível encontrar o módulo\n<code>./isVowel</code> e abaixo temos uma série de linhas com o <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack\"><em>stack\ntrace</em></a>,\nque nos mostra a pilha de chamadas a partir de onde ocorreu o erro. Neste caso\npodemos ver que é mencionado nosso script\n(<code>/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:1:79</code>),\ne ao final do caminho do arquivo vemos que aparecem dois números separados por\ndois pontos (<code>:</code>). Estes números nos dizem em qual linha e qual coluna (posição\ndentro da linha) está o código em questão. A linha <code>1</code> contém\n<code>require('./isVowel')</code>, que é a responsável pelo erro.</p>\n<p>Isso acontece porque importamos um módulo do arquivo <code>./isVowel.js</code> no mesmo\ndiretório que nosso script com os testes, mas ele não existe. Assim que o\ncriamos e declaramos uma função com o nome <code>isVowel</code>:</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.js`\n\nconst isVowel = function (char) {\n  // ...\n};\n</code></pre>\n<p>Se executarmos novamente os testes, agora a saída mostrada no console deveria\naparecer algo assim:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\nDeveria retornar true para a letra a\n/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:4\nif (isVowel('a') !== true) {\n    ^\n\nTypeError: isVowel is not a function\n    at Object.&#x3C;anonymous> (/Users/lupo/work/laboratoria/curricula-js/05-deep-dive/03-testing/01-basics/files/isVowel.spec.js:6:5)\n    at Module._compile (module.js:660:30)\n    at Object.Module._extensions..js (module.js:671:10)\n    at Module.load (module.js:573:32)\n    at tryModuleLoad (module.js:513:12)\n    at Function.Module._load (module.js:505:3)\n    at Function.Module.runMain (module.js:701:10)\n    at startup (bootstrap_node.js:194:16)\n    at bootstrap_node.js:618:3\n</code></pre>\n<p>Isto quer dizer que agora sim foi possível carregar o módulo (o erro de antes já\nnão aparece), mas agora recebemos um novo erro: <code>TypeError: isVowel is not a function</code> Se olharmos na linha logo abaixo da mensagem de erro, vemos que o erro\nfoi disparado no arquivo <code>isVowel.spec.js</code> na linha <code>6</code> e coluna <code>5</code>). Se\nolharmos no código, veremos que linha <code>6</code> e coluna <code>5</code> é onde está\n<code>isVowel('a')</code>. Esta é a linha na qual invocamos a função <code>isVowel</code> pela\nprimeira vez e parece que não é o que esperávamos (uma função, doh!).</p>\n<p>O motivo pelo qual vemos esse erro é porque apesar de termos criado o arquivo\n<code>isVowel.js</code> e termos declarado uma função com o nome <code>isVowel</code> não a\n<em>exportamos</em>.</p>\n<p>Mais adiante veremos mais detalhes sobre como <em>exportar</em> usando tanto CommonJS\n(<code>require</code>, <code>module</code>, <code>module.exports</code>) como módulos de ES6 (<code>import</code>,\n<code>export</code>). Por enquanto não vamos esmiuçar esses detalhes. O importante por\nenquanto é saber que estamos executando nosso código com <code>node</code>, com o qual\nvamos usar o sistema de módulos de <code>node</code> (CommonJS). Quando usamos este\nsistemas, podemos <em>exportar</em> qualquer valor atribuindo-o à propriedade <code>exports</code>\ndo objeto global <code>module</code> (<code>module.exports</code>). <code>Node.js</code> se encarrega de que o\n<code>module</code> exista no âmbito global.</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.js`\n\nconst isVowel = function (char) {\n  // ...\n};\n\nmodule.exports = isVowel;\n</code></pre>\n<p>Executemos os <em>tests</em> uma vez más:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\nDeveria retornar true para a letra a\n✗ fail\nDeveria retornar false para a letra b\n✗ fail\n</code></pre>\n<p>Viva! Finalmente nosso script de tests executou sem <em>erros</em>, mas vemos que a\nimplementação de <code>isVowel()</code> não passa em nenhum dos testes que escrevemos.</p>\n<p>Agora sim, implementamos a funcionalidade esperada em <code>isVowel()</code>:</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.js`\n\nconst isVowel = function (char) {\n  return ['a', 'e', 'i', 'o', 'u'].indexOf(char) > -1;\n};\n\nmodule.exports = isVowel;\n</code></pre>\n<p>E executemos os testes mais uma vez:</p>\n<pre><code class=\"language-sh\">$ node ./isVowel.spec.js\nDeveria retornar true para a letra a\n✓ ok\nDeveria retornar false para a letra b\n✓ ok\n</code></pre>\n<hr>\n<h2>Leituras complementares</h2>\n<p><a href=\"https://martinfowler.com/bliki/UnitTest.html\">Unit Test - Martin Fowler</a></p>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "frameworks",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Frameworks",
              "body": "<p>Ya hemos visto un poco de qué hacemos cuando testeamos y por qué lo hacemos.\nAhora vamos a ir introduciendo algunas herramientas para facilitar ese proceso\nde tener que ejecutar algo y comprobar si ha ocurrido lo que esperábamos.</p>\n<p>Hay un montón de frameworks y librerías buenísimas de testing para JavaScript:\n<a href=\"https://mochajs.org/\">Mocha</a>, <a href=\"https://facebook.github.io/jest/\">Jest</a>,\n<a href=\"https://jasmine.github.io/\">Jasmine</a>, <a href=\"https://github.com/substack/tape\">Tape</a>,\n... por mencionar algunas de las más populares.</p>\n<blockquote>\n<p>Unit testing involves breaking your program into pieces, and subjecting each\npiece to a series of tests.</p>\n<p>Usually tests are run as separate programs, but the method of testing varies,\ndepending on the language, and type of software (GUI, command-line, library).</p>\n<p>Most languages have unit testing frameworks, you should look into one for\nyours.</p>\n<p>Tests are usually run periodically, often after every change to the source\ncode. The more often the better, because the sooner you will catch problems.</p>\n<p>Fuente: <a href=\"https://stackoverflow.com/a/652309/374331\">Stack Overflow</a></p>\n</blockquote>\n<p>En este curso nos vamos a concentrar en <strong>Mocha</strong>, y en particular en la\ninterfaz <a href=\"https://mochajs.org/#bdd\">BDD</a>, que implementa una API para hacer\n<a href=\"https://en.wikipedia.org/wiki/Behavior-driven_development\">Behavior-driven development</a>.</p>\n<h2>Instalando Mocha</h2>\n<p>Para empezar instalemos <code>mocha</code> globalmente usando <code>npm</code>.</p>\n<pre><code class=\"language-sh\">npm install --global mocha\n</code></pre>\n<p>Alternativamente, si te gustan las abreviaciones, puedes usar este otro comando,\nque hace exactamente lo mismo que el anterior, pero usando todos los atajos.</p>\n<pre><code class=\"language-sh\">npm i -g mocha\n</code></pre>\n<p>Si recibes un error que dice algo como <code>Error: EACCES: permission denied ...</code>,\nesto probablemente significa que no tienes permisos sobre la carpeta donde está\ninstalado <code>Node.js</code> globalmente. En ese caso puedes probar a ejecutar el comando\nusando <code>sudo</code>:</p>\n<pre><code class=\"language-sh\">sudo npm i -g mocha\n</code></pre>\n<p>Si todo ha ido bien, ya deberías tener <code>mocha</code> instalado como un comando que\npuedes ejecutar en tu terminal. Podemos usar el comando <code>which</code> para ver si se\nencuentra el ejecutable:</p>\n<pre><code class=\"language-sh\">$ which mocha\n/usr/local/bin/mocha\n</code></pre>\n<p>Si <code>mocha</code> no estuviera instalado en tu <code>PATH</code> el comando <code>which</code> no mostraría\nnada. Por otro lado, ahora que sabemos que tenemos el ejecutable de <code>mocha</code>\ndisponible, podemos ver la ayuda del comando ejecutando <code>mocha --help</code>:</p>\n<pre><code class=\"language-sh\">$ mocha --help\n\n  Usage: mocha [debug] [options] [files]\n\n\n  Options:\n\n    -V, --version                           output the version number\n    -A, --async-only                        force all tests to take a callback (async) or return a promise\n    -c, --colors                            force enabling of colors\n    -C, --no-colors                         force disabling of colors\n    -G, --growl                             enable growl notification support\n    -O, --reporter-options &#x3C;k=v,k2=v2,...>  reporter-specific options\n    -R, --reporter &#x3C;name>                   specify the reporter to use\n    -S, --sort                              sort test files\n    -b, --bail                              bail after first test failure\n    ...\n\n\n  Commands:\n\n    init &#x3C;path>  initialize a client-side mocha setup at &#x3C;path>\n</code></pre>\n<h2>Nuestros primeros tests con la interfaz BDD</h2>\n<p>Ahora que ya tenemos instalado <code>mocha</code>, podemos usar el comando para ejecutar\nscripts con nuestros tests, usando todo lo que nos ofrece la librería.</p>\n<p>Para comenzar nos vamos a limitar a dos funciones que <code>mocha</code> inyecta en el\nentorno: <code>describe()</code> e <code>it()</code>. Estas dos funciones nos va a permitir construir\nla estructura de qué queremos testear.</p>\n<p>En el ejemplo que venimos viendo, nuestros test dicen algo como: comprueba que\n<em>isVowel()</em>:</p>\n<ul>\n<li>retorna <code>true</code> cuando se invoca con el valor <code>a</code> (<code>isVowel('a') === true</code>)</li>\n<li>retorna <code>false</code> cuando se invoca con el valor <code>b</code> (<code>isVowel('b') === false</code>)</li>\n</ul>\n<p>Esta lógica la podemos expresar usando <code>describe()</code> e <code>it()</code>. Con <code>describe()</code>\nvamos a decir qué cosa estamos testeando, y con <code>it()</code> vamos a ir especificando\nque características o comportamientos queremos comprobar/afirmar.</p>\n<p>Reescribamos nuestros tests usando esta API (<code>describe</code> e <code>it</code>). El primer paso\nes indicar qué queremos testear (la función <code>isVowel()</code> en nuestro caso) usando\nuna llamada a <code>describe()</code>, que recibe dos argumentos, un string informativo\npara darle un nombre al grupo de tests y una función que contendrá todos los\ntests y aserciones para esta cosa que estamos testeando.</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`\n\ndescribe('isVowel()', () => {\n  // Acá van los tests que describen el compartamiento de `isVowel()`\n});\n</code></pre>\n<p>Salva esto en el archivo <code>isVowel.spec.js</code> y ejecútalo con <code>mocha</code>:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  0 passing (2ms)\n\n</code></pre>\n<p>No recibimos ningún error pero tampoco pasa nada interesante... solo vemos que\n<code>0</code> tests pasaron. A la hora de escribir tests (ya sea antes o después de\nimplementar el código que queremos testear), es muy común plantear tests sin\ndarles una implementación todavía. En nuestro caso, sabemos que queremos probar\nque <code>isVowel()</code>:</p>\n<ul>\n<li>retorna <code>true</code> cuando se invoca con el valor <code>a</code></li>\n<li>retorna <code>false</code> cuando se invoca con el valor <code>b</code></li>\n</ul>\n<p>Esto traducido a la semántica de BDD en Mocha, lo podemos expresar así:</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`\n\ndescribe('isVowel()', () => {\n  it('debería devolver true para letra a');\n  it('debería devolver false para letra b');\n});\n</code></pre>\n<p>Volvamos a ejecutar los tests con el comando <code>mocha</code>:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n    - debería devolver true para letra a\n    - debería devolver false para letra b\n\n\n  0 passing (5ms)\n  2 pending\n\n</code></pre>\n<p>Verás de que todavía no hemos especificado cómo hacer las comprobaciones, pero\nhemos ido igualmente describiendo el comportamiento esperado, y más tarde\npodemos ir rellenando la implementación según avancemos. Esto es super útil\ntanto para <em>documentar</em> el comportamiento de nuestro código, como para ver el\nnivel de completitud de la implementación y qué casos tiene en cuenta (o no).</p>\n<p>En el snippet anterior invocamos <code>it()</code> con un string que nos permite describir\nla característica o comportamiento esperado. Lo más común es que estos strings\ncomiencen con la palabra <em>debería...</em>. De es forma se va articulando la\nsemántica que después <em>leeremos</em> como <em>is isVowel() debería ....</em>.</p>\n<p>Mocha nos muestra los tests que añadimos con <code>it()</code> pero nos dice que están\n<em>pendientes</em>. Esto es porque les dimos un nombre, pero no les dimos una\nimplementación. Para añadir el código que de verdad ejecuta la prueba en sí,\n<code>it()</code> recibe un segundo argumento, una función que será invocada para ejecutar\nel test en cuestión.</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`\n\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('debería devolver true para letra a', () => {\n    // Acá invocamos `isVowel()` y verificamos el resultado\n  });\n\n  it('debería devolver false para letra b', () => {\n    // Acá invocamos `isVowel()` y verificamos el resultado\n  });\n\n});\n</code></pre>\n<p>Bueno, ya tenemos una estructura lista para implementar nuestros tests. Para\ncontinuar gradualmente con el ejemplo, simplemente copia las comprobaciones que\nhacíamos en la primera versión de los tests (lectura anterior) dentro de nuestra\nnueva estructura:</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`\n\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('debería devolver true para letra a', () => {\n    if (isVowel('a') !== true) {\n      console.error('✗ fail');\n    } else {\n      console.log('✓ ok');\n    }\n  });\n\n  it('debería devolver false para letra b', () => {\n    if (isVowel('b') !== false) {\n      console.error('✗ fail');\n    } else {\n      console.log('✓ ok');\n    }\n  });\n\n});\n</code></pre>\n<p>Ejecutemos los tests otra vez:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n✓ ok\n    ✓ debería devolver true para letra a\n✓ ok\n    ✓ debería devolver false para letra b\n\n\n  2 passing (6ms)\n\n</code></pre>\n<p>Hmmm... como puedes ver se ejecutaron nuestras comprobaciones, pero Mocha y\nnuestro código no parecen estar comunicándose. Eso es porque Mocha espera que\nhagamos las comprobaciones usando <em>aserciones</em>, que puedan comunicar si una\ncomprobación pasó o no a mocha para que este pueda manejar los resultados, en\nvez de tener que <em>manualmente</em> imprimir mensajes a la consola.</p>\n<p>En la siguiente lectura veremos como usar <em>aserciones</em> en tus tests, tanto en\nversión vanilla, con <code>assert</code> de Node.js y con <code>Chai.assert</code>.</p>"
            },
            "pt": {
              "title": "Frameworks",
              "body": "<p>Já vimos um pouco o que fazemos quando testamos e porque testamos. Agora vamos\nintroduzir algumas ferramentas para facilitar esse processo de ter que executar\nalgo e comprovar se aconteceu o que esperávamos.</p>\n<p>Existem vários frameworks e bibliotecas ótimas de <em>testing</em> para JavaScript:\n<a href=\"https://mochajs.org/\">Mocha</a>, <a href=\"https://facebook.github.io/jest/\">Jest</a>,\n<a href=\"https://jasmine.github.io/\">Jasmine</a>,\n<a href=\"https://github.com/substack/tape\">Tape</a>,... para falar só das mais populares.</p>\n<blockquote>\n<p>Teste unitário envolve quebrar seu programa em pedaços e submeter cada pedaço\na uma série de testes.</p>\n<p>Normalmente testes são executados como programas a parte, mas o método de teste\nvaria, dependendo da linguagem e do tipo de software (GUI, linha de comando,\nbiblioteca).</p>\n<p>A maior parte das linguagens possuem frameworks para testes unitários. Você\ndeve olhar o framework que você utiliza.</p>\n<p>Testes normalmente são executados periodicamente, frequentemente após cada\nmudança do código fonte. Quando mais frequente melhor, porque mais cedo você\nverá os problemas.</p>\n<p>Fonte: <a href=\"https://stackoverflow.com/a/652309/374331\">Stack Overflow</a></p>\n</blockquote>\n<p>Neste curso concentraremos os esforços no <strong>Mocha</strong> e em particular à interface\n<a href=\"https://mochajs.org/#bdd\">BDD</a>, que implementa uma API para fazer\n<a href=\"https://pt.wikipedia.org/wiki/Behavior_Driven_Development\">Behavior-driven\ndevelopment</a>.</p>\n<h2>Instalando Mocha</h2>\n<p>Para começar, instalaremos o <code>mocha</code> globalmente usando <code>npm</code>.</p>\n<pre><code class=\"language-sh\">npm install --global mocha\n</code></pre>\n<p>Alternativamente, se você prefere abreviaturas, é possível usar este outro\ncomando que faz exatamente o mesmo que o anterior, mas usando os atalhos.</p>\n<pre><code class=\"language-sh\">npm i -g mocha\n</code></pre>\n<p>Se você receber um erro que diz algo como <code>Error: EACCES: permission denied ...</code>, provavelmente significa que você não possui permissão na pasta na qual\nestá instalado <code>Node.js</code>. Nesse caso, você pode tentar executar o comando usando\n<code>sudo</code>:</p>\n<pre><code class=\"language-sh\">sudo npm i -g mocha\n</code></pre>\n<p>Se tudo correu bem, você já deve ter o <code>mocha</code> instalado como um comando que\nvocê pode executar pelo terminal. Podemos usar o comando <code>which</code> para ver se ele\nencontra o executável:</p>\n<pre><code class=\"language-sh\">$ which mocha\n/usr/local/bin/mocha\n</code></pre>\n<p>Se o <code>mocha</code> não estivesse instalado no seu <code>Path</code> o comando <code>which</code> não\nmostraria nada. Por outro lado, agora que sabemos que temos o executável de\n<code>mocha</code> disponível, podemos ver a ajuda executando o comando <code>mocha --help</code>:</p>\n<pre><code class=\"language-sh\">$ mocha --help\n\n  Usage: mocha [debug] [options] [files]\n\n\n  Options:\n\n    -V, --version                           output the version number\n    -A, --async-only                        force all tests to take a callback (async) or return a promise\n    -c, --colors                            force enabling of colors\n    -C, --no-colors                         force disabling of colors\n    -G, --growl                             enable growl notification support\n    -O, --reporter-options &#x3C;k=v,k2=v2,...>  reporter-specific options\n    -R, --reporter &#x3C;name>                   specify the reporter to use\n    -S, --sort                              sort test files\n    -b, --bail                              bail after first test failure\n    ...\n\n\n  Commands:\n\n    init &#x3C;path>  initialize a client-side mocha setup at &#x3C;path>\n</code></pre>\n<h2>Nossos primeiros testes com a interface BDD</h2>\n<p>Agora que já temos o <code>mocha</code> instalado, podemos usar o comando para executar\nscripts com nossos testes, usando tudo o que a biblioteca nos oferece.</p>\n<p>Para começar vamos nos limitar a duas funções que o <code>mocha</code> injeta no ambiente:\n<code>describe()</code> e <code>it()</code>. Estas duas funções permitirão construir a estrutura que\nqueremos testar.</p>\n<p>No exemplo que vínhamos acompanhando, nossos testes dizem algo como: verifique\nque <em>isVowel()</em>:</p>\n<ul>\n<li>retorna <code>true</code> quando é invocada com o valor <code>a</code> (<code>isVowel('a') === true</code>)</li>\n<li>retorna <code>false</code> quando é invocada com o valor <code>b</code> (<code>isVowel('b') === false</code>)</li>\n</ul>\n<p>Esta lógica pode ser expressada usando <code>describe()</code> e <code>it()</code>. Com <code>describe()</code>\nvamos dizer o que estamos testando e com <code>it()</code> especificaremos quais\ncaracterísticas ou comportamentos queremos comprovar/afirmar.</p>\n<p>Reescrevamos nossos testes usando esta API (<code>describe</code> e <code>it</code>). O primeiro passo\né indicar que queremos testar (a função <code>isVowel()</code> neste caso) usando uma\nchamada <code>describe()</code>, que recebe argumentos, um string informativo para lhe dar\num nome ao grupo de testes e uma função que terá todos os testes e <code>asserts</code>\npara esta coisa que estamos testando.</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`\n\ndescribe('isVowel()', () => {\n  // Aqui vão os testes que descrevem o comportamento de `isVowel()`\n});\n</code></pre>\n<p>Salve isto no arquivo <code>isVowel.spec.js</code> e execute-o com o <code>mocha</code>:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  0 passing (2ms)\n\n</code></pre>\n<p>Não recebemos nenhum erro porque tampouco aconteceu algo de interessante. Só\nvemos que <code>0</code> testes passaram. Na hora de escrever os testes (seja antes ou\ndepois de implementar o código que queremos testar), é muito comum planejar os\ntestes sem lhes dar uma implementação. No nosso caso, sabemos que queremos\nprovar que <code>isVowel()</code>:</p>\n<ul>\n<li>retorna <code>true</code> quando se invoca com o valor <code>a</code>.</li>\n<li>retorna <code>false</code> quando se invoca com o valor <code>b</code>.</li>\n</ul>\n<p>Isto traduzido para a semântica de BDD no Mocha, podemos expressar assim:</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`\n\ndescribe('isVowel()', () => {\n  it('Deveria retornar true para a letra a');\n  it('Deveria retornar false para a letra b');\n});\n</code></pre>\n<p>Votemos a executar os testes com o comando <code>mocha</code>:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n    - Deveria retornar true para a letra a.\n    - Deveria retornar false para a letra b.\n\n\n  0 passing (5ms)\n  2 pending\n\n</code></pre>\n<p>Você verá que embora não tenhamos especificado como fazer as verificações, fomos\ndescrevendo igualmente o comportamento esperado. Mais tarde poderemos refinar a\nimplementação conforme avançamos. Isto é muito útil tanto para <em>documentar</em> o\ncomportamento de nosso código como para ver o nível de totalidade da\nimplementação e quais casos consideramos (ou não).</p>\n<p>No <em>snippet</em> anterior invocamos <code>it()</code> com uma string que permite descrever a\ncaracterística ou comportamento esperado. O mais comum é que estas strings\ncomecem com a palavra <em>deveria ...</em>. Desta maneira vamos articulando a semântica\nque depois <em>leremos</em> como <em>isVowel() deveria...</em>.</p>\n<p>Mocha nos mostra os testes que adicionamos com <code>it()</code> mas nos diz que estão\n<em>pendentes</em>. Isto porque demos um nome mas fizemos uma implementação. Para\nadicionar o código que de fato executa o teste, <code>it()</code> recebe um segundo\nargumento, uma função que será invocada para executar o teste em questão.</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`\n\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('Deveria retornar true para a letra a', () => {\n    // Aqui invocamos `isVowel()` e verificamos o resultado\n  });\n\n  it('Deveria retornar false para a letra b', () => {\n    // Aqui invocamos `isVowel()` e verificamos o resultado\n  });\n\n});\n</code></pre>\n<p>Já temos uma estrutura pronta para implementar nossos testes. Para continuar\ngradualmente com o exemplo, simplesmente copie as verificações que fizemos na\nprimeira versão dos testes (leitura anterior) dentro de nossa nova estrutura:</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`\n\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('Deveria retornar true para a letra a', () => {\n    if (isVowel('a') !== true) {\n      console.error('✗ fail');\n    } else {\n      console.log('✓ ok');\n    }\n  });\n\n  it('Deveria retornar false para a letra b', () => {\n    if (isVowel('b') !== false) {\n      console.error('✗ fail');\n    } else {\n      console.log('✓ ok');\n    }\n  });\n\n});\n</code></pre>\n<p>Executemos os testes outra vez:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n✓ ok\n    ✓ Deveria retornar true para a letra a.\n✓ ok\n    ✓ Deveria retornar false para a letra b.\n\n\n  2 passing (6ms)\n\n</code></pre>\n<p>Hmmm... como você pode ver nossas verificações foram executadas, mas o Mocha e\nnosso código não parecem estar se comunicando. Isso porque o Mocha espera que\nfaçamos as verificações usando <em>asserts</em> que podem comunicar se uma verificação\npassou ou não com o Mocha para que ele possa tratar os resultados, ao invés de\nter que <em>manualmente</em> exibir as mensagens no console.</p>\n<p>Na leitura seguinte, veremos como utilizar <em>asserts</em> nos seus testes, com\n<code>assert</code> de Node.js e com <code>Chai.assert</code>.</p>"
            }
          }
        },
        {
          "prefix": "03",
          "slug": "assertions",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Aserciones",
              "body": "<p>En las lecturas anteriores hemos visto como usar <code>mocha</code> para construir la\nestructura de qué queremos probar/testear, pero todavía nos falta hacer las\ncomprobaciones/aserciones que nos permitan verificar si el código que estamos\nprobando se comporta como esperamos.</p>\n<p>Para hacer esto usamos las <em>aserciones</em>. Una <em>aserción</em> no es más que un\npedacito de código que comprueba si un valor es el esperado, y en caso de que no\nlo sea lo reporte. De esta forma, si en el futuro cambiara algo en el\ncomportamiento del código, los tests nos permitirían ver exactamente qué.</p>\n<h2>Vanilla</h2>\n<p>Empecemos por implementar nuestra propia <em>aserción</em> de igualdad. Esto no es más\nque una función que compara dos valores para ver si son iguales, y en caso de\nque no lo sean bota un error con un mensaje informativo.</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`\n\nconst isVowel = require('./isVowel');\n\nconst assertEqual = (value, expected) => {\n  if (value !== expected) {\n    throw new Error(`Expected '${value}' to equal '${expected}'`);\n  }\n};\n\ndescribe('isVowel()', () => {\n\n  it('debería devolver true para letra a', () => {\n    assertEqual(isVowel('a'), true);\n  });\n\n  it('debería devolver false para letra a', () => {\n    assertEqual(isVowel('b'), false);\n  });\n\n});\n</code></pre>\n<p>Ejecutemos los tests otra vez.</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n    ✓ debería devolver true para letra a\n    ✓ debería devolver false para letra a\n\n\n  2 passing (8ms)\n\n</code></pre>\n<p>Ahora todo el output que vemos es producido por Mocha (ya no hay output que\nprovenga de nuestros <code>console.log</code>s), y vemos que ambos tests pasan.</p>\n<p>Solo para probar (y valga la redundancia) modifiquemos (mejor dicho rompamos) la\nimplementación de <code>isVowel</code> para ver que nuestros tests efectivamente reporten\nlos problemas.</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.js`\n\nconst isVowel = function (char) {\n  return ['b', 'e', 'i', 'o', 'u'].indexOf(char) > -1;\n};\n\nmodule.exports = isVowel;\n</code></pre>\n<p>Hemos cambiado la <code>a</code> por una <code>b</code>. Y nuestros tests ahora debería mostrar output\ncomo:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n    1) debería devolver true para letra a\n    2) debería devolver false para letra b\n\n\n  0 passing (7ms)\n  2 failing\n\n  1) isVowel()\n       debería devolver true para letra a:\n     Error: Expected 'false' to equal 'true'\n      at assertEqual (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:7:11)\n      at Context.it (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:14:5)\n\n  2) isVowel()\n       debería devolver false para letra b:\n     Error: Expected 'true' to equal 'false'\n      at assertEqual (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:7:11)\n      at Context.it (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:18:5)\n\n</code></pre>\n<p>Como vemos los tests se comportan como esperábamos!</p>\n<p>Este ejemplo es ilustrativo, pero en el mundo real probablemente no vas a querer\nimplementar tu propio código de aserciones (no solo de igualdad, si no todo tipo\nde comparaciones). Lo más común es usar una dependencia externa (una librería o\nmódulo) como veremos en los próximos ejemplos.</p>\n<h2>Módulo assert de Node.js</h2>\n<p>Node.js incluye su propio módulo de aserciones sin necesidad de tener que\ninstalar ninguna dependencia. Si estás corriendo tus tests en Node.js, es muy\ncomún usar este módulo (<code>assert</code>), a menos de que la librería o framework que\nestés usando ya incluya su propio sistema de aserciones (por ejemplo <code>Jest</code>).</p>\n<p>Reemplacemos nuestra función <code>assertEqual</code> con el módulo <code>assert</code> de Node.js:</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`\n\nconst assert = require('assert');\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('debería devolver true para letra a', () => {\n    assert.equal(isVowel('a'), true);\n  });\n\n  it('debería devolver false para letra a', () => {\n    assert.equal(isVowel('b'), false);\n  });\n\n});\n</code></pre>\n<p><a href=\"https://nodejs.org/api/assert.html\">Assert - Node.js Documentation</a></p>\n<h2>Chai.assert</h2>\n<p>Mocha no incluye una interfaz para aserciones, y en el navegador no tenemos el\nmódulo <code>assert</code> de Node.js. Así que es muy común usar Mocha en conjunto con\n<code>Chai</code>, que es una librería de aserciones que nos ofrece varias interfaces,\nentre ellas una muy parecida al <code>assert</code> de Node.js:</p>\n<pre><code class=\"language-js\">// Archivo `isVowel.spec.js`\n\nconst { assert } = require('chai');\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('debería devolver true para letra a', () => {\n    assert.equal(isVowel('a'), true);\n  });\n\n  it('debería devolver false para letra a', () => {\n    assert.equal(isVowel('b'), false);\n  });\n\n});\n</code></pre>\n<p><a href=\"http://chaijs.com/\">Chai - Documentación oficial</a></p>\n<h2>Lecturas complementarias</h2>\n<ul>\n<li><a href=\"https://medium.com/@hbarcelos/bdd-made-simple-in-node-js-with-mocha-and-chai-3a3ce44ecce2\">BDD made simple in Node.JS with Mocha and Chai - @hbarcelos en medium.com</a></li>\n</ul>"
            },
            "pt": {
              "title": "Asserts",
              "body": "<p>Nas leituras anteriores vimos como usar <code>mocha</code> para construir a estrutura que\nqueremos verificar/testar, mas contudo ainda nos falta fazer as\ncomprovações/asserções que permitam verificar se o código que estamos testando\nse comporta como esperamos.</p>\n<p>Para haver isso usamos as <em>asserções</em>. Uma <em>asserção</em> é um pedaço de código que\ncomprova se um valor é o esperado e no caso de não ser, avise-nos. Desta\nmaneira, se no futuro algo mudar no comportamento do código, os testes\npermitirão ver exatamente o quê.</p>\n<h2>Vanilla</h2>\n<p>Comecemos por implementar nossa própria <em>asserção</em> de igualdade. Isso não é mais\ndo que uma função que compara dois valores para ver se são iguais. Em caso\nnegativo, exibe um erro com uma mensagem informativa.</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`\n\nconst isVowel = require('./isVowel');\n\nconst assertEqual = (value, expected) => {\n  if (value !== expected) {\n    throw new Error(`Expected '${value}' to equal '${expected}'`);\n  }\n};\n\ndescribe('isVowel()', () => {\n\n  it('Deveria retornar true para a letra a', () => {\n    assertEqual(isVowel('a'), true);\n  });\n\n  it('Deveria retornar false para a letra b', () => {\n    assertEqual(isVowel('b'), false);\n  });\n\n});\n</code></pre>\n<p>Executemos os testes novamente.</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n    ✓ Deveria retornar true para a letra a.\n    ✓ Deveria retornar false para a letra b.\n\n\n  2 passing (8ms)\n\n</code></pre>\n<p>Agora toda a saída que vemos é produzido pelo Mocha (já não existe uma saída\noriunda de nossos <code>console.log</code>'s) e vemos que ambos os testes passam.</p>\n<p>Só para testar (e vale a redundância) modifiquemos (melhor dizer \"quebremos\") a\nimplementação de <code>isVowel()</code> para ver que nossos testes efetivamente reportam os\nproblemas.</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.js`\n\nconst isVowel = function (char) {\n  return ['b', 'e', 'i', 'o', 'u'].indexOf(char) > -1;\n};\n\nmodule.exports = isVowel;\n</code></pre>\n<p>Trocamos o <code>a</code> por um <code>b</code>. E nossos testes agora deveriam mostrar a saída como:</p>\n<pre><code class=\"language-sh\">$ mocha ./isVowel.spec.js\n\n\n  isVowel()\n    1) Deveria retornar true para a letra a.\n    2) Deveria retornar false para a letra b.\n\n\n  0 passing (7ms)\n  2 failing\n\n  1) isVowel()\n       Deveria retornar true para a letra a:\n     Error: Expected 'false' to equal 'true'\n      at assertEqual (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:7:11)\n      at Context.it (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:14:5)\n\n  2) isVowel()\n       Deveria retornar false para a letra b:\n     Error: Expected 'true' to equal 'false'\n      at assertEqual (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:7:11)\n      at Context.it (05-deep-dive/03-testing/03-assertions/files/isVowel-vanilla-assert.spec.js:18:5)\n\n</code></pre>\n<p>Como podemos ver, os testes se comportam como esperávamos!</p>\n<p>Este exemplo é ilustrativo, mas no mundo real provavelmente você não vai querer\nimplementar seu próprio código de asserções (não somente de igualdade, mas sim\ntodo o tipo de comparações). O mais comum é usar uma dependência externa (uma\nbiblioteca ou módulo) como veremos nos próximos exemplos.</p>\n<h2>Módulo <em>assert</em> de Node.js</h2>\n<p>Node.js contém seu próprio módulo de asserções sem necessidade de ter que\ninstalar nenhuma dependência. Se você estiver executando seus testes com\nNode.js, é muito comum utilizar este módulo (<code>assert</code>), a menos que a biblioteca\nou <em>framework</em> que estiver usando já contenham seus próprios sistemas de\nasserções (por exemplo, <code>Jest</code>).</p>\n<p>Troquemos nossa função <code>assertEqual</code> com o módulo <code>assert</code> de Node.js:</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`\n\nconst assert = require('assert');\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('Deveria retornar true para a letra a', () => {\n    assert.equal(isVowel('a'), true);\n  });\n\n  it('Deveria retornar false para a letra b', () => {\n    assert.equal(isVowel('b'), false);\n  });\n\n});\n</code></pre>\n<p><a href=\"https://nodejs.org/api/assert.html\">Documentação Assert - Node.js</a></p>\n<h2>Chai.assert</h2>\n<p>O Mocha não contém uma interface para asserções e no navegador não temos o\nmódulo <code>assert</code> de Node.js. Logo, é muito comum usar o Mocha em conjunto com\n<code>Chai</code>, que é uma biblioteca de asserções que nos oferece várias interfaces.\nEntre elas, uma muito parecida com o <code>assert</code> de Node.js:</p>\n<pre><code class=\"language-js\">// Arquivo `isVowel.spec.js`\n\nconst { assert } = require('chai');\nconst isVowel = require('./isVowel');\n\ndescribe('isVowel()', () => {\n\n  it('Deveria retornar true para a letra a', () => {\n    assert.equal(isVowel('a'), true);\n  });\n\n  it('Deveria retornar false para a letra b', () => {\n    assert.equal(isVowel('b'), false);\n  });\n\n});\n</code></pre>\n<p><a href=\"http://chaijs.com/\">Chai - Documentação oficial</a></p>\n<h2>Leituras complementares</h2>\n<ul>\n<li><a href=\"https://medium.com/@hbarcelos/bdd-made-simple-in-node-js-with-mocha-and-chai-3a3ce44ecce2\">BDD made simple in Node.JS with Mocha and Chai - @hbarcelos en\nmedium.com</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "browser",
          "type": "read",
          "duration": 15,
          "intl": {
            "es": {
              "title": "Tests en el navegador",
              "body": "<p>Hasta este punto hemos estado ejecutando nuestros tests con Node.js, pero como\nfront-end developers nos interesa también poder ejcutar nuestros tests en un\nentorno de navegador, con un <code>window</code> y un <code>DOM</code> de verdad. Esto nos va a\npermitir automatizar tests así como hacer <em>cross-browser</em> testing y probar\nnuestro código en distintos navegadores.</p>\n<p>Imagina que tienes una página web con una lista no ordenada (<code>ul</code>), algo así:</p>\n<pre><code class=\"language-html\">&#x3C;ul>\n  &#x3C;li>Betty Snyder Holberton&#x3C;/li>\n  &#x3C;li>Jean Jennings Bartik&#x3C;/li>\n  &#x3C;li>Kathleen McNulty Mauchly Antonelli&#x3C;/li>\n  &#x3C;li>Marlyn Wescoff Meltzer&#x3C;/li>\n  &#x3C;li>Ruth Lichterman Teitelbaum&#x3C;/li>\n  &#x3C;li>Frances Bilas Spence&#x3C;/li>\n&#x3C;/ul>\n</code></pre>\n<p>Y los usuarios te han estado pidiendo un <em>feature</em> para que los textos que\naparecen en la lista salgan con todas las vocales en mayúscula. Es una petición\nun poco extraña, pero la vida misma es muy extraña...</p>\n<p>Para implementar este <em>feature</em> acuerdas con tu equipo que necesitan una función\nque reciba un string y retorne otro string en el cual se hayan reemplazado todas\nlas vocales en minúsculas por mayúsculas. Necesitamos una función con la\nsiguiente firma (<em>signature</em>):</p>\n<pre><code class=\"language-js\">string makeVowelsUpperCase(string)\n</code></pre>\n<p>Si esta función existiera, sabemos que podríamos seleccionar los nodos que\nqueremos (los <code>&#x3C;li></code>) y remplazar su contenido con lo que retorne\n<code>makeVowelsUpperCase()</code> pasándole el contenido original.</p>\n<pre><code class=\"language-js\">[...document.querySelectorAll('li')]\n  .forEach(el => el.innerHTML = makeVowelsUpperCase(el.innerHTML));\n</code></pre>\n<p>Antes de asignarle a nadie la implementación de esta función, decidimos escribir\nalgunos tests para que sirvan de guía y describan el comportamiento esperado. En\nuna carpeta nueva, crea un archivo con el nombre <code>makeVowelsUpperCase.spec.js</code> y\nañade los siguientes tests:</p>\n<pre><code class=\"language-js\">describe('makeVowelsUpperCase()', () => {\n\n  it('debería convertir \"hola mundo\" en \"hOlA mUndO\"', () => {\n    assert.equal(makeVowelsUpperCase('hola mundo'), 'hOlA mUndO');\n  });\n\n  it('debería convertir \"Betty Snyder Holberton\" en \"BEtty SnydEr HOlbErtOn\"', () => {\n    assert.equal(\n      makeVowelsUpperCase('Betty Snyder Holberton'),\n      'BEtty SnydEr HOlbErtOn'\n    );\n  });\n\n});\n</code></pre>\n<p>Como punto de partida de la implementación, por ahora simplemente creemos un\narchivo con el nombre <code>makeVowelsUpperCase.js</code> en la misma carpeta donde creaste\nel archivo anterior con los tests. En este archivo por ahora solo vamos a\ndeclarar una función que recibe un argumento y retorna el argumento tal y como\nlo recibió.</p>\n<pre><code class=\"language-js\">const makeVowelsUpperCase = function (string) {\n  return string;\n};\n</code></pre>\n<p>Para poder ejecutar los tests en el navegador empecemos por crear un archivo\nHTML con el nombre <code>test.html</code>.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=utf-8>\n    &#x3C;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.css\" />\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;div id=\"mocha\">&#x3C;/div>\n    &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.js\">&#x3C;/script>\n    &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/chai/4.1.2/chai.min.js\">&#x3C;/script>\n    &#x3C;script src=\"./makeVowelsUpperCase.js\">&#x3C;/script>\n    &#x3C;script>\n      const { assert } = chai;\n      mocha.setup('bdd');\n    &#x3C;/script>\n    &#x3C;script src=\"./makeVowelsUpperCase.spec.js\">&#x3C;/script>\n    &#x3C;script>mocha.run();&#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>Este archivo HTML hace lo siguiente:</p>\n<ol>\n<li>\n<p>Añade la hoja de estilos de <code>mocha</code> desde el CDN de <a href=\"https://cdnjs.com/\">cdnjs</a></p>\n<pre><code class=\"language-html\">&#x3C;link\n  rel=\"stylesheet\"\n  href=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.css\"\n/>\n</code></pre>\n</li>\n<li>\n<p>Añade un <code>&#x3C;div></code> con <code>id=\"mocha\"</code> para que mocha escriba los resultados</p>\n<pre><code class=\"language-html\">&#x3C;div id=\"mocha\">&#x3C;/div>\n</code></pre>\n</li>\n<li>\n<p>Añade <code>mocha</code> y <code>chai</code> desde CDN de <a href=\"https://cdnjs.com/\">cdnjs</a></p>\n<pre><code class=\"language-html\">&#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.js\">&#x3C;/script>\n&#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/chai/4.1.2/chai.min.js\">&#x3C;/script>\n</code></pre>\n</li>\n<li>\n<p>Incluímos el código que queremos testear (el archivo\n<code>makeVowelsUpperCase.js</code>) que acabamos de crear.</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"./makeVowelsUpperCase.js\">&#x3C;/script>\n</code></pre>\n</li>\n<li>\n<p>Guardamos una referencia a <code>chai.assert</code> en la constante <code>assert</code> en entorno\nglobal para poder usar directamente <code>assert</code> en los tests (en vez de\n<code>chai.assert</code>);</p>\n<pre><code class=\"language-js\">const { assert } = chai;\n</code></pre>\n</li>\n<li>\n<p>Inicializa la interfaz BDD de <code>mocha</code></p>\n<pre><code class=\"language-js\">mocha.setup('bdd');\n</code></pre>\n</li>\n<li>\n<p>Incluimos todos los tests que queramos correr</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"./makeVowelsUpperCase.spec.js\">&#x3C;/script>\n</code></pre>\n</li>\n<li>\n<p>Finalmente ejecutamos los tests.</p>\n<pre><code class=\"language-js\">mocha.run();\n</code></pre>\n</li>\n</ol>\n<p>Ya tenemos un entorno donde ejecutar los tests en el navegador. Abre el archivo\n<code>test.html</code> en tu navegador y deberías ver algo así:</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/34898926-a840563a-f7c3-11e7-8872-c3f3a1f5339d.png\" alt=\"Output de Mocha en navegador\"></p>\n<p>Esto nos muestra que nuestros tests han corrido, pero la implementación actual\nde <code>makeVowelsUpperCase</code> no pasa los tests ya que no retorna los valores\nesperados.</p>\n<p>Ya estamos listos para asignarle el trabajo de implementar la función a una\ncompañera, quien tendrá clara cuál es la intención de la función y su\ncomportamiento esperado. Los tests le permitirán saber si la implementación se\najusta o no a los requerimientos.</p>\n<p>Continuemos imaginando... digamos que han pasado unos días y Pepita, una\ncompañera, nos envía una implementación de <code>makeVowelsUpperCase</code> para que la\nrevisemos. Antes de siquiera leer su código, primero vamos a ejecutar los tests.\nAsegúrate de reemplazar el código en el archivo <code>makeVowelsUpperCase.js</code> con el\nde Pepita:</p>\n<pre><code class=\"language-js\">const isVowel = function (char) {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n\n  for (let i = 0; i &#x3C; vowels.length; i++) {\n    if (char === vowels[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst makeVowelsUpperCase = function (string) {\n  let result = '';\n\n  for (let i = 0; i &#x3C; string.length; i++) {\n    if (isVowel(string[i])) {\n      result += string[i].toUpperCase();\n    } else {\n      result += string[i];\n    }\n  }\n\n  return result;\n};\n</code></pre>\n<p>Si ahora abrimos otra vez el archivo <code>test.html</code> veremos lo siguiente.</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/34899917-c8f6d402-f7c9-11e7-9e69-c00ed149d0e0.png\" alt=\"Output de Mocha en navegador con tests aprobados\"></p>\n<p>Parece que el código de Pepita pasa todos los tests :tada:</p>\n<hr>\n<p>Pero ahí no termina la historia... han pasado unos días, el código de Pepita ya\nestá en producción, y recibimos un reporte de un <em>bug</em>: las vocales con acento\nno se están transformando a mayúsculas! Gracias a que tenemos tests para esta\nfunción, podemos rápidamente escribir un nuevo test para replicar y confirmar\nel problema reportado, así que añadimos el siguiente test a nuestro archivo\n<code>makeVowelsUpperCase.spec.js</code>:</p>\n<pre><code class=\"language-js\">it('debería convertir vocales con acento', () => {\n  assert.equal(makeVowelsUpperCase('cómo estás?'), 'cÓmO EstÁs?');\n});\n</code></pre>\n<p>Si volvemos a ejecutar los test podemos ver que efectivamente el nuevo test no\npasa:</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/34906409-37ba7ecc-f83b-11e7-9500-10b5d1b49842.png\" alt=\"image\"></p>\n<p>En la siguiente lectura veremos como arreglar esto.</p>"
            },
            "pt": {
              "title": "Testes no navegador",
              "body": "<p>Até este ponto estivemos executando nossos testes com Node.js, mas como\n<em>front-end developers</em> também é interessante executar nossos testes em um\nambiente de navegador, com um <code>window</code> e com um <code>DOM</code> de verdade. Isto nos\npermitirá automatizar testes assim como fazer <em>cross-browser testing</em> e validar\nnosso código em navegadores diferentes.</p>\n<p>Imagine que você tenha uma página web com uma lista ordenada (<code>ul</code>), algo assim:</p>\n<pre><code class=\"language-html\">&#x3C;ul>\n  &#x3C;li>Betty Snyder Holberton&#x3C;/li>\n  &#x3C;li>Jean Jennings Bartik&#x3C;/li>\n  &#x3C;li>Kathleen McNulty Mauchly Antonelli&#x3C;/li>\n  &#x3C;li>Marlyn Wescoff Meltzer&#x3C;/li>\n  &#x3C;li>Ruth Lichterman Teitelbaum&#x3C;/li>\n  &#x3C;li>Frances Bilas Spence&#x3C;/li>\n&#x3C;/ul>\n</code></pre>\n<p>E os usuários estão solicitando uma <em>feature</em> para que os textos que aparecem na\nlista saiam com todas as vogais em maiúscula. É um pedido meio estranho, mas a\nprópria vida é muito estranha...</p>\n<p>Para implementar esta <em>feature</em> você combina com sua equipe que precisam de uma\nfunção que receba uma string e retorna outra string na qual todas as vogais\ntenham sido trocadas de minúsculas para maiúsculas. Precisamos de uma função com\na seguinte assinatura (<em>signature</em>):</p>\n<pre><code class=\"language-js\">string makeVowelsUpperCase(string)\n</code></pre>\n<p>Se esta função existisse, sabemos que poderíamos selecionar os nós que queremos\n(os <code>&#x3C;li></code>) e trocar seu conteúdo com o retorno de <code>makeVowelsUpperCase()</code>\npassado o conteúdo original como argumento.</p>\n<pre><code class=\"language-js\">[...document.querySelectorAll('li')]\n  .forEach(el => el.innerHTML = makeVowelsUpperCase(el.innerHTML));\n</code></pre>\n<p>Antes de atribuir a alguém a implementação desta função, decidimos escrever\nalguns testes para que sirvam de guia e descrevam o comportamento esperado. Em\numa nova pasta, crie um arquivo com o nome <code>makeVowelsUpperCase.spec.js</code> e\nadicione os testes a seguir:</p>\n<pre><code class=\"language-js\">describe('makeVowelsUpperCase()', () => {\n\n  it('Deveria converter \"olá mundo\" em \"OlÁ mUndO\"', () => {\n    assert.equal(makeVowelsUpperCase('olá mundo'), 'OlÁ mUndO');\n  });\n\n  it('Deveria converter \"Betty Snyder Holberton\" em \"BEtty SnydEr HOlbErtOn\"', () => {\n    assert.equal(\n      makeVowelsUpperCase('Betty Snyder Holberton'),\n      'BEtty SnydEr HOlbErtOn'\n    );\n  });\n\n});\n</code></pre>\n<p>Como ponto de partida para a implementação, por enquanto simplesmente criamos um\narquivo com o nome <code>makeVowelsUpperCase.js</code> na mesma pasta onde você criou o\narquivo anterior com os testes. Neste arquivo por enquanto só vamos declarar uma\nfunção que recebe um argumento e retorna o argumento tal como o recebeu.</p>\n<pre><code class=\"language-js\">const makeVowelsUpperCase = function (string) {\n  return string;\n};\n</code></pre>\n<p>Para poder executar os testes no navegador comecemos criando um arquivo HTML com\no nome <code>test.html</code>.</p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;meta charset=utf-8>\n    &#x3C;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.css\" />\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;div id=\"mocha\">&#x3C;/div>\n    &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.js\">&#x3C;/script>\n    &#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/chai/4.1.2/chai.min.js\">&#x3C;/script>\n    &#x3C;script src=\"./makeVowelsUpperCase.js\">&#x3C;/script>\n    &#x3C;script>\n      const { assert } = chai;\n      mocha.setup('bdd');\n    &#x3C;/script>\n    &#x3C;script src=\"./makeVowelsUpperCase.spec.js\">&#x3C;/script>\n    &#x3C;script>mocha.run();&#x3C;/script>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>Neste arquivo HTML faça o seguinte:</p>\n<ol>\n<li>\n<p>Adicione a folha de estilo de <code>mocha</code> a partir do CDN de\n<a href=\"https://cdnjs.com/\">cdnjs</a>:</p>\n<pre><code class=\"language-html\">&#x3C;link\n  rel=\"stylesheet\"\n  href=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.css\"\n/>\n</code></pre>\n</li>\n<li>\n<p>Adicione um <code>&#x3C;div></code> com <code>id=\"mocha\"</code> para que o Mocha escreva os resultados:</p>\n<pre><code class=\"language-html\">&#x3C;div id=\"mocha\">&#x3C;/div>\n</code></pre>\n</li>\n<li>\n<p>Adicione <code>mocha</code> e <code>chai</code> a partir do CDN de <a href=\"https://cdnjs.com/\">cdnjs</a>:</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/4.1.0/mocha.min.js\">&#x3C;/script>\n&#x3C;script src=\"https://cdnjs.cloudflare.com/ajax/libs/chai/4.1.2/chai.min.js\">&#x3C;/script>\n</code></pre>\n</li>\n<li>\n<p>Incluímos o código que queremos testar (o arquivo <code>makeVowelsUpperCase.js</code>)\nque acabamos de criar:</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"./makeVowelsUpperCase.js\">&#x3C;/script>\n</code></pre>\n</li>\n<li>\n<p>Criamos uma referência para o <code>chai.assert</code> na constante <code>assert</code> no ambiente\nglobal para podermos usar diretamente <code>assert</code> nos testes (ao invés de\n<code>chai.assert</code>):</p>\n<pre><code class=\"language-js\">const { assert } = chai;\n</code></pre>\n</li>\n<li>\n<p>Inicialize a interface BDD de <code>mocha</code>:</p>\n<pre><code class=\"language-js\">mocha.setup('bdd');\n</code></pre>\n</li>\n<li>\n<p>Incluímos todos os testes que queremos executar:</p>\n<pre><code class=\"language-html\">&#x3C;script src=\"./makeVowelsUpperCase.spec.js\">&#x3C;/script>\n</code></pre>\n</li>\n<li>\n<p>Finalmente executamos os testes:</p>\n<pre><code class=\"language-js\">mocha.run();\n</code></pre>\n</li>\n</ol>\n<p>Já temos um ambiente para executar os estes no navegador. Abra o arquivo\n<code>test.html</code> no seu navegador. Você deve ver algo assim:</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/34898926-a840563a-f7c3-11e7-8872-c3f3a1f5339d.png\" alt=\"Output de Mocha no\nnavegador\"></p>\n<p>Isto nos mostra que nossos testes foram executados, mas a implementação atual de\n<code>makeVowelsUpperCase</code> não passa nos testes já que não retorna os valores\nesperados.</p>\n<p>Já estamos prontas para atribuir-lhe o trabalho de implementar a função com uma\ncolega, a qual terá clara qual a intenção da função e seu comportamento\nesperado. Os testes permitirão saber se a implementação se adequa aos\nrequerimentos.</p>\n<p>Continuemos imaginando... digamos que alguns dias se passará e Pepita, uma\ncolega, envia-nos uma implementação de <code>makeVowelsUpperCase</code> para que revisemos.\nAntes de sequer lermos o código, primeiro vamos executar os testes. Tenha\ncerteza de substituir o código no arquivo <code>makeVowelsUpperCase.js</code> com o enviado\npor Pepita:</p>\n<pre><code class=\"language-js\">const isVowel = function (char) {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n\n  for (let i = 0; i &#x3C; vowels.length; i++) {\n    if (char === vowels[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst makeVowelsUpperCase = function (string) {\n  let result = '';\n\n  for (let i = 0; i &#x3C; string.length; i++) {\n    if (isVowel(string[i])) {\n      result += string[i].toUpperCase();\n    } else {\n      result += string[i];\n    }\n  }\n\n  return result;\n};\n</code></pre>\n<p>Se agora abrirmos outra vez o arquivo <code>test.html</code> veremos o seguinte:</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/34899917-c8f6d402-f7c9-11e7-9e69-c00ed149d0e0.png\" alt=\"Output de Mocha no navegador com testes\naprovados\"></p>\n<p>Parece que o código de Pepita passa em todos os testes :tada:</p>\n<hr>\n<p>Mas aqui não termina a história... mais uns dias se passaram, o código de Pepita\njá está em produção e recebemos um chamado de um <em>bug</em>: as vogais com acento não\nestão sendo trocadas por maiúsculas! Como temos testes para esta função, podemos\nescrever rapidamente um novo teste para replicar e confirmar o problema\nrelatado, assim que adicionamos o seguinte teste em nosso arquivo\n<code>makeVowelsUpperCase.spec.js</code>:</p>\n<pre><code class=\"language-js\">\nit('Deveria converter vogais com acento', () => {\n  assert.equal(makeVowelsUpperCase('como está?'), 'cOmO EstÁ?');\n});\n</code></pre>\n<p>Se executarmos o testes podemos ver que de fato o novo teste não passa:</p>\n<p><img src=\"https://user-images.githubusercontent.com/110297/34906409-37ba7ecc-f83b-11e7-9500-10b5d1b49842.png\" alt=\"imagem\"></p>\n<p>Na leitura seguinte veremos como consertar isso.</p>"
            }
          }
        },
        {
          "prefix": "10",
          "slug": "closing",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Cierre",
              "body": "<h2>Resumen</h2>\n<p>Llegamos al final de la unidad ;-)</p>\n<h2>Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Qué es un test?</li>\n<li>Qué es un framework de testing?</li>\n<li>Cómo escribir tests usando la interfaz BDD (<code>describe()</code>, <code>it()</code>, ...) de\n<code>mocha</code>.</li>\n<li>Cómo usar la librería standard de Node.js para aserciones con el módulo\n<code>assert</code>.</li>\n<li>Cómo usar las aserciones de <code>chai</code>.</li>\n</ul>"
            },
            "pt": {
              "title": "Encerramento",
              "body": "<h2>Resumo</h2>\n<p>Chegamos ao final da unidade 😃</p>\n<h2>Respondamos juntas as perguntas da abertura</h2>\n<ul>\n<li>O que é um teste?</li>\n<li>O que é um <em>framework</em> de <em>testing</em>?</li>\n<li>Como escrever testes usando a interface BDD (<code>describe()</code>, <code>it()</code>, ...) do <code>mocha</code>?</li>\n<li>Como usar a biblioteca padrão de Node.js para atribuições com o módulo <code>assert</code>?</li>\n<li>Como usar os <em>asserts</em> do <code>chai</code>?</li>\n<li>Como executar testes no ambiente do navegador de forma automatizada com <code>karma</code>?</li>\n</ul>"
            }
          }
        }
      ]
    }
  ]
}
