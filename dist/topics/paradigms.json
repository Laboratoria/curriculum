{
  "slug": "paradigms",
  "createdAt": "2023-02-13T19:48:47.007Z",
  "cover": null,
  "thumb": "data:image/png;base64,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",
  "title": "Paradigmas de programación",
  "description": "<p>Los <strong>Paradigmas de Programación</strong> (<em>Programming Paradigms</em>) son formas\ndiferentes de pensar en cómo se organiza un programa basado en una serie de\nprincipios, los cuales resultan en estilos muy distintos y lenguajes muy\ndiversos.</p>\n<p><strong>JavaScript</strong> es un leguage <em>híbrido</em>, por decirlo de alguna forma, y contiene\nelementos propios de lenguajes funcionales (por ejemplo funciones como objetos\nde primera clase, lambdas, ...) pero no estamos limitados al paradigma\nfuncional, si no que en su dinamismo y rareza, <strong>JavaScript nos permite\nprogramar de forma <em>funcional</em>, <em>orientado a objetos</em>, <em>orientado a eventos</em>,\n<em>por procedimientos</em>, ...</strong></p>\n<p>Como desarrolladora <strong>Full Stack JS</strong> es esencial entender los distintos\nparadigmas de programación y cómo se traducen al mundo real en proyectos de\nJavaScript.</p>\n<p>Históricamente, el paradigma orientado a objetos (OOP) ha sido el predominante,\npero recientemente, y en particular en la comunidad de JavaScript, hay un\nresurgir del paradigma funcional y sus bondades. <strong>JavaScript es un lenguaje de\ncorazón funcional</strong>, así que conocer el paradigma, y cómo se compara a la\nprogramación orientada a objetos, no sólo te hará una mejor coder, si no que\npodrás entender cómo se pueden enfrentar los mismos problemas con enfoques\ndistintos, e identificar y adaptarse a bases de código existentes.</p>\n",
  "tags": {
    "secondary": {},
    "primary": {}
  },
  "targetAudience": "<p>Este curso está pensado para estudiantes que ya se han familiarizado con la\nprogramación en JavaScript y quieren llevar su conocimiento sobre el lenguaje\na otro nivel, entendiendo diferentes formas de &quot;pensar&quot; en cómo se estructura\nun programa.</p>\n",
  "dependencies": "<p>Se asume que las estudiantes ya han trabajado con variables, valores (tipos de\ndatos), arreglos, objetos y funciones así como estructuras de control de flujo\n(bucles, condicionales, ...).</p>\n<p>Durante este curso se hará uso de algunas características de <strong>ES2015</strong>, así que\nun mínimo de familiaridad con <code>const</code>, <code>let</code>, <em>arrow-functions</em>,\n<em>deconstrucción</em> de objetos y la notación <em>shorthand</em> de objetos son un plus.</p>\n",
  "learningObjectives": "<ul>\n<li>Qué son los <strong>paradigmas de programación</strong></li>\n<li>Qué son <strong>FP</strong>, <strong>OOP</strong>, <strong>EOP</strong> y <strong>PP</strong> y cómo se comparan</li>\n<li>A entender las diferencias entre el estilo <strong>imperativo vs declarativo</strong></li>\n<li>Las diferencias entre <strong>constructores</strong> y <strong>factories</strong></li>\n<li>Cómo implementar <strong>herencia prototipal</strong></li>\n<li>Los principios básicos de la <strong>programación funcional</strong></li>\n<li>A usar <strong>composición</strong> como alternativa a la <em>herencia</em></li>\n</ul>\n",
  "product": "",
  "syllabus": {
    "01-paradigms": {
      "title": "Introducción a Paradigmas de Programación",
      "bonus": false,
      "description": "<p>En esta lección aprenderás las características y diferencias entre los\nparadigmas más relevantes para <strong>JavaScript</strong>, que es un lenguaje\nmulti-paradigma y nos permite programar en varios estilos: imperativo, por\nprocedimientos, orientado a objetos (OOP), funcional (FP), ...</p>\n",
      "parts": {
        "00-opening": {
          "title": "Apertura",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<h2 id=\"¿por-qué-aprender-esto\">¿Por qué aprender esto?</h2>\n<p>Como indica el nombre del curso, vamos a hablar de <em>Paradigmas de programación</em>,\nque son formas diferentes de pensar en cómo se organiza un programa.</p>\n<p>Como desarrollador <strong>Full Stack JS</strong> es esencial entender los distintos\nparadigmas de programación y cómo se traducen al mundo real en proyectos de\nJavaScript.</p>\n<p>Históricamente, el paradigma orientado a objetos (OOP) ha sido el predominante,\npero recientemente, y en particular en la comunidad de JavaScript, hay un\nresurgir del paradigma funcional y sus bondades. <strong>JavaScript es un lenguaje de\ncorazón funcional</strong>, así que conocer el paradigma, y cómo se compara a la\nprogramación orientada a objetos, no sólo te hará una mejor coder, si no que\npodrás entender cómo se pueden enfrentar los mismos problemas con enfoques\ndistintos, e identificar y adaptarse a bases de código existentes.</p>\n<p>En este curso nos concentraremos en los paradigmas más relevantes para\nJavaScript y cómo se materializan en este contexto.</p>\n<h2 id=\"guía-de-preguntas-y-conceptos-clave\">Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Qué son los <strong>paradigmas de programación</strong>?</li>\n<li>Qué es el estilo <strong>imperativo</strong></li>\n<li>Qué es el estilo <strong>declarativo</strong></li>\n<li>Qué paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el\n<strong>declarativo</strong></li>\n<li>Qué es la <strong>programación por procedimientos</strong>?</li>\n<li>Qué es la <strong>programación orientada a objetos</strong>?</li>\n<li>Qué es la <strong>programación funcional</strong>?</li>\n<li>Cómo se aplican los diferentes paradigmas al mundo de JavaScript?</li>\n<li>Cómo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>\n<li>Cómo programar en los diferentes estilos</li>\n</ul>\n",
          "order": 0,
          "durationString": "5min"
        },
        "01-overview": {
          "title": "¿Qué son los paradigmas de programación?",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/6frz31ykmi?wvideo=6frz31ykmi",
              "id": "6frz31ykmi"
            },
            {
              "type": "video",
              "provider": "youtube",
              "href": "https://www.youtube.com/watch?v=sqV3pL5x8PI",
              "id": "sqV3pL5x8PI"
            },
            {
              "type": "video",
              "provider": "youtube",
              "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
              "id": "4A2mWqLUpzw"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/6frz31ykmi?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>Los <strong>Paradigmas de Programación</strong> (<em>Programming Paradigms</em>) son formas\ndiferentes de pensar en cómo se organiza un programa basado en una serie de\nprincipios, los cuales resultan en estilos muy distintos y lenguajes muy\ndiversos.</p>\n<p>Consideremos la siguiente función:</p>\n<pre><code class=\"language-js\">function sum(array) {\n  let total = 0;\n  for (let i = 0; i &lt; array.length; i++) {\n    total += array[i];\n  }\n  return total;\n}\n</code></pre>\n<p>La función <code>sum(array)</code> recibe un array de números y retorna la suma de todos\nlos elementos del array. Para llevar a cabo la suma, usamos la variable <code>total</code>,\nla cual vamos a ir actualizando (mutando) mientras vamos recorriendo el arreglo\ncon un bucle (<code>for</code> en este caso). Estas características son típicas del estilo\nimperativo.</p>\n<p>Ahora, podemos implementar exactamente la misma funcionalidad usando un enfoque\ncompletamente distinto.</p>\n<pre><code class=\"language-js\">function sum(array) {\n  if (!array.length) {\n    return 0;\n  }\n  return array[0] + sum(array.slice(1));\n};\n</code></pre>\n<p>En esta segunda implementación, la función <code>sum(array)</code> sigue teniendo la misma\ninterfaz (recibe los mismos argumentos y retorna lo mismo), pero claramente\npodemos ver que la lógica se expresa de una manera muy diferente. En la versión\nrecursiva hemos reemplazado el bucle <code>for</code> por recursión, y además podemos ver\nque no hay asignación ni mutación de variables, el \"cómputo\" se hace por\naplicación de argumentos a funciones. Este tipo de características son propias\ndel paradigma funcional.</p>\n<hr>\n<p>PRO TIP:</p>\n<p>Haciendo uso de ES2015 podemos refactorizar la versión funcional de <code>sum</code> de\nesta manera:</p>\n<pre><code class=\"language-js\">const sum = array =&gt; !array.length ? 0 : array[0] + sum(array.slice(1));\n</code></pre>\n<hr>\n<p>Cuando hablamos de <strong>Paradigmas de Programación</strong> inevitablemente tenemos que\nhablar de lenguajes de programación. Algunos lenguajes, como JavaScript, son\n<em>multi-paradigma</em>, lo que quiere decir que nos permiten programar en diferentes\nparadigmas, mientras que otros se enfocan específicamente en uno.</p>\n<p><strong>JavaScript</strong> es un leguage <em>híbrido</em>, por decirlo de alguna forma, y contiene\nelementos propios de lenguajes funcionales (por ejemplo funciones como objetos\nde primera clase, lambdas, ...) pero no estamos limitados al paradigma\nfuncional. <strong>JavaScript nos permite programar de forma <em>funcional</em>, <em>orientado a\nobjetos</em>, <em>orientado a eventos</em>, <em>por procedimientos</em>, ...</strong></p>\n<p>También veremos que los \"paradigmas\" son \"estilos\" de programación que no son\nnecesariamente exclusivos. De hecho, algunos son complementarios o evoluciones\nde paradigmas más antiguos o con un nivel de abstracción más bajo. Así, la\nprogramación procedural y orientada a objetos, por ejemplo, ambas son\nimperativas, ya que comparten una raíz común.</p>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Blog posts:</p>\n<ul>\n<li><a href=\"http://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/\" target=\"_blank\">Six programming paradigms that will change how you think about coding</a>,\nYevgeniy Brikman, Apr 09 2014</li>\n</ul>\n<p>Videos:</p>\n<ul>\n<li><div class=\"iframe-container\"><iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/sqV3pL5x8PI?autoplay=0\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen=\"true\"></iframe></div>,\n<code>10:43</code>, <a href=\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\" target=\"_blank\">Computerphile</a>,\n30 Aug 2013</li>\n<li><div class=\"iframe-container\"><iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen=\"true\"></iframe></div>,\n<code>8:27</code>, <a href=\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\" target=\"_blank\">Computerphile</a>,\nJun 28 2016</li>\n<li><a href=\"https://www.video2brain.com/mx/tutorial/que-es-un-paradigma-de-programacion\" target=\"_blank\">Qué es un paradigma de programación</a>,\n<code>5:15</code>, José Dimas Luján Castillo, <a href=\"https://www.video2brain.com/\" target=\"_blank\">video2brain</a>,\n8 Mar 2017</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Programming_paradigm\" target=\"_blank\">Definición de Programming_paradigm en Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Comparison_of_programming_paradigms\" target=\"_blank\">Comparativa de paradigmas de programación en Wikipedia</a></li>\n</ul>\n",
          "order": 1,
          "durationString": "5min"
        },
        "02-history": {
          "title": "Historia",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/an9covln5w?wvideo=an9covln5w",
              "id": "an9covln5w"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/an9covln5w?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>Para tener una idea general de los paradigmas y sus peculiaridades, es útil\nrepasar brevemente su historia.</p>\n<p>El primer paradigma en aparecer, primera mitad de los años 50, es el\n<strong>imperativo</strong>, que se caracteriza por un nivel bajo de abstracción. Por lo\ntanto el código está enfocado en las instrucciones que la computadora debe\nseguir, y no necesariamente en la semántica o lógica de la funcionalidad que\nestamos implementando (el cómo nosotros pensamos en lo que hace el programa).</p>\n<p>Veamos un ejemplo de <code>Assembly</code>, el primer lenguaje \"moderno\", que apareció en\nel año 1949, y que sigue vivo a día de hoy, eso sí, para cosas muy específicas,\nque nos son necesariamente lo que vemos los desarrolladores web, pero que sirve\npara este ejemplo ;-)</p>\n<pre><code class=\"language-assembly_x86\">section .text             ;section declaration\n\n                          ;we must export the entry point to the ELF linker or\n  global  _start          ;loader. They conventionally recognize _start as their\n                          ;entry point. Use ld -e foo to override the default.\n\n_start:\n\n                          ;write our string to stdout\n\n  mov     edx,len         ;third argument: message length\n  mov     ecx,msg         ;second argument: pointer to message to write\n  mov     ebx,1           ;first argument: file handle (stdout)\n  mov     eax,4           ;system call number (sys_write)\n  int     0x80            ;call kernel\n\n                          ;and exit\n\n  mov     ebx,0           ;first syscall argument: exit code\n  mov     eax,1           ;system call number (sys_exit)\n  int     0x80            ;call kernel\n\nsection .data             ;section declaration\n\nmsg db    \"Hello, world!\",0xa    ;our dear string\nlen equ   $ - msg                ;length of our dear string\n</code></pre>\n<p><a href=\"http://www.tldp.org/HOWTO/Assembly-HOWTO/hello.html\" target=\"_blank\">Fuente: Assembly-HOWTO</a></p>\n<p>El snippet de arriba es un \"hello world\" escrito en <code>Assembly</code> (una versión\nmoderna, pero muy parecido a lo que hubieras visto en los años 50). Lo único que\nhace este programa es imprimir el string <code>Hello, world!</code>. El equivalente a todo\nel código de arriba en JavaScript sería:</p>\n<pre><code class=\"language-js\">console.log('Hello, world!');\n</code></pre>\n<p>En nuestro caso, JavaScript tiene un nivel de abstracción mucho más alto. Con lo\ncual, no tenemos que preocuparnos de muchos detalles que JavaScript ya abstrae\npara nosotros, como manejo de memoria, instrucciones del procesador, etc. Esto\nnos permite expresar de forma más \"humana\" la intención de nuestro programa, y\ncon mucho menos código.</p>\n<p>Regresamos a los años 50. Según la programación va evolucionando, y los\nprogramas creciendo, vemos cómo van a ir surgiendo diferentes formas de\n\"abstraer\", \"organizar\" y \"reusar\" el código. A finales de los años 50 vemos\ncomo aparecen <strong>Fortran II</strong> y <strong>Lisp</strong>, introduciendo la programación\n<strong>procedural</strong> y <strong>funcional</strong>. Con ambos enfoques pasamos a nuevos nieveles de\nabstracción y mejora en el reuso de código.</p>\n<p>En los años 70 y 80 se da el boom de la programación orientada a objetos,\nprimero con <strong>Smalltalk</strong> y después <strong>C++</strong>.</p>\n<p><strong>JavaScript</strong> nace en 1995, el mismo año que <strong>Java</strong>, <strong>Ruby</strong> y <strong>PHP</strong>. La\ndécada de los 90 se caracteriza por los lenguajes multi-paradigma. En ese\ncontexto JavaScript destaca por su dinamismo y su naturaleza funcional. De hecho\na nivel conceptual, JavaScript está fuertemente inspirado por <strong>Scheme</strong>, que es\nun lenguaje funcional, y los prototipos de <strong>Self</strong>, aunque por necesidades del\nmercado, la sintáxis se parece más a la familia de lenguajes de <strong>C</strong> y\n<strong>Java</strong>, que son imperativos. Por esta razón, JavaScript se considera muchas\nveces <a href=\"http://javascript.crockford.com/javascript.html\" target=\"_blank\">el lenguaje más\nincomprendido</a>, y quizás\nconfuso.</p>\n<p>Como referencia, abajo podemos ver una tabla con algunos de los lenguajes más\nsignificativos a nivel de cambios de paradigma, y el conexto en el que aparece\nJavaScript.</p>\n<table>\n<thead>\n<tr>\n<th>Año</th>\n<th>Lenguaje</th>\n<th>Paradigma</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1949</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Assembly_language\" target=\"_blank\">Assembly</a></td>\n<td>imperativo</td>\n</tr>\n<tr>\n<td>1957</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Fortran\" target=\"_blank\">Fortran</a></td>\n<td>imperativo</td>\n</tr>\n<tr>\n<td>1958</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Fortran#FORTRAN_II\" target=\"_blank\">Fortran II</a></td>\n<td>imperativo, procedural</td>\n</tr>\n<tr>\n<td>1958</td>\n<td><a href=\"https://goo.gl/ZbUXeg\" target=\"_blank\">Lisp</a></td>\n<td>funcional</td>\n</tr>\n<tr>\n<td>1965</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Simula\" target=\"_blank\">Simula</a></td>\n<td>orientado a objetos</td>\n</tr>\n<tr>\n<td>1972</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Smalltalk\" target=\"_blank\">Smalltalk</a></td>\n<td>orientado a objetos</td>\n</tr>\n<tr>\n<td>1972</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Prolog\" target=\"_blank\">Prolog</a></td>\n<td>lógico</td>\n</tr>\n<tr>\n<td>1972</td>\n<td><a href=\"https://goo.gl/4bnEHY\" target=\"_blank\">C</a></td>\n<td>imperativo, procedural, estructurado</td>\n</tr>\n<tr>\n<td>1975</td>\n<td><a href=\"https://goo.gl/x2WMht\" target=\"_blank\">Scheme</a></td>\n<td>funcional</td>\n</tr>\n<tr>\n<td>1983</td>\n<td><a href=\"https://en.wikipedia.org/wiki/C%2B%2B\" target=\"_blank\">C++</a></td>\n<td>imperativo, procedural, estructurado, orientado a objetos</td>\n</tr>\n<tr>\n<td>1987</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Perl\" target=\"_blank\">Perl</a></td>\n<td>imperativo, procedural, funcional, orientado a objetos, orientado a eventos</td>\n</tr>\n<tr>\n<td>1991</td>\n<td><a href=\"https://goo.gl/bJ9Wcg\" target=\"_blank\">Python</a></td>\n<td>imperativo, procedural, funcional, orientado a objetos</td>\n</tr>\n<tr>\n<td>1995</td>\n<td><a href=\"https://goo.gl/PhfLjJ\" target=\"_blank\">Ruby</a></td>\n<td>imperativo, funcional, orientado a objetos</td>\n</tr>\n<tr>\n<td>1995</td>\n<td><a href=\"https://goo.gl/aWjoSR\" target=\"_blank\">Java</a></td>\n<td>imperativo, orientado a objetos</td>\n</tr>\n<tr>\n<td>1995</td>\n<td><a href=\"https://en.wikipedia.org/wiki/PHP\" target=\"_blank\">PHP</a></td>\n<td>imperativo, procedural, orientado a objetos</td>\n</tr>\n<tr>\n<td>1995</td>\n<td><a href=\"https://en.wikipedia.org/wiki/JavaScript\" target=\"_blank\">JavaScript</a></td>\n<td>imperativo, funcional, orientado a objetos, orientado a eventos</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/History_of_programming_languages\" target=\"_blank\">History of programming languages</a></li>\n</ul>\n",
          "order": 2,
          "durationString": "5min"
        },
        "03-declarative-vs-imperative": {
          "title": "Declarativo vs Imperativo",
          "type": "read",
          "format": "self-paced",
          "duration": 15,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/ty5mr7p77t?wvideo=ty5mr7p77t",
              "id": "ty5mr7p77t"
            },
            {
              "type": "video",
              "provider": "youtube",
              "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
              "id": "4A2mWqLUpzw"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/ty5mr7p77t?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>Hemos mencionado que los primeros lenguajes de programación eran imperativos, y\nque se centraban en el \"cómo\" más que en el \"qué\". Como contrapartida, el estilo\ndeclarativo se caracteriza por lo contrario, enfocarse más en \"qué\" queremos\nhacer, desde el punto de vista de un ser humano, en vez de cómo lo debe ejecutar\nla computadora. Por ende, cuanto más declarativo, más alejado del hardware.</p>\n<p>Algunos paradigmas son más imperativos y otros más declarativos. Por ejemplo,\nla programación orientada a procedimientos, o la programación orientada objetos,\nvan a tener un caracter imperativo, mientras que la programación funcional tiene\nun caracter mucho más declarativo.</p>\n<p>Imáginemos que tenemos la siguiente data en un array de objetos:</p>\n<pre><code class=\"language-js\">const array = [\n  {id: 'uno', name: 'el primero'},\n  {id: 'dos', name: 'el segundo'},\n  {name: 'no tengo id'},\n];\n</code></pre>\n<p>A partir de esta data, ahora nos piden extraer los <code>id</code> de cada un de los\nobjetos y amacenarlos en un nuevo arreglo (<code>ids</code>). Si nos planteamos el\nproblema desde un enfoque imperativo, podríamos implementar una solución así:</p>\n<pre><code class=\"language-js\">const ids = [];\n\nfor (let i = 0; i &lt; array.length; i++) {\n  if (array[i].id) {\n    ids.push(array[i].id);\n  }\n}\n\nconsole.log(ids); // ['uno', 'dos']\n</code></pre>\n<p>En el código anterior, probablemente puedas identificar claramente el estilo\nimperativo. Las variables como \"contadores\" y \"acumuladores\", son típicos del\nestilo imperativo. En este estilo el principal mecanismo de cómputo se lleva a\ncabo a través de la asignación de valores en variables. Veremos así uso de\nvariables globales y mutación de los valores asignados a variables a través del\ntiempo.</p>\n<p>JavaScript nos ofrece utilidades para afrontar este tipo problemas desde el\nenfoque funcional. Así, los arrays (gracias a <code>Array.prototype</code>) tienen una\nserie de métodos para manipular su data a través de \"higher order functions\",\nque en este caso son funciones que aceptan otra función como argumento, como por\nejemplo <code>Array.prototype.filter</code> o <code>Array.prototype.map</code>. Veamos cómo podemos\nusar estas herramientas para implementar la misma lógica:</p>\n<pre><code class=\"language-js\">const ids = array\n  .filter(item =&gt; typeof item.id === 'string')\n  .map(item =&gt; item.id);\n\nconsole.log(ids); // ['uno', 'dos']\n</code></pre>\n<p>En esta nueva versión hacemos lo siguiente:</p>\n<ol>\n<li>Usamos <code>Array#filter</code> para crear un nuevo arreglo sólo con aquellos elementos\nque tengan un <code>id</code> que sea un string (<code>typeof item.id === 'string'</code>).</li>\n<li>Usamos <code>Array#map</code> para transformar cada elemento del arreglo y crear un\nnuevo arreglo con los resultados.</li>\n</ol>\n<p>De esta forma los detalles de la iteración quedan escondidos detrás de\n<code>Array#filter</code> y <code>Array#map</code>, haciendo nuestro código más declarativo.</p>\n<p>También podemos ver cómo \"encadenamos\" (method chaining) las invocaciones de\n<code>filter</code> y <code>map</code> ya que ambas retornan un array, que a su vez tiene todos los\nmétodos de <code>Array.prototype</code>.</p>\n<p>El estilo declarativo depende de que el lenguaje (o librerías) nos ofrezcan este\ntipo de herramientas o abstracciones con las que poder expresar nuestra lógica\nsin preocuparnos tanto sobre los detalles de implementación.</p>\n<p>Para terminar esta sección, cabe mencionar que HTML es un lenguaje declarativo!\nMuchos se quejarían diciendo que HTML no es un lenguaje de programación, sino un\nlenguaje de marcado (<em>markup language</em>). Pero podemos considerear a HTML como un\nlenguaje declarativo muy restringido, no de uso general, donde sólo podemos\ncrear un árbol de nodos a partir de una estructura de etiquetas (<em>tags</em>) con una\nsintáxis y semántica predefinida. Es declarativo en el sentido de que no le\nestamos diciendo a la computadora cómo convertir nuestro código en\ninstrucciones, sino que describimos de formal declarativa lo que queremos que\nocurra (el compilador o intérprete se encarga del resto).</p>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Videos:</p>\n<ul>\n<li><div class=\"iframe-container\"><iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen=\"true\"></iframe></div>,\n<code>8:27</code>, <a href=\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\" target=\"_blank\">Computerphile</a>,\nJun 28 2016</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Imperative_programming\" target=\"_blank\">Imperative programming</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Declarative_programming\" target=\"_blank\">Declarative programming</a></li>\n</ul>\n",
          "order": 3,
          "durationString": "15min"
        },
        "04-imperative-exercise": {
          "title": "Ejercicio imperativo",
          "type": "practice",
          "format": "self-paced",
          "duration": 5,
          "exercises": {
            "01-print-primes": {
              "title": "Imprime los número enteros menores que 20",
              "env": "js",
              "body": "<p>La programación imperativa tiene un nivel de abstracción bajo, lo que quiere\ndecir que se enfoca en describir, desde el punto de vista de la computadora,\ncómo hacer lo que queremos. Nuestro código expresa de forma explícita el control\nde flujo, usando bucles, declara variables para llevar la cuenta, ...</p>\n<p>En el mundo real, en un lenguaje como JavaScript, vamos a encontrar\ncaracterísticas de este paradigma, pero siempre en el contexto de otro paradigma\ncon un nivel de abtracción más alto y un mecanismo de reuso de código (cómo la\nprogramación orientada a objetos o la prgramación funcional).</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>El <em>boilerplate</em> (la plantilla sobre la que hacer el ejercicio) contiene un\nprograma sin terminar. Este programa debe <strong>imprimir en la consola todos los\nnúmeros primos menores que <code>20</code></strong>.</p>\n<p>El <em>boilerplate</em> impementa sólo parte de la lógica. Por el momento imprime todos\nlos números enteros del <code>2</code> al <code>19</code>. Ahora tienes que añadir la lógica para\ncomprobar si un número es primo o no, y así sólo imprimir los primos.</p>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Debes implementar un bucle <code>for</code> anidado dentro del <code>for</code> ya existente.</li>\n</ul>\n<h2 id=\"pistas\">Pistas</h2>\n<ul>\n<li>Si un número es divisible por cualquier entero mayor que <code>1</code> que no sea el\nnúmero mismo, sabemos que NO es primo.</li>\n<li>Dentro del bucle <code>for</code> principal, para ver si un número es primo, vamos a\ntratar de demostrar que NO es primo, y si no podemos probar que no es primo,\nentonces podemos asumir que sí es primo.</li>\n<li>El operador <code>%</code> nos da el residuo de una división.</li>\n<li>Una vez que hemos probado que un número no es primo ya no necesitamos\ncontinuar dividiéndolo.</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://goo.gl/zn7cTu\" target=\"_blank\">Arithmetic Operators: Remainder - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for\" target=\"_blank\">Statements: for - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Imprime los número enteros menores que 20\n\n* Environment: `js`\n\n***\n\nLa programación imperativa tiene un nivel de abstracción bajo, lo que quiere\ndecir que se enfoca en describir, desde el punto de vista de la computadora,\ncómo hacer lo que queremos. Nuestro código expresa de forma explícita el control\nde flujo, usando bucles, declara variables para llevar la cuenta, ...\n\nEn el mundo real, en un lenguaje como JavaScript, vamos a encontrar\ncaracterísticas de este paradigma, pero siempre en el contexto de otro paradigma\ncon un nivel de abtracción más alto y un mecanismo de reuso de código (cómo la\nprogramación orientada a objetos o la prgramación funcional).\n\n## Tarea\n\nEl _boilerplate_ (la plantilla sobre la que hacer el ejercicio) contiene un\nprograma sin terminar. Este programa debe **imprimir en la consola todos los\nnúmeros primos menores que `20`**.\n\nEl _boilerplate_ impementa sólo parte de la lógica. Por el momento imprime todos\nlos números enteros del `2` al `19`. Ahora tienes que añadir la lógica para\ncomprobar si un número es primo o no, y así sólo imprimir los primos.\n\n## Requisitos\n\n* Debes implementar un bucle `for` anidado dentro del `for` ya existente.\n\n## Pistas\n\n* Si un número es divisible por cualquier entero mayor que `1` que no sea el\n  número mismo, sabemos que NO es primo.\n* Dentro del bucle `for` principal, para ver si un número es primo, vamos a\n  tratar de demostrar que NO es primo, y si no podemos probar que no es primo,\n  entonces podemos asumir que sí es primo.\n* El operador `%` nos da el residuo de una división.\n* Una vez que hemos probado que un número no es primo ya no necesitamos\n  continuar dividiéndolo.\n\n## Recursos\n\n* [Arithmetic Operators: Remainder - MDN](https://goo.gl/zn7cTu)\n* [Statements: for - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)\n",
                "Ym9pbGVycGxhdGU=": {
                  "cHJpbnRQcmltZXMuanM=": "function printPrimes() {\n  // Iteramos desde 2 (el primer número primo) hasta 19 (menor que 20)\n  for (let i = 2; i < 20; i++) {\n    let isPrime = true;\n\n    // Ahora debemos iterar desde `2` hasta `i / 2` usando una variable `j` como\n    // contador.\n    //\n    // Para cada `j` comprueba si la división `i / j` deja un residuo.\n    //\n    // NOTA: No necesitamos probar números más allá de `i / 2` porque el\n    // resultado de la división `i / j` siempre sería una fracción entre 2 y 1,\n    // siempre dejando residuo.\n\n    // TU CÓDIGO AQUÍ\n\n    if (isPrime) {\n      console.log(i);\n    }\n  }\n}\n\nmodule.exports = printPrimes;\n"
                },
                "c29sdXRpb24=": {
                  "cHJpbnRQcmltZXMuanM=": "function printPrimes() {\n  for (let i = 2; i < 20; i++) {\n    let isPrime = true;\n    for (let j = 2; j <= (i / 2); j++) {\n      if (i % j === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      console.log(i);\n    }\n  }\n}\n\nmodule.exports = printPrimes;\n"
                },
                "dGVzdA==": {
                  "cHJpbnRQcmltZXMuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/printPrimes');\n\n\ndescribe('printPrimes()', () => {\n\n  const stub = Sinon.stub(console, 'log');\n  Submission();\n  stub.restore();\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería invocar console.log 8 veces', () => {\n    Assert.equal(stub.callCount, 8);\n  });\n\n  [[2], [3], [5], [7], [11], [13], [17], [19]].forEach((args, idx) => {\n    it(`invocación ${idx + 1} a console.log debería recibir \"${args[0]}\" como único argumento`, () => {\n      Assert.deepEqual(args, stub.getCall(idx).args);\n    });\n  });\n\n});\n"
                }
              }
            }
          },
          "order": 4,
          "durationString": "5min"
        },
        "05-procedural": {
          "title": "Programación por procedimientos",
          "type": "read",
          "format": "self-paced",
          "duration": 6,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/el19ibmhpj?wvideo=el19ibmhpj",
              "id": "el19ibmhpj"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/el19ibmhpj?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>La programación por procedimientos (<em>procedural programming</em>) pertenece a la\nrama del estilo <em>imperativo</em>. Antes mencionamos que a finales de los años 50\nFortran II introduce la programación por procedimientos, y de esa forma\nempezamos a \"organizar\", \"abstraer\" y \"reusar\" nuestro código.</p>\n<p>Cuando programamos orientados a procedimientos, lo cual puede ser un enfoque\nválido para ciertos programas o scripts, nos concentramos en agrupar código\nen procedimientos o funciones, e invocar estos procedimientos con diferentes\nargumentos o parámetros. En este sentido es parecido a la programación\nfuncional, pero con la diferencia de que nos mantenemos en la rama imperativa,\ndescribiendo acciones como pasos secuenciales, que podrían tener efectos\nsecundarios y donde el output no está necesariamente deterinado por los\nargumentos de entrada. Mientras que la programación funcional es más abstracta,\nse basa en funciones puras sin efectos secundarios, evitar el estado compartido,\ny otros principios específicos de la programación funcional.</p>\n<p>Refactoricemos el ejemplo anterior donde sacábamos la propiedad <code>id</code> de una\nlista de objetos. Empecemos por envolver el código en una función:</p>\n<pre><code class=\"language-js\">function getIds(inputArray) {\n  const ids = [];\n\n  for (let i = 0; i &lt; inputArray.length; i++) {\n    if (inputArray[i].id) {\n      ids.push(inputArray[i].id);\n    }\n  }\n\n  return ids;\n}\n\nconsole.log(getIds(array)); // ['uno', 'dos']\n</code></pre>\n<p>Este cambio parece menor, pero añade una capa de abstracción que nos da un\nmontón de flexibilidad. Ahora nuestro código está <em>encapsulado</em> dentro de su\npropio <em>scope</em> y podemos reusar la lógica para otros arrays (podemos invocar la\nfunción cuantas veces queramos).</p>\n<p>Pero vayamos un paso más allá. Ahora que estamos ordenando nuestro código usando\nfunciones, aprovechemos a abstraer y mejorar la comprobación que hacíamos para\nsaber si un objeto tiene una propiedad <code>id</code>.</p>\n<pre><code class=\"language-js\">function hasId(obj) {\n  return obj &amp;&amp; typeof obj.id === 'string';\n}\n\nfunction getIds(inputArray) {\n  const ids = [];\n\n  for (let i = 0; i &lt; inputArray.length; i++) {\n    if (hasId(inputArray[i])) {\n      ids.push(inputArray[i].id);\n    }\n  }\n\n  return ids;\n}\n\nconsole.log(getIds(array)); // ['uno', 'dos']\nconsole.log(hasId()); // false\nconsole.log(hasId({name: 'foo'})); // false\nconsole.log(hasId({id: 'uno'})); // true\n</code></pre>\n<p>En esta nueva versión hemos partido el código en dos funciones, y al hacerlo\nhemos tenido que dar nombres a estas funciones. Estos nombres representan de\nalguna forma esa capa de abstracción. Ahora podemos hablar de <code>hasId()</code>\ncuando queremos referirnos a ese pedacito de lógica. Así, poco a poco vamos\ncreando una semántica que nos permite alejarnos de los detalles de\nimplementación.</p>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Procedural_programming\" target=\"_blank\">Procedural programming</a></li>\n</ul>\n",
          "order": 5,
          "durationString": "6min"
        },
        "06-modules": {
          "title": "Modularidad",
          "type": "read",
          "format": "self-paced",
          "duration": 6,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/ph5zkst0fv?wvideo=ph5zkst0fv",
              "id": "ph5zkst0fv"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/ph5zkst0fv?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>Una de las consecuencias de estos cambios es el concepto de \"modularidad\". Esto\nva a permitir que empecemos a escribir programas estructurados en módulos\nindependientes, que son más fáciles de entender, testear, mantener, ...</p>\n<p>En JavaScript existen varios sistemas de módulos, principalmente <strong>AMD</strong>,\n<strong>Common JS</strong> y <strong>ES2015/ES6</strong>. Para este ejemplo vamos a concentrarnos en\n<strong>Common JS</strong>, que es el que usa <strong>Node.js</strong>, y que también podemos usar en el\nnavegador gracias a los <em>bundlers</em>. En nuestro ejemplo, ahora que nuestro código\nvive dentro de una función, podríamos <em>exportar</em> la función, lo que nos\npermitiría usar esta función desde otros scripts u otros programas. Esto es\nesencial para casi cuaquier programa o script hoy en día, con consecuencias que\ndamos por sentado como poder organizar nuestro código en archivos y carpetas\ndiferentes o tener dependecias de módulos externos.</p>\n<p>Para exportar nuestra función <code>getIds</code> usando Common JS en Node.js, podemos\nsimplemente asignar nuestra función a <code>module.exports</code>.</p>\n<pre><code class=\"language-js\">// al final del script\nmodule.exports = getIds;\n</code></pre>\n<p>El objeto <code>module</code> es una variable local a cada script en Common JS. Si\nasignamos algo a <code>module.exports</code>, éste será el valor que recibiremos cuando\nrequiramos nuestro \"módulo\". Por ejemplo, imaginemos que salvamos el script en\nel archivo <code>src/getIds.js</code>, y ahora lo queremos usar desde otro script afuera de\n<code>src/</code>:</p>\n<pre><code class=\"language-js\">const getIds = require('./src/getIds');\n// `getIds` tiene el valor que hemos exportado a través de `module.exports`\n// en el script `src/getIds.js`\n</code></pre>\n<p>Common JS también nos ofrece la opción de exportar los valores que queramos\ncomo propiedades del objeto <code>exports</code> (que es un alias de <code>module.exports</code>). Así\nen vez de exportar sólo un valor (la función <code>getids</code>), podemos exporar varios\nvalores.</p>\n<pre><code class=\"language-js\">exports.getIds = getIds;\nexports.hasId = hasId;\n</code></pre>\n<p>Ahora cuando requerimos nuestro módulo desde otro script lo que recibimos es\nun objeto (el objeto <code>exports</code>), que tiene dos propiedades, <code>getIds</code> y <code>hasId</code>.</p>\n<pre><code class=\"language-js\">const myModule = require('./src/myModule');\n// myModule.getIds()\n// myModule.hasId()\n</code></pre>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Blog posts:</p>\n<ul>\n<li><a href=\"http://2ality.com/2014/09/es6-modules-final.html\" target=\"_blank\">ECMAScript 6 modules: the final syntax</a>,\nAxel Rauschmayer, 07 Sep 2014</li>\n<li><a href=\"https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\" target=\"_blank\">JavaScript Modules: A Beginner’s Guide</a>,\nPreethi Kasireddy (FreeCodeCamp), Jan 22 2016</li>\n</ul>\n",
          "order": 6,
          "durationString": "6min"
        },
        "07-procedural-exercise": {
          "title": "Ejercicio por procedimientos",
          "type": "practice",
          "format": "self-paced",
          "duration": 10,
          "exercises": {
            "01-get-primes": {
              "title": "getPrimes()",
              "env": "js",
              "body": "<p>La programación <em>procedural</em> (por procedimientos) introduce el concepto de\nprocedimientos o funciones que nos permiten agrupar instrucciones, y así reusar\nbloques de código e invocarlos con diferentes valores.</p>\n<p>Según va creciendo un programa, vamos a tener la necesidad de organizar nuestro\ncódigo en pedacitos comprensibles, además de abstraer repetición. La\nprogramación por procedimientos representa un primer paso de abstracción, lo que\nnos obliga a tener que dar nombres a estos procedimientos, encapsularlos, y\ndefinir sus interfaces (input/output).</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Refactoriza el código que vimos en el ejercicio anterior en dos funciones:</p>\n<ul>\n<li><code>getPrimes(start, end)</code></li>\n<li><code>isPrime(num)</code></li>\n</ul>\n<p>Ya hemos envuelto el código en una función con el nombre <code>getPrimes</code>.</p>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>La función <code>getPrimes()</code> recibe dos argumentos: <code>start</code> y <code>end</code>, que nos deben\npermitir especificar el rango de números primos que nos interesa.</li>\n<li>La función <code>getPrimes()</code> debe retornar un <code>array</code> con los números primos en\nvez de imprimirlos en la consola. Para ello usa una variable donde ir gurdando\nlos números primos que vayamos encontrando y al final de la función devuelve\n(retorna) ese array.</li>\n<li>En el bucle de <code>getPrimes()</code>, tendrás que sustituir el valor inicial de <code>i</code>\npor <code>start</code> y la condición por <code>i &lt; end</code>.</li>\n<li>Dentro del bucle de <code>getPrimes()</code> ya no necesitamos la variable <code>isPrime</code>,\nahora debes invocar a la función <code>isPrime()</code> para determinar si el número en\ncuestión es primo.</li>\n<li>El bucle que en el ejercicio anterior usamos para comprobar si un número es\nprimo, ahora debe quedar dentro de <code>isPrime()</code>, la cual sólo ha de recibir un\nargumento (el número a comprobar) y retornar un booleano (<code>true</code> o <code>false</code>).</li>\n<li>Asegúrate de que tu script exporta las funciones <code>getPrimes()</code> e <code>isPrime()</code>.</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions\" target=\"_blank\">Functions - MDN</a></li>\n<li><a href=\"https://nodejs.org/api/modules.html#modules_the_module_object\" target=\"_blank\">The module object - Node.js Docs</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# getPrimes()\n\n* Environment: `js`\n\n***\n\nLa programación _procedural_ (por procedimientos) introduce el concepto de\nprocedimientos o funciones que nos permiten agrupar instrucciones, y así reusar\nbloques de código e invocarlos con diferentes valores.\n\nSegún va creciendo un programa, vamos a tener la necesidad de organizar nuestro\ncódigo en pedacitos comprensibles, además de abstraer repetición. La\nprogramación por procedimientos representa un primer paso de abstracción, lo que\nnos obliga a tener que dar nombres a estos procedimientos, encapsularlos, y\ndefinir sus interfaces (input/output).\n\n## Tarea\n\nRefactoriza el código que vimos en el ejercicio anterior en dos funciones:\n\n* `getPrimes(start, end)`\n* `isPrime(num)`\n\nYa hemos envuelto el código en una función con el nombre `getPrimes`.\n\n## Requisitos\n\n* La función `getPrimes()` recibe dos argumentos: `start` y `end`, que nos deben\n  permitir especificar el rango de números primos que nos interesa.\n* La función `getPrimes()` debe retornar un `array` con los números primos en\n  vez de imprimirlos en la consola. Para ello usa una variable donde ir gurdando\n  los números primos que vayamos encontrando y al final de la función devuelve\n  (retorna) ese array.\n* En el bucle de `getPrimes()`, tendrás que sustituir el valor inicial de `i`\n  por `start` y la condición por `i < end`.\n* Dentro del bucle de `getPrimes()` ya no necesitamos la variable `isPrime`,\n  ahora debes invocar a la función `isPrime()` para determinar si el número en\n  cuestión es primo.\n* El bucle que en el ejercicio anterior usamos para comprobar si un número es\n  primo, ahora debe quedar dentro de `isPrime()`, la cual sólo ha de recibir un\n  argumento (el número a comprobar) y retornar un booleano (`true` o `false`).\n* Asegúrate de que tu script exporta las funciones `getPrimes()` e `isPrime()`.\n\n## Recursos\n\n* [Functions - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions)\n* [The module object - Node.js Docs](https://nodejs.org/api/modules.html#modules_the_module_object)\n",
                "Ym9pbGVycGxhdGU=": {
                  "Z2V0UHJpbWVzLmpz": "function isPrime(num) {\n  //...\n}\n\nfunction getPrimes(start, end) {\n  for (let i = 2; i < 20; i++) {\n    let isPrime = true;\n\n    //...\n\n    if (isPrime) {\n      console.log(i);\n    }\n  }\n}\n"
                },
                "c29sdXRpb24=": {
                  "Z2V0UHJpbWVzLmpz": "function isPrime(num) {\n  for (let i = 2; i <= (num / 2); i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getPrimes(start, end) {\n  const primes = [];\n  for (let i = start; i < end; i++) {\n    if (isPrime(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n}\n\nexports.getPrimes = getPrimes;\nexports.isPrime = isPrime;\n"
                },
                "dGVzdA==": {
                  "Z2V0UHJpbWVzLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/getPrimes');\n\n\ndescribe('getPrimes(start, end)', () => {\n\n  it('debería exportar función `getPrimes`', () => {\n    Assert.equal(typeof Submission.getPrimes, 'function');\n  });\n\n  it('debería retornar los número primos menores de 20', () => {\n    Assert.deepEqual(Submission.getPrimes(2, 20), [2, 3, 5, 7, 11, 13, 17, 19]);\n  });\n\n  it('debería retornar los número primos entre 50 y 100', () => {\n    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n  });\n\n});\n\n\ndescribe('isPrime(num)', () => {\n\n  it('debería exportar función `isPrime`', () => {\n    Assert.equal(typeof Submission.isPrime, 'function');\n  });\n\n  it('debería retornar true para 2, 3, 5, 13, 89', () => {\n    [2, 3, 5, 13, 89].forEach(n => Assert.deepEqual(Submission.isPrime(n), true));\n  });\n\n  it('debería retornar false para ', () => {\n    [4, 10, 99, 411].forEach(n => Assert.deepEqual(Submission.isPrime(n), false));\n  });\n\n  it('debería retornar los número primos entre 50 y 100', () => {\n    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n  });\n\n});\n"
                }
              }
            }
          },
          "order": 7,
          "durationString": "10min"
        },
        "08-oop": {
          "title": "OOP",
          "type": "read",
          "format": "self-paced",
          "duration": 15,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/8id6wdxrdn?wvideo=8id6wdxrdn",
              "id": "8id6wdxrdn"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/8id6wdxrdn?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>La <strong>Programación Orientada a Objetos</strong> (<em>Object Oriented Programming</em> - OOP)\nrepresenta un cambio de paradigma bastante grande con respecto al paradigma por\nprocedimientos que acabamos de ver. Cuando programamos por procedimientos nos\nconcentramos en funciones, que representan acciones, y así nuestra semántica\nestá orientada a acciones antes que a estructuras de datos.</p>\n<p>En la programación orientada a objetos le damos la vuelta a la tortilla, y en\nvez de pensar en acciones nos enfocamos en definir los \"tipos\" de datos primero,\ny después decidimos que interacciones van a tener. En OOP diseñamos objetos, que\nvan a tener una data (un estado) y una serie de operaciones que pueden realizar.</p>\n<p>A la hora de construir aplicaciones nos vemos obligados a pensar en cómo\n\"modelar\" o representar en código cosas del mundo real o conceptos útiles para\nun ser humano (un usuario, un documento, ...) y la programación orientada a\nobjetos propone crear tipos de objetos para representar estas cosas.</p>\n<p>Imaginemos que tenemos que escribir una aplicación de \"notas\" donde el usuario\npuede crear diferentes tipos de \"notas\", marcarlas como completadas, ... Si\nvamos a seguir el estilo orientado a objetos, normalmente empezaríamos por\nmodelar el \"tipo de objeto\" que con el que vamos a representar una \"nota\".\nPodríamos empezar con algo así:</p>\n<pre><code class=\"language-js\">function Note(text) {\n  this.text = text || '';\n  this.createdAt = new Date();\n  this.completed = false;\n}\n</code></pre>\n<p>Hemos declarado una función (<code>Note</code>) que hace uso de una <em>pseudo variable</em>\nllamada <code>this</code>. La presencia de <code>this</code>, junto con la convención de usar la\nprimera letra en mayúscula, nos indican que esta función está escrita\npara ser invocada con el <em>keyword</em> <code>new</code>. Este tipo de función es lo que\nconocemos como un <em>constructor</em>. Los constructores son funciones cuyo propósito\nes crear un objeto, inicializarlo y ofrecernos una manera de especificar el\nprototipo que tendrán los objetos creados con este constructor. Dicho de otra\nmanera, menos correcta pero más común, los constructores son lo más parecido a\nclases en JavaScript (por lo menos hasta ES6).</p>\n<p>JavaScript es un lenguaje dinámicamente tipado (<em>dynamically typed</em>), pero a\ndiferencia de la mayoría de lenguajes de su generación, usa herencia prototipal\nen vez de clases, lo cual suele confundir a muchos programadores con experiencia\nen otros lenguajes orientados a objetos.</p>\n<p>Cuando invocamos un constructor precedido de <code>new</code>, la pseudo-variable <code>this</code> es\nuna referencia al nuevo objeto creado al invocar el constructor. Creemos un\nobjeto para ver que significa todo esto:</p>\n<pre><code class=\"language-js\">const note = new Note('comprar arroz');\nconsole.log(note);\n</code></pre>\n<p>En la consola deberías de ver algo así:</p>\n<pre><code class=\"language-text\">Note {\n  text: 'comprar arroz',\n  createdAt: 2017-06-14T22:39:51.987Z,\n  completed: false }\n</code></pre>\n<p>Podemos ver que <code>note</code> es un objeto con tres propiedades (<code>text</code>, <code>createdAt</code> y\n<code>completed</code>). Estas tres propiedades están declaradas directamente sobre la\ninstancia.</p>\n<p>Cuando usamos constructores, es importante acordarnos de usar <code>new</code> a la hora de\ninvocarlos, si no, el constructor retornará <code>undefined</code>.</p>\n<pre><code class=\"language-js\">const note = Note('comprar arroz');\nconsole.log(note); // undefined\n</code></pre>\n<p>Hemos dicho que una de las características fundamentales de OOP es que empezamos\npor definir los tipos de datos (ya sea con clases, constructores, prototipos,\n...), lo cual nos permite inspeccionar los objetos creados para saber si son\nuna instacia de un constructor (con el operador <code>instanceof</code>) o comprobar si un\nobjeto está en la cadena de prototipos de otro objeto\n(<code>Object.prototype.isPrototypeOf</code>).</p>\n<pre><code class=\"language-js\">console.log(note instanceof Note); // true\nconsole.log(Note.prototype.isPrototypeOf(note)); // true\n</code></pre>\n<p>Ahora que ya hemos definido un constructor que inicializa una serie de\npropiedades, podemos usar el prototipo del constructor (<code>Note.prototype</code>) para\nañadir funcionalidad. Todo lo que le añadamos a <code>Note.prototype</code> será parte del\nprototipo de los objetos creados por <code>new Note()</code>. Añadamos un método al\nprototipo de <code>Note</code>:</p>\n<pre><code class=\"language-js\">Note.prototype.toString = function () {\n  let str = '[' + (this.completed ? 'X' : ' ') + ']';\n  str += ' | ' + this.createdAt.toDateString();\n  str += ' | ' + this.text;\n  return str;\n};\n</code></pre>\n<p>Hemos añadido el método <code>Note.prototype.toString</code>, que simplemente retorna una\nrepresentación de nuestro objeto como string. Ahora todos los objetos que\ncreemos con <code>new Note()</code> deberían de \"heredar\" un método <code>toString</code>. Si hacemos\n<code>console.log(note)</code> veremos las tres propiedades que seteamos en el constructor,\npero qué pasó con el método <code>toString</code> que le habíamos  añadimo al prototipo de\n<code>Note</code>?</p>\n<p>Inspeccionemos un poco...</p>\n<pre><code class=\"language-js\">console.log(note.prototype); // undefined\nconsole.log(note.__proto__); // Note { toString: [Function] }\nconsole.log(note.toString); // [Function]\n</code></pre>\n<p>El objeto <code>note</code> sí tiene el método <code>toString</code>, pero no directamente sobre la\ninstancia, si no que está en su prototipo. Cuando tratamos de acceder a una\npropiedad que no existe en un objeto, JavaScript va a buscar a ver si hay una\npropiedad con ese nombre en el prototipo del objeto, si la encuentra usará esa,\nsi no buscará en el prototipo del prototipo, y así irá recorriendo lo que\nconocemos como la cadena de prototipos (prototype chain).</p>\n<p>En la programación orientada a objetos el principal mecanismo de reuso de código\nes la \"herencia\", donde un objeto \"hereda\" una serie de propiedades y métodos\nde otro objeto o clase (en herencia prototipal heredamos directamente de un\nobjeto en vez de una clase).</p>\n<p>En la próxima unidad de este curso exploraremos los detalles de cómo implementar\njerarquías de herencia usando prototipos. Por el momento nos quedamos con estos\nconceptos.</p>\n<p>Ahora que hemos visto qué es la programación orientada a objetos en el contexto\nde JavaScript, concluyamos con una lista de características que definen a OOP de\nforma más general, por el propio Alan Kay, creador del término OOP y Smalltalk:</p>\n<blockquote>\n<p>Traducido al español:</p>\n<ul>\n<li>Todo es un objeto</li>\n<li>Los objetos se comunican enviando y recibiendo mensajes (en términos de objetos)</li>\n<li>Los objetos deben tener su propia memoria (en términos de objetos)</li>\n<li>Todo objeto es una instancia de una clase (que debe ser un objeto)</li>\n<li>La clase tiene el comportamiento compartido para las instancias (como objetos\nen un programa)</li>\n<li>Para evaluar un programa, se pasa el control al primer objeto y el resto se\ntrata como su mensaje.</li>\n</ul>\n<p>Original en inglés:</p>\n<ul>\n<li>Everything Is An Object</li>\n<li>Objects communicate by sending and receiving messages (in terms of objects).</li>\n<li>Objects have their own memory (in terms of objects).</li>\n<li>Every object is an instance of a class (which must be an object).</li>\n<li>The class holds the shared behavior for its instances (in the form of objects\nin a program list)</li>\n<li>To eval a program list, control is passed to the first object and the\nremainder is treated as its message.</li>\n</ul>\n<p>Fuente <a href=\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\" target=\"_blank\">Alan Kays Definition Of Object Oriented</a></p>\n</blockquote>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Blog posts:</p>\n<ul>\n<li><a href=\"https://css-tricks.com/understanding-javascript-constructors/\" target=\"_blank\">Understanding JavaScript Constructors</a>,\nFaraz Kelhini, CSS Tricks, Sep 24 2015</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\" target=\"_blank\">Alan Kays Definition Of Object Oriented</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\">Object-oriented programming</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\">MDN - instanceof</a></li>\n</ul>\n",
          "order": 8,
          "durationString": "15min"
        },
        "09-oop-exercise": {
          "title": "Ejercicio OOP",
          "type": "practice",
          "format": "self-paced",
          "duration": 10,
          "exercises": {
            "01-notes": {
              "title": "Notes (OOP)",
              "env": "js",
              "body": "<p>En la programación orientada a objetos (OOP), nos concentramos en describir\nobjetos, que tienen una data (un estado) y una serie de operaciones que pueden\nrealizar.</p>\n<p>Imaginemos que estamos construyendo una aplicación de \"notas\", donde el usuario\npuede añadir notas con un texto. Antes de empezar a implementar tratamos de\nimaginarnos los objetos que participan de este proceso. Lo primero que se nos\nviene a la mente es que vamos a necesitar objetos de tipo \"nota\".</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>El boilerplate contiene dos constructores (<code>Note</code> y <code>Notes</code>). El primero\n(<code>Note</code>) ya está implemetado. Ahora nos piden implementar los métodos\n<code>Notes.prototype.add</code> y <code>Notes.prototype.toString</code>.</p>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<p>Una vez implementado el ejercicio, alguien que importe tu módulo debería de\npoder hacer lo siguiente:</p>\n<pre><code class=\"language-js\">const note1 = new Note('hola');\nconst note2 = new Note('mundo');\nconst notes = new Notes();\n\nnotes.add(note1);\nnotes.add(note2);\n\nconsole.log(notes.toString());\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [ ] | Mon Jun 12 2017 | hola\n\nnote1.completed = true;\n\nconsole.log(notes.toString());\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [X] | Mon Jun 12 2017 | hola\n</code></pre>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li><code>Notes.prototype.add</code> debe botar error (throw) si el argumento (<code>note</code>) no es\nuna instancia de <code>Note</code>.</li>\n<li><code>Notes.prototype.add</code> debe añadir nuevas notas al principio de <code>this.data</code>, no\nal final.</li>\n<li>La implementación de <code>Notes.prototype.toString</code> debe iterar sobre las notas e\ninvocar <code>toString</code> en cada nota y así ir concatenando el resultado. El string\nque retornes debe contener una línea para cada nota (ver ejemplo).</li>\n<li>El método <code>Notes.prototype.toString</code> debe listar las notas ordenadas por fecha\nde creación descendente, la última añadida debe aparecer primero.</li>\n<li>No olvides exportar los constructores <code>Note</code> y <code>Notes</code>.</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\">Operators: instanceof - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\" target=\"_blank\">Array#unshift - MDN</a></li>\n<li><a href=\"https://css-tricks.com/understanding-javascript-constructors/\" target=\"_blank\">Understanding JavaScript Constructors - CSS Tricks</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Notes (OOP)\n\n* Environment: `js`\n\n***\n\nEn la programación orientada a objetos (OOP), nos concentramos en describir\nobjetos, que tienen una data (un estado) y una serie de operaciones que pueden\nrealizar.\n\nImaginemos que estamos construyendo una aplicación de \"notas\", donde el usuario\npuede añadir notas con un texto. Antes de empezar a implementar tratamos de\nimaginarnos los objetos que participan de este proceso. Lo primero que se nos\nviene a la mente es que vamos a necesitar objetos de tipo \"nota\".\n\n## Tarea\n\nEl boilerplate contiene dos constructores (`Note` y `Notes`). El primero\n(`Note`) ya está implemetado. Ahora nos piden implementar los métodos\n`Notes.prototype.add` y `Notes.prototype.toString`.\n\n## Ejemplo\n\nUna vez implementado el ejercicio, alguien que importe tu módulo debería de\npoder hacer lo siguiente:\n\n```js\nconst note1 = new Note('hola');\nconst note2 = new Note('mundo');\nconst notes = new Notes();\n\nnotes.add(note1);\nnotes.add(note2);\n\nconsole.log(notes.toString());\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [ ] | Mon Jun 12 2017 | hola\n\nnote1.completed = true;\n\nconsole.log(notes.toString());\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [X] | Mon Jun 12 2017 | hola\n```\n\n## Requisitos\n\n* `Notes.prototype.add` debe botar error (throw) si el argumento (`note`) no es\n  una instancia de `Note`.\n* `Notes.prototype.add` debe añadir nuevas notas al principio de `this.data`, no\n  al final.\n* La implementación de `Notes.prototype.toString` debe iterar sobre las notas e\n  invocar `toString` en cada nota y así ir concatenando el resultado. El string\n  que retornes debe contener una línea para cada nota (ver ejemplo).\n* El método `Notes.prototype.toString` debe listar las notas ordenadas por fecha\n  de creación descendente, la última añadida debe aparecer primero.\n* No olvides exportar los constructores `Note` y `Notes`.\n\n## Recursos\n\n* [Operators: instanceof - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)\n* [Array#unshift - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)\n* [Understanding JavaScript Constructors - CSS Tricks](https://css-tricks.com/understanding-javascript-constructors/)\n",
                "Ym9pbGVycGxhdGU=": {
                  "bm90ZXMuanM=": "function Note(text) {\n  this.text = text || '';\n  this.createdAt = new Date();\n  this.completed = false;\n}\n\n// Convierte note en un string con este formato:\n// [X] | Mon Jun 12 2017 | mundo\nNote.prototype.toString = function () {\n  let str = '[' + (this.completed ? 'X' : ' ') + ']';\n  str += ' | ' + this.createdAt.toDateString();\n  str += ' | ' + this.text;\n  return str;\n};\n\n\nfunction Notes() {\n  this.data = [];\n}\n\nNotes.prototype.add = function (note) {\n  //...\n};\n\nNotes.prototype.toString = function () {\n  //...\n};\n"
                },
                "c29sdXRpb24=": {
                  "bm90ZXMuanM=": "function Note(text) {\n  this.text = text || '';\n  this.createdAt = new Date();\n  this.completed = false;\n}\n\nNote.prototype.toString = function () {\n  let str = '[' + (this.completed ? 'X' : ' ') + ']';\n  str += ' | ' + this.createdAt.toDateString();\n  str += ' | ' + this.text;\n  return str;\n};\n\n\nfunction Notes() {\n  this.data = [];\n}\n\nNotes.prototype.add = function (note) {\n  if (!(note instanceof Note)) {\n    throw new Error('Wrong type!');\n  }\n\n  this.data.unshift(note);\n};\n\nNotes.prototype.toString = function () {\n  let str = '';\n  for (let i = 0; i < this.data.length; i++) {\n    if (i > 0) {\n      str += '\\n';\n    }\n    str += this.data[i].toString();\n  }\n  return str;\n};\n\n\nexports.Note = Note;\nexports.Notes = Notes;\n"
                },
                "dGVzdA==": {
                  "bm90ZXMuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/notes');\nconst Note = Submission.Note;\nconst Notes = Submission.Notes;\n\n\ndescribe('Note', () => {\n\n  it('debería exportar función `Note`', () => {\n    Assert.equal(typeof Note, 'function');\n  });\n\n  it('debería crear un nuevo objeto cuando invocamos new Note()', () => {\n    const note = new Note('renovar dni');\n    Assert.equal(note.text, 'renovar dni');\n    Assert.ok(note.createdAt instanceof Date);\n    Assert.equal(note.completed, false);\n  });\n\n  it('debería retornar undefined cuando invocamos Note() sin \"new\"', () => {\n    Assert.equal(Note('renovar dni'), undefined);\n  });\n\n});\n\n\ndescribe('Note#toString', () => {\n\n  it('debería convertir objeto a string', () => {\n    const note = new Note('foo');\n    const date = (new Date()).toDateString();\n    Assert.equal(note.toString(), '[ ] | ' + date + ' | foo');\n    note.completed = true;\n    Assert.equal(note.toString(), '[X] | ' + date + ' | foo');\n  });\n\n});\n\n\ndescribe('Notes (oop)', () => {\n\n  it('debería exportar función `Notes`', () => {\n    Assert.equal(typeof Notes, 'function');\n  });\n\n});\n\n\ndescribe('Notes#add', () => {\n\n  it('debería botar error cuando argumento no es instancia de Note', () => {\n    [\n      undefined, null, true, false, 0, 1, 3.14, '', 'foo', [], [1, 2], {},\n      {foo: 'bar'}, new Date(), function () {}\n    ].forEach((val) => {\n\n      const notes = new Notes();\n      Assert.throws(_ => notes.add(val), Error);\n    });\n  });\n\n\n  it('debería permitir añadir instancias de Note', () => {\n    const notes = new Notes();\n    Assert.doesNotThrow(_ => notes.add(new Note('one')));\n  });\n\n});\n\n\ndescribe('Notes#toString', () => {\n\n  it('debería retornar un string vacío cuando no hay notas', () => {\n    const notes = new Notes();\n    Assert.equal(notes.toString(), '');\n  });\n\n\n  it('debería ordenar lista por fecha de creación descendente', () => {\n    const notes = new Notes();\n    const note1 = new Note('one');\n    const date = (new Date()).toDateString();\n\n    notes.add(note1);\n    notes.add(new Note('two'));\n\n    Assert.equal(notes.toString(), [\n      '[ ] | ' + date + ' | two',\n      '[ ] | ' + date + ' | one'\n    ].join('\\n'));\n\n    note1.completed = true;\n\n    Assert.equal(notes.toString(), [\n      '[ ] | ' + date + ' | two',\n      '[X] | ' + date + ' | one'\n    ].join('\\n'));\n  });\n\n});\n"
                }
              }
            }
          },
          "order": 9,
          "durationString": "10min"
        },
        "10-fp": {
          "title": "FP",
          "type": "read",
          "format": "self-paced",
          "duration": 10,
          "body": "<p>Finalmente llegamos al paradigma funcional (<em>Functional Programming</em>), y digo\nfinalmente porque es probable que sientas curiosidad por conocer un poco más\nsobre este paradigma tan incomprendido, pero tan de moda en el mundo de\nJavaScript.</p>\n<p>A diferencia del paradigma procedural y el orientado a objetos, la programación\nfuncional pertenece a la rama de los paradigmas <em>declarativos</em>. Esto quiere\ndecir que el \"estilo\" en el que programamos va a estar mucho más enfocado en qué\nqueremos hacer y no tanto en los detalles de cómo la computadora lo ejecuta.</p>\n<p>Cuando hablamos del estilo imperativo dijimos que nos enfocábamos en asignar\nvalores a variables, mutar esas variables, e iterar usando bucles. La\nprogramación funcional se caracteriza por exactamente lo opuesto. <strong>En FP el\nprincipal mecanismo de cómputo es la aplicación de argumentos a funciones</strong>.\nComo consecuencia, evitamos la asignación de varialbles, mutación, delegamos el\ncontrol de flujo, ... De hecho, podemos resumir los principios de la\nprogramación funcional en los siguientes:</p>\n<ul>\n<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>\n<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para\nlos mismos argumentos)</li>\n<li><strong>Composición</strong> de funciones</li>\n<li><strong>Inmutabilidad</strong> (no \"mutar\" valores asignados)</li>\n<li><strong>Evitar el \"estado\" compartido</strong> (no usar referencias fuera del scope de la\nfunción)</li>\n<li>Uso de <strong>recursión</strong> como alternativa a la iteración.</li>\n</ul>\n<p>Veamos estos conceptos en acción:</p>\n<pre><code class=\"language-js\">// pasando una función anónima como un argumento\nsetTimeout(function () {\n  //...\n}, 100);\n\n\n// recibiendo una función como un argumento\nfunction map(arr, fn) {\n  const results = [];\n  for (let i = 0; i &lt; arr.length; i++) {\n    results.push(fn(arr[i]));\n  }\n  return results;\n}\n\n// Ahora reemplazando iteración con recursividad\nfunction recursiveMap(arr, fn) {\n  if (!arr.length) {\n    return [];\n  }\n  return [fn(arr[0])].concat(recursiveMap(arr.slice(1), fn));\n}\n</code></pre>\n<p>La última función (<code>recursiveMap</code>) es un buen ejemplo de FP porque muestra como\npodemos recibir una función como argumento, reemplzar iteración por recursión,\nevitar asignación y mutación. Además no accede a ninguna referencia fuera de su\nscope (sólo usa variables locales) y no tiene ningún efecto secundario: se\nlimita a producir un valor de retorno a partir de su input (argumentos) sin\nafectar nada fuera de su <em>scope</em>.</p>\n<p>Para comparar con el ejemplo que hicimos de OOP, ahora vamos a crear una función\nque cree objetos, algo parecido a un constructor, pero muy distinto a la vez.\nLos constructores son un tipo de función especial que se invoca con <code>new</code>, usa\n<code>this</code> internamente y define un prototipo. La función que vamos a implementar\nahora se va a limitar a crear un objeto y retornarlo, nada de <code>new</code>, <code>this</code> o\n<code>prototype</code>.</p>\n<pre><code class=\"language-js\">const createRobot = function (name) {\n  return {\n    name: name,\n    active: false\n  };\n};\n</code></pre>\n<p>ES2015 introduce \"arrow functions\" (funciones flecha), que es una implementación\nde funciones muy parecida al keyword <code>function</code>, pero que no implica <code>new</code>,\n<code>this</code> ni <code>prototype</code>.</p>\n<pre><code class=\"language-js\">const createRobot = (name) =&gt; {\n  return {\n    name: name,\n    active: false\n  };\n};\n</code></pre>\n<hr>\n<p>PRO TIP:</p>\n<p>Con un poquito más de azúcar sintáctica cortesía de ES2015:</p>\n<pre><code class=\"language-js\">const createRobot = name =&gt; ({\n  name,\n  active: false\n});\n</code></pre>\n<p>Cuando el cuerpo de la función es sólo una expresión (un objeto literal en\nnuestro caso), las \"arrow functions\" nos permiten hacer <em>retorno implícito</em>, lo\nque significa que podemos obviar los <code>{}</code> que determinan el \"bloque\" de la\nfunción y el keyword <code>return</code>. El resultado de evaluar la expresión será el\nvalor de retorno. En este ejemplo hemos envuelto la expresión (el objeto\nliteral) en paréntesis <code>()</code> para evitar que los <code>{}</code> se confundan con el cuerpo\nde la función. En este caso los curly braces son parte del objeto!</p>\n<hr>\n<p>En FP, en vez de pensar en \"tipos\", normalmente nos centramos en\ntransformaciones. Es decir, una función recibe un input (argumentos) y de alguna\nforma los \"transforma\" en otra cosa. Por ejemplo, en la función anterior,\npodemos decir que la función <code>createRobot</code> transforma un <code>string</code> (su input) en\nun objeto (su valor de retorno). De esta forma cada función está completamente\naislada del mundo exterior y se concentra en hacer sólo una cosa.</p>\n<p>Un buen ejemplo para visualzar el concepto de transformación es el método\n<code>Array#map</code> en JavaScript (muy parecido al map que acabamos de implementar).\n<code>Array.prototype.map</code> recibe un argumento, una función que será invocada para\ncada elemento del array, y retorna un nuevo arreglo con los resultados de cada\ninvocación a la función que recibe <code>Array#map</code> como argumento.</p>\n<pre><code class=\"language-js\">const array = ['1', '02', '33', '3.14', '028'];\n\nconst double = num =&gt; num + num;\n\nconsole.log(array.map(double));\n// [ '11', '0202', '3333', '3.143.14', '028028' ]\n\nconsole.log(array.map(parseFloat));\n// [ 1, 2, 33, 3.14, 28 ]\n\nconsole.log(array.map(parseFloat).map(double));\n// [ 2, 4, 66, 6.28, 56 ]\n\nconst arrayToDouble = array =&gt; array.map(parseFloat).map(double);\n\nconsole.log(arrayToDouble(array));\n// [ 2, 4, 66, 6.28, 56 ]\n</code></pre>\n<p>Como vemos en estos ejemplos, podemos encadenar invocaciones a <code>Array#map</code> para\nir \"transformando\" los elementos de un arreglo, ya que cada invocación retorna\nun array.</p>\n<h2 id=\"qué-ventajas-ofrece\">Qué ventajas ofrece?</h2>\n<ul>\n<li>Cómo hemos visto en el ejemplo de arriba, el código funcional tiende a ser más\nconciso y expresivo.</li>\n<li>Más predecible. Más adelante veremos que como resultado de los principios del\nparadigma (uso de funciones puras, inmutabilidad, evitar estado compartido y\nefectos secundarios, ...) nuestro código será más fácil de predecir, aislar y\nprobar.</li>\n<li>Se presta a la paralelización y la computación distribuida.</li>\n<li>Se presta a la asincrónia.</li>\n<li>JavaScript, como lenguaje, tiene una naturaleza más funcional que imperativa.</li>\n</ul>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Blog posts:</p>\n<ul>\n<li><a href=\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\" target=\"_blank\">Why Learn Functional Programming in JavaScript? (Composing Software)</a>,\nEric Elliott en Medium, Feb 20 2017</li>\n<li><a href=\"https://bethallchurch.github.io/JavaScript-and-Functional-Programming/\" target=\"_blank\">JavaScript and Functional Programming</a>,\nBeth Allchurch, 29 of June, 2016</li>\n<li><a href=\"https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming\" target=\"_blank\">An introduction to functional programming</a>,\nMary Rose Cook</li>\n<li><a href=\"https://medium.com/laboratoria-how-to/introducci%C3%B3n-a-la-programaci%C3%B3n-funcional-en-javascript-parte-1-e0b1d0b2142e\" target=\"_blank\">Introducción a programación funcional en JavaScript — Parte 1</a>,\nLupo Montero en Medium, Feb 15 2017</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\">MDN - Arrow functions</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\">MDN - Array.prototype.map</a></li>\n</ul>\n",
          "order": 10,
          "durationString": "10min"
        },
        "11-fp-exercise": {
          "title": "Ejercicio FP",
          "type": "practice",
          "format": "self-paced",
          "duration": 10,
          "exercises": {
            "01-notes": {
              "title": "Notes (FP)",
              "env": "js",
              "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa tres funciones con las siguientes \"firmas\":</p>\n<h3 id=\"createnotetext\"><code>createNote(text)</code></h3>\n<p>Esta función debe crear un objeto literal con tres propiedades (ver retorno).</p>\n<h4 id=\"argumentos\">Argumentos</h4>\n<ul>\n<li><code>text</code>: un string con el texto de la nota</li>\n</ul>\n<h4 id=\"retorno\">Retorno</h4>\n<p>Un objeto con 3 propiedades:</p>\n<ul>\n<li><code>text</code>: el texto de la nota.</li>\n<li><code>createdAt</code>: objeto tipo <code>Date</code> creado cuando se invoca <code>createNote</code>.</li>\n<li><code>completed</code>: un booleano con valor <code>false</code> por defecto.</li>\n</ul>\n<h3 id=\"createnotesarray\"><code>createNotes(array)</code></h3>\n<p>Crea un arreglo de objetos a partir de un arreglo de strings. Cada objeto en el\nnuevo arreglo será creado usando <code>createNote</code>.</p>\n<h4 id=\"argumentos-1\">Argumentos</h4>\n<ul>\n<li><code>array</code>: Un array de strings con los textos de las notas.</li>\n</ul>\n<h4 id=\"retorno-1\">Retorno</h4>\n<p>Un arreglo de objetos donde cada objeto tiene la estructura esperada de nota.</p>\n<h3 id=\"notestostringnotes\"><code>notesToString(notes)</code></h3>\n<p>Convierte un arreglo de notas (objetos con la estructura que hemos visto) en un\nstring. Para ello debe invocar <code>noteToString</code> para cada elemento en el array.</p>\n<h4 id=\"argumentos-2\">Argumentos</h4>\n<ul>\n<li><code>notes</code>: Un arreglo de objetos (notas).</li>\n</ul>\n<h4 id=\"retorno-2\">Retorno</h4>\n<p>Un string donde tenemos una línea por cada nota.</p>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<pre><code class=\"language-js\">const notes = createNotes(['hola', 'mundo']);\n\nconsole.log(notes);\n\n// [ { text: 'hola',\n//    createdAt: 2017-06-15T17:40:56.093Z,\n//    completed: false },\n//  { text: 'mundo',\n//    createdAt: 2017-06-15T17:40:56.093Z,\n//    completed: false } ]\n\nconsole.log(notesToString(notes));\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [ ] | Mon Jun 12 2017 | hola\n\nnotes[0].completed = true;\n\nconsole.log(notesToString(notes));\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [X] | Mon Jun 12 2017 | hola\n</code></pre>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Tu módulo debe exportar cuatro funciones: <code>createNote</code>, <code>noteToString</code>,\n<code>createNotes</code> y <code>notesToString</code>.</li>\n<li>Tus funciones deben de ser \"puras\" (no side effects).</li>\n<li>Evita usar asignación dentro del cuerpo de las funciones.</li>\n<li>Usa <code>Array#map</code> para implementar <code>createNotes</code> y <code>notesToString</code>.</li>\n<li>Todas las funciones deben ser \"arrow functions\"</li>\n</ul>\n<h2 id=\"bonus-points\">Bonus points</h2>\n<ul>\n<li>Evita usar el \"keyword\" <code>return</code> cuando puedas usar retorno implícito.</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\">Arrow functions - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\">Array#map - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\" target=\"_blank\">Array#join - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\" target=\"_blank\">Date - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Notes (FP)\n\n* Environment: `js`\n\n***\n\n## Tarea\n\nImplementa tres funciones con las siguientes \"firmas\":\n\n### `createNote(text)`\n\nEsta función debe crear un objeto literal con tres propiedades (ver retorno).\n\n#### Argumentos\n\n* `text`: un string con el texto de la nota\n\n#### Retorno\n\nUn objeto con 3 propiedades:\n\n* `text`: el texto de la nota.\n* `createdAt`: objeto tipo `Date` creado cuando se invoca `createNote`.\n* `completed`: un booleano con valor `false` por defecto.\n\n### `createNotes(array)`\n\nCrea un arreglo de objetos a partir de un arreglo de strings. Cada objeto en el\nnuevo arreglo será creado usando `createNote`.\n\n#### Argumentos\n\n* `array`: Un array de strings con los textos de las notas.\n\n#### Retorno\n\nUn arreglo de objetos donde cada objeto tiene la estructura esperada de nota.\n\n### `notesToString(notes)`\n\nConvierte un arreglo de notas (objetos con la estructura que hemos visto) en un\nstring. Para ello debe invocar `noteToString` para cada elemento en el array.\n\n#### Argumentos\n\n* `notes`: Un arreglo de objetos (notas).\n\n#### Retorno\n\nUn string donde tenemos una línea por cada nota.\n\n## Ejemplo\n\n```js\nconst notes = createNotes(['hola', 'mundo']);\n\nconsole.log(notes);\n\n// [ { text: 'hola',\n//    createdAt: 2017-06-15T17:40:56.093Z,\n//    completed: false },\n//  { text: 'mundo',\n//    createdAt: 2017-06-15T17:40:56.093Z,\n//    completed: false } ]\n\nconsole.log(notesToString(notes));\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [ ] | Mon Jun 12 2017 | hola\n\nnotes[0].completed = true;\n\nconsole.log(notesToString(notes));\n\n// [ ] | Mon Jun 12 2017 | mundo\n// [X] | Mon Jun 12 2017 | hola\n```\n\n## Requisitos\n\n* Tu módulo debe exportar cuatro funciones: `createNote`, `noteToString`,\n  `createNotes` y `notesToString`.\n* Tus funciones deben de ser \"puras\" (no side effects).\n* Evita usar asignación dentro del cuerpo de las funciones.\n* Usa `Array#map` para implementar `createNotes` y `notesToString`.\n* Todas las funciones deben ser \"arrow functions\"\n\n## Bonus points\n\n* Evita usar el \"keyword\" `return` cuando puedas usar retorno implícito.\n\n## Recursos\n\n* [Arrow functions - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n* [Array#map - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n* [Array#join - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join)\n* [Date - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)\n",
                "Ym9pbGVycGxhdGU=": {
                  "bm90ZXMuanM=": "const createNote = text => {}; // debes implementar esta función ;-)\n\nconst noteToString = note => [\n  '[' + (note.completed ? 'X' : ' ') + ']',\n  ' | ' + note.createdAt.toDateString(),\n  ' | ' + note.text\n].join('');\n\nconst createNotes = array => {}; // debes implementar esta función ;-)\n\nconst notesToString = notes => {}; // debes implementar esta función ;-)\n"
                },
                "c29sdXRpb24=": {
                  "bm90ZXMuanM=": "const createNote = text => ({\n  text,\n  createdAt: new Date(),\n  completed: false\n});\n\nconst noteToString = note => [\n  '[' + (note.completed ? 'X' : ' ') + ']',\n  ' | ' + note.createdAt.toDateString(),\n  ' | ' + note.text\n].join('');\n\nconst createNotes = array => array.map(createNote);\n\nconst notesToString = notes => notes.map(noteToString).join('\\n');\n\nexports.createNote = createNote;\nexports.noteToString = noteToString;\nexports.createNotes = createNotes;\nexports.notesToString = notesToString;\n"
                },
                "dGVzdA==": {
                  "bm90ZXMuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/notes');\nconst { createNote, noteToString, createNotes, notesToString } = Submission;\n\n\ndescribe('createNote()', () => {\n\n  it('debería exportar función `createNote`', () => {\n    Assert.equal(typeof createNote, 'function');\n  });\n\n  it('debería crear un objeto con los campos esperados', () => {\n    const note = createNote('renovar dni');\n    Assert.equal(note.text, 'renovar dni');\n    Assert.ok(note.createdAt instanceof Date);\n    Assert.equal(note.completed, false);\n    Assert.equal(note.__proto__, Object.prototype);\n  });\n\n});\n\ndescribe('noteToString()', () => {\n\n  it('debería exportar función `noteToString`', () => {\n    Assert.equal(typeof noteToString, 'function');\n  });\n\n  it('debería convertir objeto a string', () => {\n    const note = createNote('foo');\n    const date = (new Date()).toDateString();\n    Assert.equal(noteToString(note), '[ ] | ' + date + ' | foo');\n    note.completed = true;\n    Assert.equal(noteToString(note), '[X] | ' + date + ' | foo');\n  });\n\n});\n\ndescribe('createNotes()', () => {\n\n  it('debería exportar función `createNotes`', () => {\n    Assert.equal(typeof createNotes, 'function');\n  });\n\n});\n\ndescribe('notesToString()', () => {\n\n  it('debería exportar función `notesToString`', () => {\n    Assert.equal(typeof notesToString, 'function');\n  });\n\n  it('debería retornar un string vacío cuando no hay notas', () => {\n    const notes = createNotes([]);\n    Assert.equal(notesToString(notes), '');\n  });\n\n\n  it('debería ordenar lista por fecha de creación descendente', () => {\n    const notes = createNotes(['one']);\n    const date = (new Date()).toDateString();\n\n    notes.unshift(createNote('two'));\n\n    Assert.equal(notesToString(notes), [\n      '[ ] | ' + date + ' | two',\n      '[ ] | ' + date + ' | one'\n    ].join('\\n'));\n\n    notes[1].completed = true;\n\n    Assert.equal(notesToString(notes), [\n      '[ ] | ' + date + ' | two',\n      '[X] | ' + date + ' | one'\n    ].join('\\n'));\n  });\n\n});\n"
                }
              }
            }
          },
          "order": 11,
          "durationString": "10min"
        },
        "13-closing": {
          "title": "Cierre",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<h2 id=\"resumen\">Resumen</h2>\n<p>Los <strong>Paradigmas de Programación</strong> (<em>Programming Paradigms</em>) son formas\ndiferentes de pensar en cómo se organiza un programa basado en una serie de\nprincipios, los cuales resultan en estilos muy distintos y lenguajes muy\ndiversos.</p>\n<p>Algunos paradigmas son más <strong>imperativos</strong> y otros más <strong>declarativos</strong>. Por\nejemplo, la programación orientada a procedimientos, o la programación orientada\nobjetos, van a tener un caracter imperativo, mientras que la programación\nfuncional tiene un caracter mucho más declarativo.</p>\n<p>La <strong>programación por procedimientos</strong> (<em>procedural programming</em>) pertenece a la\nrama del estilo <em>imperativo</em>. Cuando programamos orientados a procedimientos nos\nconcentramos en agrupar código en procedimientos o funciones.</p>\n<p>En la <strong>programación orientada a objetos</strong> , vez de pensar en acciones nos\nenfocamos en definir los \"tipos\" de datos primero, y después decidimos que\ninteracciones van a tener. En OOP diseñamos objetos, que van a tener una data\n(un estado) y una serie de operaciones que pueden realizar.</p>\n<p>En la <strong>programación orientada a objetos</strong> el principal mecanismo de reuso de\ncódigo es la <strong>herencia</strong>, donde un objeto \"hereda\" una serie de propiedades y\nmétodos de otro objeto o clase (en <em>herencia prototipal</em> heredamos directamente\nde un objeto en vez de una clase).</p>\n<p>La <strong>programación funcional</strong> pertenece a la rama de los paradigmas\n<em>declarativos</em>. Esto quiere decir que el \"estilo\" en el que programamos va a\nestar mucho más enfocado en <em>qué queremos hacer</em> y no tanto en los detalles de\n<em>cómo la computadora lo ejecuta</em>.</p>\n<p>En FP el principal mecanismo de cómputo es la aplicación de argumentos a\nfunciones. Como consecuencia, evitamos la asignación de varialbles, mutación y\ndelegamos el control de flujo.</p>\n<p>Principios de la programación funcional:</p>\n<ul>\n<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>\n<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para\nlos mismos argumentos)</li>\n<li><strong>Composición</strong> de funciones</li>\n<li><strong>Inmutabilidad</strong> (no \"mutar\" valores asignados)</li>\n<li><strong>Evitar el \"estado\" compartido</strong> (no usar referencias fuera del scope de la\nfunción)</li>\n<li>Uso de <strong>recursión</strong> como alternativa a la iteración.</li>\n</ul>\n<h2 id=\"respondamos-juntxs-las-preguntas-de-la-apertura\">Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Qué son los <strong>paradigmas de programación</strong>?</li>\n<li>Qué es el estilo <strong>imperativo</strong></li>\n<li>Qué es el estilo <strong>declarativo</strong></li>\n<li>Qué paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el\n<strong>declarativo</strong></li>\n<li>Qué es la <strong>programación por procedimientos</strong>?</li>\n<li>Qué es la <strong>programación orientada a objetos</strong>?</li>\n<li>Qué es la <strong>programación funcional</strong>?</li>\n<li>Cómo se aplican los diferentes paradigmas al mundo de JavaScript?</li>\n<li>Cómo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>\n<li>Cómo programar en los diferentes estilos</li>\n</ul>\n",
          "order": 12,
          "durationString": "5min"
        }
      },
      "order": 0,
      "stats": {
        "duration": 107,
        "durationString": "1.8h",
        "exerciseCount": 4,
        "partCount": 13
      }
    },
    "03-proto": {
      "title": "OOP y herencia prototipal",
      "bonus": false,
      "description": "<p>Después de haber completado la introducción a paradigmas, te introdicirás en los\ndetalles de cómo usar contructores y prototipos para crear jerarquías de\nherencia.</p>\n",
      "parts": {
        "00-opening": {
          "title": "Apertura",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<h2 id=\"¿por-qué-aprender-esto\">¿Por qué aprender esto?</h2>\n<p>La <strong>programación orientada a objetos</strong> (OOP) es un paradigma muy común y\npotente. Como desarolladora de JavaScript es fundamental entender el paradigma,\nlas implicaciones a nivel de diseño y su implementación.</p>\n<p>Entender bien la <strong>herencia prototipal</strong> en JavaScript es de especial\nimportancia ya que el modelo de herencia es muy distinto a la mayoría de\nlenguajes orientados a objetos, donde casi siempre creamos objetos a partir de\nclases, mientras que en JavaScript heredamos directamente de otros objetos a\ntravés de cadenas de prototipos.</p>\n<p>La herencia es el principal mecanismo de reuso de código en OOP. En esta unidad\nvamos a ver cómo implementar herencia prototipal en JavaScript así como las\npeculiaridades del paradigma al aplicarlo en el contexto del lenguaje.</p>\n<h2 id=\"guía-de-preguntas-y-conceptos-clave\">Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Qué valor toma <code>this</code> cuando no puede ser inferido por el contexto?</li>\n<li>Qué hace el método <code>bind</code> que tienen todas las funciones?</li>\n<li>Cómo infiere JavaScript el valor de <code>this</code> dentro de una función?</li>\n<li>Qué es un <strong>constructor</strong>?</li>\n<li>Cómo usar <code>new</code> para crear instancias de un constructor?</li>\n<li>Cómo usar <code>instanceof</code> para determinar si un objeto fue creado con un\nconstructor específico?</li>\n<li>Cómo usar <code>Object.prototype.isPrototypeOf</code> para determinar si un objeto está\nla cadena de prototipos de otro objeto?</li>\n<li>Cómo añadir propiedades al prototipo de un constructor usando <code>Function.prototype</code>?</li>\n<li>Cómo usar <code>Object.create</code> para crear objetos con un prototipo específico?</li>\n<li>Cómo implementar <strong>herencia prototipal</strong>?</li>\n</ul>\n",
          "order": 0,
          "durationString": "5min"
        },
        "01-this-and-bind": {
          "title": "`this` y `bind`",
          "type": "read",
          "format": "self-paced",
          "duration": 10,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/wuv699tbbx?wvideo=wuv699tbbx",
              "id": "wuv699tbbx"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/wuv699tbbx?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>Entender el concepto de <code>this</code> es fundamental para entender el modelo de\nobjetos de JavaScript.</p>\n<p><code>this</code> es una pseudo-variable que existe dentro de las funciones. <code>this</code>\n(\"esto\") no significa nada por sí mismo, sino que depende del \"contexto\". El\nvalor de <code>this</code> debe ser \"inferido\" del contexto donde aparece, y por eso puede\nser motivo de confusión.</p>\n<pre><code class=\"language-js\">function talk() {\n  console.log(this.sound); // qué valor tiene `this`?\n}\n</code></pre>\n<p>Si invocamos la función <code>talk</code> veremos que imprime <code>undefined</code>. Pero qué es\n<code>this</code>? Inspeccionemos un poco...</p>\n<pre><code class=\"language-js\">function talk() {\n  console.log(this); // el objeto global!!\n}\n\ntalk();\n</code></pre>\n<p>Cuando ejecutámos nustro código ahora veremos algo así:</p>\n<pre><code class=\"language-text\">{ console: [Getter],\n  DTRACE_NET_SERVER_CONNECTION: [Function],\n  DTRACE_NET_STREAM_END: [Function],\n  DTRACE_HTTP_SERVER_REQUEST: [Function],\n  DTRACE_HTTP_SERVER_RESPONSE: [Function],\n  DTRACE_HTTP_CLIENT_REQUEST: [Function],\n  DTRACE_HTTP_CLIENT_RESPONSE: [Function],\n  global: [Circular],\n  process:\n   process {\n     title: 'node',\n     version: 'v8.1.2',\n     moduleLoadList:\n      [ 'Binding contextify',\n      ...\n</code></pre>\n<p>Qué es todo esto? De dónde salió? Cuando no se puede inferir el valor de <code>this</code>,\néste toma el valor del objeto global; <code>process</code> en Node.js o <code>window</code> en el\nnavegador.</p>\n<p>En la lección anterior vimos cómo <code>this</code> tomaba un valor especial en caso de los\nconstructores. En ese contexto <code>this</code> hace referencia al nuevo objeto que crea\nel constructor.</p>\n<p>Pero hay otra manera más explícita de asignarle un valor a <code>this</code>:\n<code>Function#bind</code>. Todas las funciones en JavaScript son objetos que heredan de\n<code>Function.prototype</code>, y así heredan el método <code>bind()</code>, que nos permite crear\nuna copia de la función, pero con <code>this</code>, el \"contexto\", asignado\nexplícitamente a un valor.</p>\n<p>\"Bind\" literalmente significa \"ligar\", \"unir a\" o \"vincular con\". Veamos un\nejemplo:</p>\n<pre><code class=\"language-js\">const cat = { sound: 'meeow!' };\nconst boundToCat = talk.bind(cat);\nboundToCat(); // meeow!\n</code></pre>\n<p>En este ejemplo <code>boundToCat</code> es una copia de <code>talk</code>, pero con su pseudo-variable\n<code>this</code> asignada a <code>cat</code>. Por lo tanto, ahora siempre que invocamos <code>boundToCat</code>\nel contexto está claro y no cambia dependiendo del contexto de invocación.</p>\n<p>Pero qué pasaría si asignamos nuestra función <code>talk</code> a una propiedad de un\nobjeto?</p>\n<pre><code class=\"language-js\">const cat = {\n  talk: talk,\n  sound: 'meeow!'\n};\n\ncat.talk(); // meeow!\ntalk(); // undefined\n</code></pre>\n<p><code>talk</code> y <code>cat.talk</code> hacen referencia a exactamente la misma función, pero se\ncomportan de manera distinta por el contexto. Al asignar <code>talk</code> a una propiedad\nde <code>cat</code>, ahora cuando invocamos <code>cat.talk()</code> JavaScript automáticamente infiere\nque el contexto es <code>cat</code>. Nótese que la función <code>talk</code> no ha cambiado, sólo ha\ncabiado el hecho de que ahora la estamos invocando como un método de un objeto.</p>\n<p>Qué pasaría si ahora asignamos ese método a una variable?</p>\n<pre><code class=\"language-js\">const balbucea = cat.talk\nbalbucea(); // undefined\n</code></pre>\n<p>Tanto <code>cat.talk</code> como <code>balbucea</code> hacen referencia a la misma función <code>talk</code>,\npero podemos ver claramente que se comportan de maneras distintas dependiendo\ndel contexto.</p>\n<p>Veamos como <code>bind</code> nos puede ayudar a \"aclarar\" el contexto de una función y así\npoder asegurar el valor de <code>this</code>:</p>\n<pre><code class=\"language-js\">const cat = {\n  sound: 'meeow!'\n};\n\ncat.talk = talk.bind(cat);\n\ncat.talk(); // meeow!\ntalk(); // undefined\n\nconst catTalk = cat.talk;\ncatTalk(); // meeow!\n</code></pre>\n<p>Para terminar esta sección, veamos un último ejemplo confuso y enrevesado:</p>\n<pre><code class=\"language-js\">function talk() {\n  console.log(this.sound); // qué valor tiene `this`?\n}\n\nconst cat = {\n  talk: talk,\n  sound: 'meeow!'\n};\n\nconst dog = {\n  talk: cat.talk,\n  sound: 'woof!'\n};\n\ndog.talk(); // woof!\n</code></pre>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Capítulos de libros:</p>\n<ul>\n<li><a href=\"http://eloquentjavascript.net/06_object.html\" target=\"_blank\">Eloquent JavaScript - Chapter 6: The Secret Life of Objects</a></li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\">MDN - instanceof</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\">MDN - this</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\">MDN - Function.bind</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\">MDN - Function.call</a></li>\n</ul>\n",
          "order": 1,
          "durationString": "10min"
        },
        "02-object-create": {
          "title": "Object.create()",
          "type": "read",
          "format": "self-paced",
          "duration": 10,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/y3ka2dold6?wvideo=y3ka2dold6",
              "id": "y3ka2dold6"
            },
            {
              "type": "video",
              "provider": "youtube",
              "href": "https://www.youtube.com/watch?v=YkoelSTUy7A",
              "id": "YkoelSTUy7A"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/y3ka2dold6?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>En JavaScript todo objeto tiene un \"prototipo\", aunque no lo especifiquemos.\nCuando creamos un objeto literal, el prototipo del objeto por defecto es\n<code>Object.prototype</code>.</p>\n<pre><code class=\"language-js\">console.log(Object.prototype.isPrototypeOf({})); // true\nconsole.log({} instanceof Object); // true\n</code></pre>\n<p>En la lección anterior vimos como podemos usar <em>constructores</em> para crear\nobjetos con un prototipo determinado. Cuando usamos un constructor los objetos\nnuevos tendrán como prototipo la propiedad <code>prototype</code> del constructor.</p>\n<pre><code class=\"language-js\">function Robot(name) {\n  this.name = name;\n}\n\nRobot.prototype.say = function () {\n  console.log('Hi! I\\'m ' + this.name + '!');\n};\n\nconst ada = new Robot('ada');\nada.say(); // Hi! I'm ada!\n\nconsole.log(ada instanceof Robot); // true\nconsole.log(Robot.prototype.isPrototypeOf(ada)); // true\n</code></pre>\n<p>Los constructores son comunes porque se parecen a las \"clases\" que hay en otros\nlenguajes, pero no son la única manera de crear objetos con un prototipo\ndeterminado. Hay una manera más simple y más natural para el modelo prototipal:\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\"><code>Object.create()</code></a>.</p>\n<pre><code class=\"language-js\">// otra manera de asignar el prototipo: `Object.create()`\nconst robot = {\n  say: function () {\n    console.log('Hi! I\\'m ' + this.name + '!');\n  }\n};\n\nconst johnny = Object.create(robot);\njohnny.name = 'johnny';\njohnny.say(); // Hi! I'm johnny!\n\nconst betty = Object.create(robot);\nbetty.name = 'betty';\nbetty.say(); // Hi! I'm betty!\n\nconsole.log(robot.isPrototypeOf(johnny)); // true\nconsole.log(robot.isPrototypeOf(betty)); // true\n</code></pre>\n<p>JavaScript implementa \"herencia\" a través de prototipos, lo que quiere decir que\nno heredamos de una clase, sino de un objeto. Así que podemos concentrarnos en\nlos prototipos sin necesidad de un constructor, <code>new</code> y <code>Function#prototype</code>.</p>\n<p>A diferencia de los constructores, cuando usamos directamente <code>Object.create</code> no\ntenemos dónde escribir lógica de inicialización. Para solventar esto podríamos\nrefactorizar el constructor anterior en una función que explícitamente crea un\nnuevo objeto usando <code>Object.create()</code> y le asigna la propiedad <code>name</code>.</p>\n<pre><code class=\"language-js\">function createRobot(name) {\n  const obj = Object.create(robot);\n  obj.name = name;\n  return obj;\n}\n</code></pre>\n<p>Como alternativa, una convención común cuando necesitamos lógica de constructor\nes añadir un método <code>init</code> que se encargue de inicializar el objeto:</p>\n<pre><code class=\"language-js\">const robot = {\n  init: function (name) {\n    this.name = name;\n  },\n  say: function () {\n    console.log('Hi! I\\'m ' + this.name + '!');\n  }\n};\n</code></pre>\n<hr>\n<p>PRO TIP:</p>\n<p>Si nuestro métodod <code>init</code> retorna una referencia a <code>this</code>, podemos encadenar las\ninvocaciones:</p>\n<pre><code class=\"language-js\">const robot = {\n  init: function (name) {\n    this.name = name;\n    return this;\n  },\n  say: function () {\n    console.log('Hi! I\\'m ' + this.name + '!');\n  }\n};\n\nconst johnny = Object.create(robot).init('johnny');\n</code></pre>\n<hr>\n<p>Por ahora hemos invocado <code>Object.create()</code> con un solo argumento: el prototipo\nque queremos que tenga el nuevo objeto. Pero <code>Object.create()</code> nos ofrece la\nposibilidad de pasar un segundo argumento: un objeto cuyas propiedades serán\nagregadas al objeto recién creado, con los nombres de propiedad\ncorrespondientes. Estas propiedades corresponden al segundo argumento de\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\" target=\"_blank\"><code>Object.defineProperties</code></a>.</p>\n<pre><code class=\"language-js\">function createRobot(name) {\n  return Object.create(robot, {\n    name: {\n      value: name,\n      enumerable: true\n    }\n  });\n}\n\nconst grace = createRobot('grace');\ngrace.say(); // Hi! I'm grace!\nconsole.log(grace); // { name: 'grace' }\n</code></pre>\n<hr>\n<p>BONUS FACT:</p>\n<p><code>Object.create()</code> fue originalmente implementada y popularizada por <a href=\"http://javascript.crockford.com/prototypal.html\" target=\"_blank\">Douglas\nCrockford</a>, el abuelito gruñón\ndel JavaScript, con la intención de aclarar los malos entendidos que generan los\nconstructores, que parecen clases pero no lo son, y en cambio se centra en los\nprototipos. Hoy en día <code>Object.create()</code> ya es parte del lenguaje en sí.</p>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Videos:</p>\n<ul>\n<li><div class=\"iframe-container\"><iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/YkoelSTUy7A?autoplay=0\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen=\"true\"></iframe></div>,\n<code>19:19</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\" target=\"_blank\">funfunfunction</a>,\n22 ago. 2016</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\">MDN - Object.create</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\" target=\"_blank\">MDN - Object.defineProperties</a></li>\n</ul>\n",
          "order": 2,
          "durationString": "10min"
        },
        "03-prototypal-inheritance": {
          "title": "Herencia prototipal",
          "type": "read",
          "format": "self-paced",
          "duration": 12,
          "embeds": [
            {
              "type": "video",
              "provider": "wistia",
              "href": "https://laboratoria.wistia.com/medias/6p1jbpi4qk?wvideo=6p1jbpi4qk",
              "id": "6p1jbpi4qk"
            },
            {
              "type": "video",
              "provider": "youtube",
              "href": "https://www.youtube.com/watch?v=riDVvXZ_Kb4",
              "id": "riDVvXZ_Kb4"
            },
            {
              "type": "video",
              "provider": "youtube",
              "href": "https://www.youtube.com/watch?v=YkoelSTUy7A",
              "id": "YkoelSTUy7A"
            }
          ],
          "body": "<p><div class=\"iframe-container\"><iframe width=\"100%\" height=\"100%\" src=\"//fast.wistia.net/embed/iframe/6p1jbpi4qk?videoFoam=true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" oallowfullscreen=\"true\" msallowfullscreen=\"true\" allowtransparency=\"true\"></iframe></div></p>\n<p>Hasta ahora nos hemos concetrado en el concepto de prototipo y cómo crear\nobjetos con un prototipo determinado. También hemos mencionado el concepto\nde <em>cadena de prototipos</em> y cómo JavaScript \"resuleve\" (busca) las propiedades\nde un objeto empezando por aquellas definidas directamente sobre la instacia,\ndespués el prototipo, de ahí el prototipo del prototipo y así sucesivamente.</p>\n<p>También hemos hablado de cómo el concepto de \"herencia\" y las \"jerarquías de\nherencia\" son fundamentales en la programación orientada a objetos. Ahora es la\nhora de ver cómo usamos lo que hemos aprendido de prototipos y <code>Object.create</code>\npara implementar una jerarquía de herencia, donde un objeto hereda de otro\nobjeto que a su vez hereda de otro.</p>\n<p>Para heredar de un objeto existente, podemos crear un nuevo constructor y\na su prototipo asignarle un objeto que tenga como prototipo el prototipo del\nconstructor que queremos \"extender\". Para crear ese objeto que podamos usar como\nprototipo del nuevo constructor vamos a usar <code>Object.create()</code>, que nos permite\ncrear un nuevo objeto especificando su prototipo.</p>\n<p>Continuando con el ejemplo de la lección anterior, implementemos un nuevo tipo\nde nota que herede de <code>Note</code>.</p>\n<pre><code class=\"language-js\">//\n// Note (constructor base que vamos a extender, copiado de la lección anterior)\n//\nfunction Note(text) {\n  this.text = text || '';\n  this.createdAt = new Date();\n  this.completed = false;\n}\n\nNote.prototype.toString = function () {\n  let str = '[' + (this.completed ? 'X' : ' ') + ']';\n  str += ' | ' + this.createdAt.toDateString();\n  str += ' | ' + this.text;\n  return str;\n};\n\n//\n// ImageNote (constructor que hereda de Note)\n//\nfunction ImageNote(url) {\n  this.url = url;\n}\n\n// Heredamos de `Note.prototype`\nImageNote.prototype = Object.create(Note.prototype);\n\nconsole.log(new ImageNote('http://foo.com/bar.png'));\n// Note { url: 'http://foo.com/bar.png' }\n</code></pre>\n<p>Hemos creado un constructor <code>ImageNote</code>, y antes de fijarnos en el cuerpo del\nconstructor veamos primero el mecanismo de herencia. A <code>ImageNote.prototype</code> le\nasignamos un objeto nuevo que tiene <code>Note.prototype</code> como prototipo usando\n<code>Object.create()</code>.</p>\n<p>Nuestra implementación de <code>ImageNote</code> todavía está incompleta, pero ya podemos\nver cómo hemos preparado el escenario para que herede de <code>Note.prototype</code>. En el\ncaso de <code>Note</code>, habíamos asignado propiedades a <code>Note.prototype</code>, pero no\nhabíamos asignado el objeto <code>Note.prototype</code> en sí. Ahora en <code>ImageNote</code> hacemos\nalgo muy distinto: usamos <code>Object.create()</code> para crear un nuevo objeto que tenga\ncomo prototipo <code>Note.prototype</code>, y éste nuevo objeto lo asignamos a\n<code>ImageNote.prototype</code>. Lo que estamos haciendo es construir una cadena de\nprototipos. Los objetos creados con <code>new ImageNote()</code> tendrán como prototipo un\nobjeto que a su vez tiene <code>Note.prototype</code> como prototipo. Esto puede sonar\nbastante confuso al principio. Tómate tu tiempo para entender lo que está\npasando.</p>\n<p>Hemos dicho que nuestra implementación no está completa. Si nos fijamos en el\nconstructor <code>Note</code> vemos que inicializa el nuevo objeto con tres propiedades:\n<code>text</code>, <code>createdAt</code> y <code>completed</code>. Podríamos \"duplicar\" la lógica dentro del\nconstructor <code>ImageNote</code>, pero si estamos usando herencia, es precisamente para\npoder reusar código y evitar repetición!</p>\n<p>Antes hemos visto como podemos usar <code>bind</code> para definir de forma explícita el\nvalor de <code>this</code>. Ahora veamos cómo otro método de las funciones nos permite\n\"invocar\" una función asignando <code>this</code> a lo que queramos.</p>\n<pre><code class=\"language-js\">function ImageNote(url) {\n  this.url = url;\n  Note.call(this, 'an image note');\n}\n\n// Heredamos de `Note.prototype`\nImageNote.prototype = Object.create(Note.prototype);\n\nconsole.log(new ImageNote('http://foo.com/bar.png'));\n</code></pre>\n<p>En la consola deberías ver algo así:</p>\n<pre><code class=\"language-text\">Note {\n  url: 'http://foo.com/bar.png',\n  text: 'an image note',\n  createdAt: 2017-06-22T15:05:21.013Z,\n  completed: false }\n</code></pre>\n<p>Dentro de nuestro constructor <code>ImageNote</code> hemos añadido una invocación al\nconstructor <code>Note</code>. De esa forma podemos reusar la lógica del constructor\n<code>Note</code>, y para asegurarnos de que <code>Note</code> opera sobre el <code>this</code> de la nueva nota\ncreada con <code>ImageNote</code> usamos <code>call()</code>. <code>Function.prototype.call</code> es muy\nparecida a <code>Function.prototype.bind</code>, pero en vez de retornar una función con\nel contexto fijado, lo que hace es invocar la función con el contexto deseado.</p>\n<p>También podemos ver, al hacer <code>console.log</code>, que el objeto aparece como de\n\"tipo\" <code>Note</code> y no <code>ImageNote</code>. Eso es porque el prototipo de una función guarda\nuna referencia a su constructor en una propiedad llamada <code>constructor</code>. Al\nreemplazar el prototipo de <code>ImageNote</code> con el objeto creado con <code>Object.create</code>,\nla propiedad <code>constructor</code> ahora resuleve al constructor de <code>Note</code>. Podemos\ncorregir esto explícitamente asignando <code>ImageNote.prototype.constructor</code>:</p>\n<pre><code class=\"language-js\">function ImageNote(url) {\n  this.url = url;\n  Note.call(this, 'an image note');\n}\n\n// Heredamos de `Note.prototype`\nImageNote.prototype = Object.create(Note.prototype);\n// Asignamos constructor al nuevo prototipo\nImageNote.prototype.constructor = ImageNote;\n\nconsole.log(new ImageNote('http://foo.com/bar.png'));\n</code></pre>\n<p>En la consola deberías ver algo así:</p>\n<pre><code class=\"language-text\">ImageNote {\n  url: 'http://foo.com/bar.png',\n  text: 'an image note',\n  createdAt: 2017-06-22T15:12:40.163Z,\n  completed: false }\n</code></pre>\n<p>Yay! Ya tenemos un constructor que hereda de <code>Note</code>! Ahora vamos a modificar la\nfuncionalidad del método <code>Note#toString</code> para que se adapte a <code>ImageNote</code> y nos\nmuestre la url de la imagen:</p>\n<pre><code class=\"language-js\">function ImageNote(url) {\n  this.url = url;\n  Note.call(this, 'an image note');\n}\n\n// Heredamos de `Note.prototype`\nImageNote.prototype = Object.create(Note.prototype);\nImageNote.prototype.constructor = ImageNote;\n\n// Sobreescribimos el método `toString` para instancias de `ImageNote`\nImageNote.prototype.toString = function () {\n  return Note.prototype.toString.call(this) + ' | ' + this.url;\n};\n</code></pre>\n<p>Hemos declarado un nuevo método <code>toString</code> sobre el prototipo de <code>ImageNote</code>, y\nen la implementación de ese método estamos reusando <code>Note.prototype.toString</code>,\nhaciendo uso de <code>Function#call</code> otra vez ;-)</p>\n<p>Ahora instanciemos nuestro objeto y veamos como se comporta:</p>\n<pre><code class=\"language-js\">const imageNote = new ImageNote('http://foo.bar/baz.jpg');\n\nconsole.log(imageNote);\nconsole.log(imageNote.toString());\n// [ ] | Thu Jun 22 2017 | an image note | http://foo.bar/baz.jpg\n\nconsole.log(note instanceof ImageNote); // false\nconsole.log(imageNote instanceof Note); // true\nconsole.log(imageNote instanceof ImageNote); // true\n\nconsole.log(Note.prototype.isPrototypeOf(imageNote)); // true\nconsole.log(ImageNote.prototype.isPrototypeOf(note)); // false\nconsole.log(ImageNote.prototype.isPrototypeOf(imageNote)); // true\n</code></pre>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Capítulos de libros:</p>\n<ul>\n<li><a href=\"http://eloquentjavascript.net/06_object.html\" target=\"_blank\">Eloquent JavaScript - Chapter 6: The Secret Life of Objects</a></li>\n</ul>\n<p>Blog posts:</p>\n<ul>\n<li><a href=\"https://css-tricks.com/understanding-javascript-constructors/\" target=\"_blank\">Understanding JavaScript Constructors</a>,\nFaraz Kelhini, CSS Tricks, Sep 24 2015</li>\n</ul>\n<p>Videos:</p>\n<ul>\n<li><a href=\"https://frontendmasters.com/courses/javascript-jquery-dom/prototypal-inheritance/\" target=\"_blank\">Prototypal Inheritance</a>,\n<code>8:52</code>, Justin Meyer, <a href=\"https://frontendmasters.com/\" target=\"_blank\">Frontend Masters</a></li>\n<li>Playlist: <a href=\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub\" target=\"_blank\">Object Creation in JavaScript</a>,\n<code>aprox. 3h</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\" target=\"_blank\">funfunfunction</a>,\n2016</li>\n<li><div class=\"iframe-container\"><iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/riDVvXZ_Kb4?autoplay=0\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen=\"true\"></iframe></div>,\n<code>11:55</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\" target=\"_blank\">funfunfunction</a>,\n25 Jan 2016</li>\n<li><div class=\"iframe-container\"><iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/YkoelSTUy7A?autoplay=0\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen=\"true\"></iframe></div>,\n<code>19:19</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\" target=\"_blank\">funfunfunction</a>,\n22 ago. 2016</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\">MDN - instanceof</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\">MDN - this</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\">MDN - Function.bind</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\">MDN - Function.call</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\">MDN - Object.create</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\" target=\"_blank\">MDN - Object.defineProperties</a></li>\n</ul>\n",
          "order": 3,
          "durationString": "12min"
        },
        "04-ejercicios": {
          "title": "Ejercicios",
          "type": "practice",
          "format": "self-paced",
          "duration": 90,
          "exercises": {
            "01-simple-objects": {
              "title": "Objetos simples",
              "env": "js",
              "body": "<p>Hay muchas formas de crear objetos en JavaScript, pero la más sencilla es usando\nobjetos \"literales\":</p>\n<pre><code class=\"language-js\">const alien = {\n  legs: 3\n};\n</code></pre>\n<h2 id=\"desafío\">Desafío</h2>\n<p>Escribe un programa que haga lo siguiente:</p>\n<ul>\n<li>Crea un objeto que se llame <code>robot</code> usando un objeto literal</li>\n<li><code>robot</code> debe tener una propiedad llamada <code>smart</code> con un valor <code>true</code></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Objetos simples\n\n* Environment: `js`\n\n***\n\nHay muchas formas de crear objetos en JavaScript, pero la más sencilla es usando\nobjetos \"literales\":\n\n```js\nconst alien = {\n  legs: 3\n};\n```\n\n## Desafío\n\nEscribe un programa que haga lo siguiente:\n\n* Crea un objeto que se llame `robot` usando un objeto literal\n* `robot` debe tener una propiedad llamada `smart` con un valor `true`\n",
                "Ym9pbGVycGxhdGU=": {
                  "c2ltcGxlT2JqZWN0cy5qcw==": "// -> Crea un objeto llamado 'robot' usando un objeto literal\n// -> robot debe tener una propiedad 'smart' con el valor true\n__\n\n// Exports de Common JS para verificación, no modificar\nmodule.exports = { robot };\n"
                },
                "c29sdXRpb24=": {
                  "c2ltcGxlT2JqZWN0cy5qcw==": "const robot = {\n  smart: true\n};\n\nmodule.exports = { robot };\n"
                },
                "dGVzdA==": {
                  "c2ltcGxlT2JqZWN0cy5zcGVjLmpz": "'use strict';\n\n\nconst globalScope = (typeof WorkerNavigator !== 'undefined' ? WorkerNavigator : global);\nconst Assert = globalScope.Assert = require('chai').assert;\nconst Submission = require('../solution/simpleObjects');\n\n\ndescribe('module', () => {\n\n  it('debería exportar un objeto con una propiedad \"robot\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('robot'));\n  });\n\n  describe('robot', () => {\n\n    it('debería ser un objeto', () => {\n      Assert.equal(typeof Submission.robot, 'object');\n    });\n\n    it('debería tener una propiedad \"smart\"', () => {\n      Assert.ok(Submission.robot.hasOwnProperty('smart'));\n    });\n\n    describe('robot.smart', () => {\n\n      it('debería ser true', () => {\n        Assert.equal(Submission.robot.smart, true);\n      });\n\n    });\n\n  });\n\n});\n"
                }
              }
            },
            "02-proto": {
              "title": "El objeto __proto__",
              "env": "js",
              "body": "<p>Para entender las cadenas de prototipos, no hay nada más simple que la propiedad\n<code>__proto__</code>. Desgraciadamente <code>__proto__</code> todavía no es parte de la interfaz\nestándar de JavaScript, y está depreciada. Así que probablemente no\ndeberías usarlo en el mundo real. No obstante, ayuda mucho a explicar los\nprototipos de una forma sencilla.</p>\n<pre><code class=\"language-js\">// creémos un objeto alien\nconst alien = {\n  kind: 'alien'\n};\n\n// y un objeto robot\nconst robot = {\n  kind: 'robot'\n};\n\n// y un objeto llamado 'zippy'\nconst zippy = {};\n\n// asignamos alien como el prototipo de zippy\nzippy.__proto__ = alien;\n\n// zippy ahora está vinculado a alien\n// 'hereda' las propiedades de alien\nconsole.log(zippy.kind); //=&gt; 'alien'\n\n// asignamos robot como el prototipo de zippy\nzippy.__proto__ = robot;\n\n// y ahora zippy está vinculado a robot\nconsole.log(zippy.kind); //=&gt; 'robot'\n</code></pre>\n<p>Como puedes ver, la propiedad <code>__proto__</code> es bastante clara y fácil de usar.\nIncluso si no deberíamos usar <code>__proto__</code> en producción, creo que estos ejemplos\nnos dan una buena base para entender la modelo de objetos de JavaScript.</p>\n<p>Puedes comprobar si un objeto es el prototipo de otro objeto así:</p>\n<pre><code class=\"language-js\">console.log(alien.isPrototypeOf(zippy));\n//=&gt; true\n</code></pre>\n<h2 id=\"desafío\">Desafío</h2>\n<p>En la pestaña de código encontrarás el 'boilerplate' con las instrucciones y los\nlugares donde añadir tu código debidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# El objeto __proto__\n\n* Environment: `js`\n\n***\n\nPara entender las cadenas de prototipos, no hay nada más simple que la propiedad\n`__proto__`. Desgraciadamente `__proto__` todavía no es parte de la interfaz\nestándar de JavaScript, y está depreciada. Así que probablemente no\ndeberías usarlo en el mundo real. No obstante, ayuda mucho a explicar los\nprototipos de una forma sencilla.\n\n```js\n// creémos un objeto alien\nconst alien = {\n  kind: 'alien'\n};\n\n// y un objeto robot\nconst robot = {\n  kind: 'robot'\n};\n\n// y un objeto llamado 'zippy'\nconst zippy = {};\n\n// asignamos alien como el prototipo de zippy\nzippy.__proto__ = alien;\n\n// zippy ahora está vinculado a alien\n// 'hereda' las propiedades de alien\nconsole.log(zippy.kind); //=> 'alien'\n\n// asignamos robot como el prototipo de zippy\nzippy.__proto__ = robot;\n\n// y ahora zippy está vinculado a robot\nconsole.log(zippy.kind); //=> 'robot'\n```\n\nComo puedes ver, la propiedad `__proto__` es bastante clara y fácil de usar.\nIncluso si no deberíamos usar `__proto__` en producción, creo que estos ejemplos\nnos dan una buena base para entender la modelo de objetos de JavaScript.\n\nPuedes comprobar si un objeto es el prototipo de otro objeto así:\n\n```js\nconsole.log(alien.isPrototypeOf(zippy));\n//=> true\n```\n\n## Desafío\n\nEn la pestaña de código encontrarás el 'boilerplate' con las instrucciones y los\nlugares donde añadir tu código debidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "cHJvdG8uanM=": "// -> Crea un objeto 'machine'\n//    con una propiedad 'motors' = 4\n__\n\n// -> Crea un objeto robot\n//    con una propiedad 'friendly' = true\n__\n\n// -> Crea un objeto 'robby'\n__\n\n// -> Haz que 'machine' sea el prototipo de 'robot'\n__\n\n// -> Haz que 'robot' sea el prototipo de 'robby'\n__\n\n// -> Qué es `robby.motors`?\nclaim(robby.motors, __);\n\n// -> Qué es `robby.friendly`?\nclaim(robby.friendly, __);\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  machine,\n  robot,\n  robby,\n};\n"
                },
                "c29sdXRpb24=": {
                  "cHJvdG8uanM=": "const machine = {\n  motors: 4\n};\n\nconst robot = {\n  friendly: true\n};\n\nconst robby = {};\n\nrobot.__proto__ = machine;\n\nrobby.__proto__ = robot;\n\nclaim(robby.motors, 4);\n\nclaim(robby.friendly, true);\n\nmodule.exports = {\n  machine,\n  robot,\n  robby,\n};\n"
                },
                "dGVzdA==": {
                  "cHJvdG8uc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\nconst claim = globalScope.claim = (actual, expected) => Assert.equal(actual, expected);\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/proto');\nconst { machine, robot, robby } = Submission;\n\n\ndescribe('proto', () => {\n\n  it('debería exportar un objeto con las propiedades \"machine\", \"robot\" y \"robby\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('machine'));\n    Assert.ok(Submission.hasOwnProperty('robot'));\n    Assert.ok(Submission.hasOwnProperty('robby'));\n  });\n\n  it('debería invocar claim 2 veces', () => {\n    Assert.equal(spy.callCount, 2);\n  });\n\n  describe('primera invocación a claim', () => {\n    it('debería comparar 4 con 4', () => {\n      Assert.deepEqual(spy.getCall(0).args, [4, 4]);\n    })\n  });\n\n  describe('segunda invocación a claim', () => {\n    it('debería comparar true con true', () => {\n      Assert.deepEqual(spy.getCall(1).args, [true, true]);\n    })\n  });\n\n  describe('machine', () => {\n\n    it('debería ser un objeto con una propiedad \"motors\"', () => {\n      Assert.equal(typeof machine, 'object');\n      Assert.ok(machine.hasOwnProperty('motors'));\n    });\n\n    describe('machine.motors', () =>\n      it('debería ser 4', () => Assert.equal(machine.motors, 4)));\n\n  });\n\n  describe('robot', () => {\n\n    it('debería ser un objeto con una propiedad \"friendly\"', () => {\n      Assert.equal(typeof robot, 'object');\n      Assert.ok(robot.hasOwnProperty('friendly'));\n    });\n\n    describe('robot.friendly', () =>\n      it('debería ser true', () => Assert.equal(robot.friendly, true)));\n\n  });\n\n  describe('robby', () => {\n\n    it('debería ser un objeto sin propiedades propias', () => {\n      Assert.equal(Object.keys(robby).length, 0);\n    });\n\n    describe('robby.__proto__', () =>\n      it('debería ser robot', () => Assert.equal(robby.__proto__, robot)));\n\n    describe('robby.__proto__.__proto__', () =>\n      it('debería ser machine', () => Assert.equal(robby.__proto__.__proto__, machine)));\n\n    describe('robby.motors', () =>\n      it('debería resolver a 4', () => Assert.equal(robby.motors, 4)));\n\n    describe('robby.friendly', () =>\n      it('debería resolver a true', () => Assert.equal(robby.friendly, true)));\n\n  });\n\n});\n"
                }
              }
            },
            "03-dynamic-lookups": {
              "title": "Búsquedas dinámicas (dynamic lookups)",
              "env": "js",
              "body": "<p>Las búsquedas en el prototipo son dinámicas.</p>\n<p>Puedes añadir propiedades al prototipo de un objeto en cualquier momento. La\ncadena de prototipos (prototype chain) encontrará la nueva propiedad:</p>\n<pre><code class=\"language-js\">const alien = {};\n\nconst zippy = {};\nzippy.__proto__ = alien;\n\n// zippy no resuelve (encuentra) una propiedad 'kind' en este punto\nconsole.log(zippy.kind); //=&gt; undefined\n\n// añadimos 'kind' a alien\nalien.kind = 'alien';\n\n// ahora zippy si resuelve 'kind'\n// porque lo encuentra en 'alien'\nconsole.log(zippy.kind); //=&gt; 'alien'\n</code></pre>\n<h2 id=\"conclusiones\">Conclusiones</h2>\n<ul>\n<li>Los objetos delegan la resolución/búsqueda (lookup) de propiedades a su\nprototipo</li>\n<li>Un prototipo puede ser compartido entre varios objetos</li>\n</ul>\n<h2 id=\"desafío\">Desafío</h2>\n<p>El 'boilerplate' contiene las instrucciones y los lugares donde añadir tu código\ndebidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Búsquedas dinámicas (dynamic lookups)\n\n* Environment: `js`\n\n***\n\nLas búsquedas en el prototipo son dinámicas.\n\nPuedes añadir propiedades al prototipo de un objeto en cualquier momento. La\ncadena de prototipos (prototype chain) encontrará la nueva propiedad:\n\n```js\nconst alien = {};\n\nconst zippy = {};\nzippy.__proto__ = alien;\n\n// zippy no resuelve (encuentra) una propiedad 'kind' en este punto\nconsole.log(zippy.kind); //=> undefined\n\n// añadimos 'kind' a alien\nalien.kind = 'alien';\n\n// ahora zippy si resuelve 'kind'\n// porque lo encuentra en 'alien'\nconsole.log(zippy.kind); //=> 'alien'\n```\n\n## Conclusiones\n\n* Los objetos delegan la resolución/búsqueda (lookup) de propiedades a su\n  prototipo\n* Un prototipo puede ser compartido entre varios objetos\n\n## Desafío\n\nEl 'boilerplate' contiene las instrucciones y los lugares donde añadir tu código\ndebidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "ZHluYW1pY0xvb2t1cHMuanM=": "// -> Declaremos tres objetos: 'machine' 'vehicle' y 'robot'\nconst machine = {};\nconst vehicle = {};\nconst robot = {};\n\n// -> Haz que `machine` sea el prototipo de `vehicle`\n// -> Haz que `machine` sea el prototipo de `robot`\n__\n\n// -> Qué es `vehicle.motors`?\nclaim(vehicle.motors, __);\n\n// -> Qué es `robot.motors`?\nclaim(robot.motors, __);\n\n// -> Define una propiedad `motors` en `machine` y asígnale el valor `4`\n__\n\n// -> Qué es `vehicle.motors` ahora?\nclaim(vehicle.motors, __);\n\n// -> Qué es `robot.motors`?\nclaim(robot.motors, __);\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  machine,\n  vehicle,\n  robot,\n};\n"
                },
                "c29sdXRpb24=": {
                  "ZHluYW1pY0xvb2t1cHMuanM=": "const machine = {};\nconst vehicle = {};\nconst robot = {};\n\nvehicle.__proto__ = machine;\nrobot.__proto__ = machine;\n\n// What is vehicle.motors\nclaim(vehicle.motors, undefined);\n// What is robot.motors?\nclaim(robot.motors, undefined);\n\nmachine.motors = 4;\n\n// -> What is `vehicle.motors` now?\nclaim(vehicle.motors, 4);\n\n// -> What is `robot.motors`?\nclaim(robot.motors, 4);\n\n// ------------------------------------------------\nmodule.exports = {\n  machine,\n  vehicle,\n  robot,\n};\n"
                },
                "dGVzdA==": {
                  "ZHluYW1pY0xvb2t1cHMuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\nconst claim = globalScope.claim = (actual, expected) => Assert.equal(actual, expected);\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/dynamicLookups');\nconst { machine, vehicle, robot } = Submission;\n\n\ndescribe('dynamicLookup', () => {\n\n  it('debería exportar un objeto con las propiedades \"machine\", \"vehicle\" y \"robot\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('machine'));\n    Assert.ok(Submission.hasOwnProperty('vehicle'));\n    Assert.ok(Submission.hasOwnProperty('robot'));\n  });\n\n  it('debería invocar claim 4 veces', () => {\n    Assert.equal(spy.callCount, 4);\n  });\n\n  [\n    [undefined, undefined],\n    [undefined, undefined],\n    [4, 4],\n    [4, 4]\n  ].forEach((args, idx) => {\n    describe(`invocación ${idx + 1} a claim`, () => {\n      it(`debería comparar ${args[0]} con ${args[1]}`, () => {\n        Assert.deepEqual(spy.getCall(idx).args, args);\n      })\n    });\n  });\n\n  describe('machine', () => {\n\n    it('debería ser un objeto con una propiedad \"motors\"', () => {\n      Assert.equal(typeof machine, 'object');\n      Assert.ok(machine.hasOwnProperty('motors'));\n    });\n\n    describe('machine.motors', () =>\n      it('debería ser 4', () => Assert.equal(machine.motors, 4)));\n\n  });\n\n  describe('vehicle', () => {\n\n    it('debería ser un objeto sin propiedades propias', () => {\n      Assert.equal(typeof vehicle, 'object');\n      Assert.equal(Object.keys(vehicle).length, 0);\n    });\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(vehicle.__proto__, machine);\n    });\n\n    describe('vehicle.motors', () =>\n      it('debería resolver a 4', () => Assert.equal(vehicle.motors, 4)));\n\n  });\n\n  describe('robot', () => {\n\n    it('debería ser un objeto sin propiedades propias', () => {\n      Assert.equal(typeof robot, 'object');\n      Assert.equal(Object.keys(robot).length, 0);\n    });\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(robot.__proto__, machine);\n    });\n\n    describe('robot.motors', () =>\n      it('debería resolver a 4', () => Assert.equal(robot.motors, 4)));\n\n  });\n\n});\n"
                }
              }
            },
            "04-property-assignments": {
              "title": "Asignación de propiedades",
              "env": "js",
              "body": "<p>Qué pasa si actualizas una propiedad que ya existía en el prototipo? Veamos:</p>\n<pre><code class=\"language-js\">const alien = {\n  kind: 'alien'\n};\n\nconst zippy = {};\nzippy.__proto__ = alien;\n\nzippy.kind = 'zippy';\n\nconsole.log(zippy.kind); //=&gt; 'zippy'\n// zippy ahora tiene una propiedad `kind`\n\nconsole.log(alien.kind); //=&gt; 'alien'\n// alien no se ha modificado\n</code></pre>\n<p>Las propiedades nuevas o actualizadas son asignadas al objeto, no a su\nprototipo. Ten en cuenta que la propiedad <code>kind</code> ahora existe tanto en <code>alien</code>\ncomo en <code>zippy</code>.</p>\n<h2 id=\"desafío\">Desafío</h2>\n<p>El 'boilerplate' tiene las instrucciones y los lugares donde añadir tu código\ndebidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Asignación de propiedades\n\n* Environment: `js`\n\n***\n\nQué pasa si actualizas una propiedad que ya existía en el prototipo? Veamos:\n\n```js\nconst alien = {\n  kind: 'alien'\n};\n\nconst zippy = {};\nzippy.__proto__ = alien;\n\nzippy.kind = 'zippy';\n\nconsole.log(zippy.kind); //=> 'zippy'\n// zippy ahora tiene una propiedad `kind`\n\nconsole.log(alien.kind); //=> 'alien'\n// alien no se ha modificado\n```\n\nLas propiedades nuevas o actualizadas son asignadas al objeto, no a su\nprototipo. Ten en cuenta que la propiedad `kind` ahora existe tanto en `alien`\ncomo en `zippy`.\n\n## Desafío\n\nEl 'boilerplate' tiene las instrucciones y los lugares donde añadir tu código\ndebidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "cHJvcGVydHlBc3NpZ25tZW50cy5qcw==": "// -> Define tres objetos: 'machine', 'robot' y 'vehicle'\n//    En la definición de `machine` añade la propiedad `motors` y asígnale null.\n__\n\n// -> Hacemos que `machine` sea el prototipo de `robot` y `vehicle`\nvehicle.__proto__ = machine;\nrobot.__proto__ = machine;\n\n// -> Qué son `machine.motors`, `robot.motors` y `vehicle.motors`?\nclaim(machine.motors, __);\nclaim(robot.motors, __);\nclaim(vehicle.motors, __);\n\n// -> Asigna `4` a `robot.motors`.\n__\n\n// -> ¿Qué son `machine.motors`, `robot.motors` y `vehicle.motors` ahora?\nclaim(machine.motors, __);\nclaim(robot.motors, __);\nclaim(vehicle.motors, __);\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  machine,\n  vehicle,\n  robot,\n};\n"
                },
                "c29sdXRpb24=": {
                  "cHJvcGVydHlBc3NpZ25tZW50cy5qcw==": "const machine = { motors: null };\nconst vehicle = {};\nconst robot = {};\n\n// -> Let's make machine the prototype of robot and vehicle\nvehicle.__proto__ = machine;\nrobot.__proto__ = machine;\n\nclaim(machine.motors, null);\nclaim(robot.motors, null);\nclaim(vehicle.motors, null);\n\nrobot.motors = 4;\n\nclaim(machine.motors, null);\nclaim(robot.motors, 4);\nclaim(vehicle.motors, null);\n\nmodule.exports = {\n  machine,\n  vehicle,\n  robot,\n};\n"
                },
                "dGVzdA==": {
                  "cHJvcGVydHlBc3NpZ25tZW50cy5zcGVjLmpz": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\nconst claim = globalScope.claim = (actual, expected) => Assert.equal(actual, expected);\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/propertyAssignments');\nconst { machine, vehicle, robot } = Submission;\n\n\ndescribe('propertyAssignments', () => {\n\n  it('debería exportar un objeto con las propiedades \"machine\", \"vehicle\" y \"robot\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('machine'));\n    Assert.ok(Submission.hasOwnProperty('vehicle'));\n    Assert.ok(Submission.hasOwnProperty('robot'));\n  });\n\n  it('debería invocar claim 6 veces', () => {\n    Assert.equal(spy.callCount, 6);\n  });\n\n  [\n    [null, null],\n    [null, null],\n    [null, null],\n    [null, null],\n    [4, 4],\n    [null, null],\n  ].forEach((args, idx) => {\n    describe(`invocación ${idx + 1} a claim`, () =>\n      it(`debería comparar ${args[0]} con ${args[1]}`, () =>\n        Assert.deepEqual(spy.getCall(idx).args, args)\n      )\n    );\n  });\n\n  describe('machine', () => {\n\n    it('debería tener una propiedad motors', () => {\n      Assert.ok(robot.hasOwnProperty('motors'));\n    });\n\n    describe('machine.motors', () =>\n      it('debería tener valor null', () => Assert.equal(machine.motors, null))\n    );\n\n  });\n\n  describe('vehicle', () => {\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(vehicle.__proto__, machine);\n    });\n\n  });\n\n  describe('robot', () => {\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(robot.__proto__, machine);\n    });\n\n    it('debería tener una propiedad motors', () => {\n      Assert.ok(robot.hasOwnProperty('motors'));\n    });\n\n    describe('robot.motors', () =>\n      it('debería tener valor 4', () => Assert.equal(robot.motors, 4))\n    );\n\n  });\n\n});\n"
                }
              }
            },
            "05-arrays-and-objects": {
              "title": "Arreglos y objetos en prototipos",
              "env": "js",
              "body": "<p>Los arreglos y objetos podrían no comportarse como esperas.</p>\n<p>Veamos qué pasa cuando modificamos un arreglo:</p>\n<pre><code class=\"language-js\">const alien = {\n  skills: ['morph']\n};\n\nconst zorg = {};\nzorg.__proto__ = alien;\n\nzorg.skills.push('clone');\n\nconsole.log(zorg.skills); //=&gt; morph, clone\n// es lo que esperabamos\n\nconsole.log(alien.skills); //=&gt; morph, clone\n// quizás no esperábamos esto, pero funciona así porque hemos modificado el\n// arreglo del prototipo.\n</code></pre>\n<p>Cuando modificas un arreglo u objeto, el cambio se hace directamente sobre el objeto.</p>\n<h2 id=\"desafío\">Desafío</h2>\n<p>El 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Arreglos y objetos en prototipos\n\n* Environment: `js`\n\n***\n\nLos arreglos y objetos podrían no comportarse como esperas.\n\nVeamos qué pasa cuando modificamos un arreglo:\n\n```js\nconst alien = {\n  skills: ['morph']\n};\n\nconst zorg = {};\nzorg.__proto__ = alien;\n\nzorg.skills.push('clone');\n\nconsole.log(zorg.skills); //=> morph, clone\n// es lo que esperabamos\n\nconsole.log(alien.skills); //=> morph, clone\n// quizás no esperábamos esto, pero funciona así porque hemos modificado el\n// arreglo del prototipo.\n```\n\nCuando modificas un arreglo u objeto, el cambio se hace directamente sobre el objeto.\n\n## Desafío\n\nEl 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "YXJyYXlzQW5kT2JqZWN0cy5qcw==": "// -> Crea tres objetos: 'machine', 'robot' y 'vehicle'\n// -> En la definición de `machine` incluye una propiedad `parts`, y dale un\n//    array vacío como valor: `[]`\n// -> En la definición de `machine` incluye una propiedad 'capabilities', y\n//    asígnale un objeto vacío: `{}`\n__\n\n// -> Hagamos que el prototipo de tanto `robot` como `vehicle` sea `machine`\nrobot.__proto__ = machine;\nvehicle.__proto__ = machine;\n\n// -> ¿Qué es `robot.parts`?\nclaim(robot.parts, __);\n\n// -> ¿Qué es `vehicle.parts`?\nclaim(vehicle.parts, __);\n\n// -> ¿Qué es `robot.capabilities`?\nclaim(robot.capabilities, __);\n\n// -> ¿Qué es `vehicle.capabilities`?\nclaim(vehicle.capabilities, __);\n\n// -> Añadamos 'core' a `parts` del robot\nrobot.parts.push('core');\n\n// -> ¿Qué es `robot.parts` ahora?\nclaim(robot.parts, __);\n\n// -> ¿Qué es `vehicle.parts` ahora?\nclaim(vehicle.parts, __);\n\n// -> Démosle una habilidad al vehículo...\nvehicle.capabilities.fly = true;\n\n// -> ¿Qué es `robot.capabilities` ahora?\nclaim(robot.capabilities, __);\n\n// -> ¿Qué es `vehicle.capabilities` ahora?\nclaim(vehicle.capabilities, __);\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  machine: machine,\n  vehicle: vehicle,\n  robot:   robot\n}\n"
                },
                "c29sdXRpb24=": {
                  "YXJyYXlzQW5kT2JqZWN0cy5qcw==": "// -> Crea tres objetos: 'machine', 'robot' y 'vehicle'\n// -> En la definición de `machine` incluye una propiedad `parts`, y dale un\n//    array vacío como valor: `[]`\n// -> En la definición de `machine` incluye una propiedad 'capabilities', y\n//    asígnale un objeto vacío: `{}`\n\nconst machine = {\n\tparts: [],\n\tcapabilities: {}\n};\n\nconst vehicle = {};\nconst robot = {};\n\n// -> Hagamos que el prototipo de tanto `robot` como `vehicle` sea `machine`\nrobot.__proto__ = machine;\nvehicle.__proto__ = machine;\n\n// -> ¿Qué es `robot.parts`?\nclaim(robot.parts, []);\n\n// -> ¿Qué es `vehicle.parts`?\nclaim(vehicle.parts, []);\n\n// -> ¿Qué es `robot.capabilities`?\nclaim(robot.capabilities, {});\n\n// -> ¿Qué es `vehicle.capabilities`?\nclaim(vehicle.capabilities, {});\n\nrobot.parts.push('core');\n\n// -> ¿Qué es `robot.parts` ahora?\nclaim(robot.parts, ['core']);\n\n// -> ¿Qué es `vehicle.parts` ahora?\nclaim(vehicle.parts, ['core']);\n\n// -> Démosle una habilidad al vehículo...\nvehicle.capabilities.fly = true;\n\nclaim(robot.capabilities, {fly: true});\nclaim(vehicle.capabilities, {fly: true});\n\nmodule.exports = {\n\tmachine,\n\tvehicle,\n\trobot\n}\n"
                },
                "dGVzdA==": {
                  "YXJyYXlzQW5kT2JqZWN0cy5zcGVjLmpz": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\n\nconst claim = globalScope.claim = (actual, expected) =>\n  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?\n    Assert.deepEqual(actual, expected) :\n    Assert.equal(actual,expected);\n\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/arraysAndObjects');\nconst { machine, vehicle, robot } = Submission;\n\n\ndescribe('arraysAndObjects', () => {\n\n  it('debería exportar un objeto con las propiedades \"machine\", \"vehicle\" y \"robot\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('machine'));\n    Assert.ok(Submission.hasOwnProperty('vehicle'));\n    Assert.ok(Submission.hasOwnProperty('robot'));\n  });\n\n  it('debería invocar claim 8 veces', () => {\n    Assert.equal(spy.callCount, 8);\n  });\n\n  [ [ [ 'core' ], [] ],\n    [ [ 'core' ], [] ],\n    [ { fly: true }, {} ],\n    [ { fly: true }, {} ],\n    [ [ 'core' ], [ 'core' ] ],\n    [ [ 'core' ], [ 'core' ] ],\n    [ { fly: true }, { fly: true } ],\n    [ { fly: true }, { fly: true } ]\n  ].forEach((args, idx) => {\n    describe(`invocación ${idx + 1} a claim`, () =>\n      it(`debería comparar ${args[0]} con ${args[1]}`, () =>\n        Assert.deepEqual(spy.getCall(idx).args, args)\n      )\n    );\n  })\n\n  describe('machine', () => {\n\n    it('debería tener una propiedad parts y capabilities', () => {\n      Assert.ok(machine.hasOwnProperty('parts'));\n      Assert.ok(machine.hasOwnProperty('capabilities'));\n    });\n\n    describe('machine.parts', () => {\n      it('debería tener valor [\"core\"]', () => {\n        Assert.deepEqual(machine.parts,['core']);\n      });\n    });\n\n    describe('machine.capabilities', () => {\n      it('debería tener valor { fly: true }', () => {\n        Assert.deepEqual(machine.capabilities, { fly: true });\n      });\n    });\n  });\n\n  describe('vehicle', () => {\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(vehicle.__proto__, machine);\n    });\n  })\n\n  describe('robot', () => {\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(robot.__proto__, machine);\n    });\n  })\n\n});\n"
                }
              }
            },
            "06-object-create": {
              "title": "Object.create",
              "env": "js",
              "body": "<p>Como comentamos anteriormente, <code>__proto__</code> no es una manera estándar de asignar\nprototipos. Una manera más sencilla es usando <code>Object.create()</code>,\ndisponible en ES5 y para navegadores antiguos podemos usar\n<a href=\"https://github.com/kriskowal/es5-shim\" target=\"_blank\">es5-shim</a>.</p>\n<pre><code class=\"language-js\">const alien = {\n  kind: 'alien'\n};\n\n// creamos un nuevo objeto con `alien` como prototipo\nconst zack = Object.create(alien);\n\nconsole.log(zack.kind); // =&gt; 'alien'\n</code></pre>\n<p>Podemos pasar un objeto a <code>Object.create</code> para añadir propiedades al nuevo\nobjeto:</p>\n<pre><code class=\"language-js\">const zack = Object.create(alien, {age: {value:  13} });\nconsole.log(zack.age); // =&gt; '13'\n</code></pre>\n<p>Sí, el objeto que tenemos que pasar es un poco complicado, pero así es. Puedes\nver más en la\n<a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\">documentación oficial</a>.</p>\n<h2 id=\"objectgetprototypeof\"><code>Object.getPrototypeOf</code></h2>\n<p>Puedes acceder al prototipo de un objeto usando <code>Object.getPrototypeOf</code>:</p>\n<pre><code class=\"language-js\">const zack = Object.create(alien);\nObject.getPrototypeOf(zack); //=&gt; alien\n</code></pre>\n<h2 id=\"objectsetprototypeof\"><code>Object.setPrototypeOf</code></h2>\n<p>A partir de ES2015, también tenemos <code>Object.setPrototypeOf(object, prototype)</code>\ncomo una alternativa oficial para cambiar la propiedad <code>__proto__</code>. Aún así,\nno es recomendable alterar el prototipo durante la ejecución ya que es un\nproceso lento. Siempre es mejor definir el prototipo <em>antes</em> de crear el objeto,\npor ejemplo usando <code>Object.create()</code>.</p>\n<h2 id=\"desafío\">Desafío</h2>\n<p>El 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Object.create\n\n* Environment: `js`\n\n***\n\nComo comentamos anteriormente, `__proto__` no es una manera estándar de asignar\nprototipos. Una manera más sencilla es usando `Object.create()`,\ndisponible en ES5 y para navegadores antiguos podemos usar\n[es5-shim](https://github.com/kriskowal/es5-shim).\n\n```js\nconst alien = {\n  kind: 'alien'\n};\n\n// creamos un nuevo objeto con `alien` como prototipo\nconst zack = Object.create(alien);\n\nconsole.log(zack.kind); // => 'alien'\n```\n\nPodemos pasar un objeto a `Object.create` para añadir propiedades al nuevo\nobjeto:\n\n```js\nconst zack = Object.create(alien, {age: {value:  13} });\nconsole.log(zack.age); // => '13'\n```\n\nSí, el objeto que tenemos que pasar es un poco complicado, pero así es. Puedes\nver más en la\n[documentación oficial](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create).\n\n## `Object.getPrototypeOf`\n\nPuedes acceder al prototipo de un objeto usando `Object.getPrototypeOf`:\n\n```js\nconst zack = Object.create(alien);\nObject.getPrototypeOf(zack); //=> alien\n```\n\n## `Object.setPrototypeOf`\n\nA partir de ES2015, también tenemos `Object.setPrototypeOf(object, prototype)`\ncomo una alternativa oficial para cambiar la propiedad `__proto__`. Aún así,\nno es recomendable alterar el prototipo durante la ejecución ya que es un\nproceso lento. Siempre es mejor definir el prototipo *antes* de crear el objeto,\npor ejemplo usando `Object.create()`.\n\n## Desafío\n\nEl 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "b2JqZWN0Q3JlYXRlLmpz": "// -> Creamos un objeto llamado `machine`\nconst machine = {};\n\n// -> Usa Object.create para crear otro objeto llamado `robot` con `machine`\n//    como prototipo\n__\n\n// -> Usa Object.create para crear otro objeto llamado `robby` con `robot`\n//    como prototipo\n__\n\n// -> ¿Cuál es el resultado de `machine.isPrototypeOf(robby)`?\nclaim(machine.isPrototypeOf(robby), __);\n\n// -> ¿Cuál es el resultado de `robot.isPrototypeOf(robby)`?\nclaim(robot.isPrototypeOf(robby), __);\n\n// -> ¿Qué objeto es el prototipo directo de `robby`?\nclaim(Object.getPrototypeOf(robby), __);\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  machine,\n  robot,\n  robby\n}\n"
                },
                "c29sdXRpb24=": {
                  "b2JqZWN0Q3JlYXRlLmpz": "const machine = {}\n\nconst robot = Object.create(machine);\nconst robby = Object.create(robot);\n\n// -> ¿Cuál es el resultado de `machine.isPrototypeOf(robby)`?\nclaim(machine.isPrototypeOf(robby), true);\n\n// -> ¿Cuál es el resultado de `robot.isPrototypeOf(robby)`?\nclaim(robot.isPrototypeOf(robby), true);\n\n// -> ¿Qué objeto es el prototipo directo de `robby`?\nclaim(Object.getPrototypeOf(robby), robot);\n\n// ------------------------------------------------\nmodule.exports = {\n\tmachine,\n\trobot,\n\trobby\n}\n"
                },
                "dGVzdA==": {
                  "b2JqZWN0Q3JlYXRlLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\n\nconst claim = globalScope.claim = (actual, expected) =>\n  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?\n    Assert.deepEqual(actual, expected) :\n    Assert.equal(actual,expected);\n\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/objectCreate');\nconst { machine, robot, robby } = Submission;\n\ndescribe('objectCreate', () => {\n\n  it('debería exportar un objeto con las propiedades \"machine\", \"robot\" y \"robby\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('machine'));\n    Assert.ok(Submission.hasOwnProperty('robot'));\n    Assert.ok(Submission.hasOwnProperty('robby'));\n  });\n\n  it('debería invocar claim 3 veces', () => {\n    Assert.equal(spy.callCount, 3);\n  });\n\n  [\n    [ true, true ],\n    [ true, true ],\n    [ {}, {} ]\n  ].forEach((args, idx) => {\n    describe(`invocación ${idx + 1} a claim`, () =>\n      it(`debería comparar ${args[0]} con ${args[1]}`, () =>\n        Assert.deepEqual(spy.getCall(idx).args, args)\n      )\n    );\n  });\n\n  describe('robot', () => {\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(robot.__proto__, machine);\n    });\n  });\n\n  describe('robby', () => {\n\n    it('debería ser un objeto con machine como prototipo', () => {\n      Assert.equal(robby.__proto__.__proto__, machine);\n    });\n\n    it('debería ser un objeto con robot como prototipo', () => {\n      Assert.equal(robby.__proto__, robot);\n    });\n  });\n\n})\n"
                }
              }
            },
            "07-dot-new": {
              "title": "Nuestro propio 'new'",
              "env": "js",
              "body": "<p>Llegado a este punto, sabemos suficiente como para hacer cosas increibles con\nobjetos en JavaScript.</p>\n<h2 id=\"desafío\">Desafío</h2>\n<ul>\n<li>Define un objeto llamado <code>Robot</code></li>\n<li>Define un método llamado <code>new</code> en <code>Robot</code></li>\n<li>Cuando invocamos <code>Robot.new()</code>, debe retornar un objeto nuevo con <code>Robot</code> como\nprototipo. Por ejemplo:</li>\n</ul>\n<pre><code class=\"language-js\">const robby = Robot.new();\n// Robot debe ser el prototipo de Robby\n</code></pre>\n<h2 id=\"boilerplate\">Boilerplate</h2>\n<p>El 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Nuestro propio 'new'\n\n* Environment: `js`\n\n***\n\nLlegado a este punto, sabemos suficiente como para hacer cosas increibles con\nobjetos en JavaScript.\n\n## Desafío\n\n* Define un objeto llamado `Robot`\n* Define un método llamado `new` en `Robot`\n* Cuando invocamos `Robot.new()`, debe retornar un objeto nuevo con `Robot` como\n  prototipo. Por ejemplo:\n\n```js\nconst robby = Robot.new();\n// Robot debe ser el prototipo de Robby\n```\n\n## Boilerplate\n\nEl 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "ZG90TmV3Lmpz": "// -> Define un objeto llamado `Robot`\n// -> Define un método llamado `new` en `Robot`\n// -> Cuando llamamos a `Robot.new()` debe retornar un objeto nuevo con Robot\n//    como prototipo\n//    Por ejemplo: const robby = Robot.new();\n//    `Robot` debe ser el prototipo de `robby`\n\n__\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  Robot\n}\n"
                },
                "c29sdXRpb24=": {
                  "ZG90TmV3Lmpz": "// -> Define un objeto llamado `Robot`\n// -> Define un método llamado `new` en `Robot`\n// -> Cuando llamamos a `Robot.new()` debe retornar un objeto nuevo con Robot\n//    como prototipo\n//    Por ejemplo: const robby = Robot.new();\n//    `Robot` debe ser el prototipo de `robby`\n\nconst Robot = {\n\tnew: function () {\n\t\treturn Object.create(this);\n\t}\n}\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n\tRobot\n}\n"
                },
                "dGVzdA==": {
                  "ZG90TmV3LnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\n\nconst claim = globalScope.claim = (actual, expected) =>\n  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?\n    Assert.deepEqual(actual, expected) :\n    Assert.equal(actual,expected);\n\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/dotNew');\nconst { Robot } = Submission;\n\ndescribe('dotNew', () => {\n\n  it('debería exportar un objeto con las propiedades \"Robot\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('Robot'));\n  });\n\n  describe('Robot', () => {\n\n    it('debería tener una función llamada \"new\"', () => {\n      Assert.equal(typeof Robot.new,'function');\n    });\n\n    describe('Robot.new', () => {\n\n      it('debería devolver un objeto que tiene como prototipo a Robot',() => {\n        Assert.equal(Robot.new().__proto__, Robot);\n      });\n\n    });\n\n  });\n\n});\n"
                }
              }
            },
            "08-constructor-functions": {
              "title": "Constructores",
              "env": "js",
              "body": "<p>Los <strong>Constructores</strong> son probablemente la manera más común de implementar\ncadenas de prototipos. La popularidad de los constructores se debe a que estos\neran la manera en la que originalmente se construían \"tipos\".\nAlgunos motores están altamente optimizados para usar constructores.</p>\n<p>En JavaScript puedes crear un objeto de esta manera:</p>\n<pre><code class=\"language-js\">function Alien() {\n  this.age = 10;\n}\n\nconst zippy = new Alien();\n</code></pre>\n<p>Cuando usamos funciones con la palabra clave <code>new</code>, se comportan de una manera\nun tanto especial; crean objetos. El nuevo objeto creado se vincula a la función\na través del prototipo (más sobre esto más adelante). Así que en JavaScript, a\nestos objetos creados por constructores los llamamos una <strong>instancia</strong> de la\nfunción.</p>\n<pre><code class=\"language-js\">// zippy is an instance of Alien\nconsole.log(zippy instanceof Alien); //=&gt; true\n</code></pre>\n<h2 id=\"desafío\">Desafío</h2>\n<p>El 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Constructores\n\n* Environment: `js`\n\n***\n\nLos __Constructores__ son probablemente la manera más común de implementar\ncadenas de prototipos. La popularidad de los constructores se debe a que estos\neran la manera en la que originalmente se construían \"tipos\".\nAlgunos motores están altamente optimizados para usar constructores.\n\nEn JavaScript puedes crear un objeto de esta manera:\n\n```js\nfunction Alien() {\n  this.age = 10;\n}\n\nconst zippy = new Alien();\n```\n\nCuando usamos funciones con la palabra clave `new`, se comportan de una manera\nun tanto especial; crean objetos. El nuevo objeto creado se vincula a la función\na través del prototipo (más sobre esto más adelante). Así que en JavaScript, a\nestos objetos creados por constructores los llamamos una __instancia__ de la\nfunción.\n\n```js\n// zippy is an instance of Alien\nconsole.log(zippy instanceof Alien); //=> true\n```\n\n## Desafío\n\nEl 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "Y29uc3RydWN0b3JGdW5jdGlvbnMuanM=": "// -> Define un constructor 'Robot'\n// -> Dentro de la función `Robot` asigna una propiedad 'motors' en 'this',\n//    y dale el valor `2` a `motors`\n// -> Crear una instancia de `Robot` llamada `robby`\n\n__\n\n// -> ¿Cuál es el resultado de `(robby instanceof Robot)`?\nclaim(robby instanceof Robot, __);\n\n// -> ¿Qué valor tiene `robby.motors`?\nclaim(robby.motors, __);\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  Robot,\n  robby\n}\n"
                },
                "c29sdXRpb24=": {
                  "Y29uc3RydWN0b3JGdW5jdGlvbnMuanM=": "// -> Define un constructor 'Robot'\n// -> Dentro de la función `Robot` asigna una propiedad 'motors' en 'this',\n//    y dale el valor `2` a `motors`\n// -> Crear una instancia de `Robot` llamada `robby`\n\nfunction Robot() {\n\tthis.motors = 2;\n};\n\nconst robby = new Robot();\n\n// -> ¿Cuál es el resultado de `(robby instanceof Robot)`?\nclaim(robby instanceof Robot, true);\n\n// -> ¿Qué valor tiene `robby.motors`?\nclaim(robby.motors, 2);\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n\tRobot,\n\trobby\n}\n"
                },
                "dGVzdA==": {
                  "Y29uc3RydWN0b3JGdW5jdGlvbnMuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\n\nconst claim = globalScope.claim = (actual, expected) =>\n  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?\n    Assert.deepEqual(actual, expected) :\n    Assert.equal(actual,expected);\n\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/constructorFunctions');\nconst { Robot, robby } = Submission;\n\ndescribe('objectCreate', () => {\n\n  it('debería exportar un objeto con las propiedades \"Robot\", \"robby\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('Robot'));\n    Assert.ok(Submission.hasOwnProperty('robby'));\n  });\n\n  it('debería invocar claim 2 veces', () => {\n    Assert.equal(spy.callCount, 2);\n  });\n\n  [\n    [ true, true ],\n    [ 2, 2 ]\n  ].forEach((args, idx) => {\n    describe(`invocación ${idx + 1} a claim`, () =>\n      it(`debería comparar ${args[0]} con ${args[1]}`, () =>\n        Assert.deepEqual(spy.getCall(idx).args, args)\n      )\n    );\n  });\n\n  describe('Robot', () => {\n\n    it('debería ser un constructor', () => {\n      Assert.equal(typeof Robot,'function');\n    });\n\n  });\n\n  describe('robby', () => {\n\n    it('debería ser una una instancia de robot',() => {\n      Assert.equal(robby.__proto__,new Robot().__proto__);\n    });\n\n    it('debería tener una propiedad motors con valor 2', () => {\n      Assert.equal(robby.motors,2);\n    });\n\n  });\n\n\n});\n"
                }
              }
            },
            "09-implicit-this": {
              "title": "'this' se asigna implícitamente",
              "env": "js",
              "body": "<p>Cuando usamos <code>new</code> con una función, JavaScript inyecta una referencia implícita\nal nuevo objeto creado a través de la pseudo-variable <code>this</code>.\nAdemás, retorna esta referencia implícitamente al final de la función.</p>\n<p>Cuando hacemos esto:</p>\n<pre><code class=\"language-js\">function Alien() {\n  this.kind = 'alien';\n}\n\nconst zippy = new Alien();\nzippy.kind; //=&gt; 'alien'\n</code></pre>\n<p>Detrás de las cortinas JavaScript hace algo como:</p>\n<pre><code class=\"language-js\">function Alien() {\n  const this = {}; // no es JavaScript válido, sólo para ilustrar el concepto\n  this.__proto__ = Alien.prototype;\n\n  this.kind = 'alien';\n\n  return this;\n}\n</code></pre>\n<p>Hay que estar atentos al hecho que <code>this</code> sólo se asigna implícitamente al\nnuevo objeto cuando usamos el keyword <code>new</code>. Si te olvidas de poner <code>new</code>, la\npseudo-variable <code>this</code> será una referencia al objeto global. Esto hace que <code>new</code>\nsea una causa común de errores, así que no te olvides de usar <code>new</code> cuando sea\nnecesario.</p>\n<p>Una convención popular es poner la primera letra en mayúscula al nombrar la\nfunción (por ejemplo <code>Alien</code>), así resulta más fácil identificar el hecho de que\nla función debe ser llamada con <code>new</code>.</p>\n<h2 id=\"desafío\">Desafío</h2>\n<p>El 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# 'this' se asigna implícitamente\n\n* Environment: `js`\n\n***\n\nCuando usamos `new` con una función, JavaScript inyecta una referencia implícita\nal nuevo objeto creado a través de la pseudo-variable `this`.\nAdemás, retorna esta referencia implícitamente al final de la función.\n\nCuando hacemos esto:\n\n```js\nfunction Alien() {\n  this.kind = 'alien';\n}\n\nconst zippy = new Alien();\nzippy.kind; //=> 'alien'\n```\n\nDetrás de las cortinas JavaScript hace algo como:\n\n```js\nfunction Alien() {\n  const this = {}; // no es JavaScript válido, sólo para ilustrar el concepto\n  this.__proto__ = Alien.prototype;\n\n  this.kind = 'alien';\n\n  return this;\n}\n```\n\nHay que estar atentos al hecho que `this` sólo se asigna implícitamente al\nnuevo objeto cuando usamos el keyword `new`. Si te olvidas de poner `new`, la\npseudo-variable `this` será una referencia al objeto global. Esto hace que `new`\nsea una causa común de errores, así que no te olvides de usar `new` cuando sea\nnecesario.\n\nUna convención popular es poner la primera letra en mayúscula al nombrar la\nfunción (por ejemplo `Alien`), así resulta más fácil identificar el hecho de que\nla función debe ser llamada con `new`.\n\n## Desafío\n\nEl 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "aW1wbGljaXRUaGlzLmpz": "// -> Define dos constructores: 'Robot' y 'Vehicle'\n// -> Cuando `Robot` se invoque con 'new' debe retornar el 'this' implícito\n// -> Cuando `Vehicle` se invoque con 'new', debe retornar un objeto cualquiera,\n//    no el 'this' implícito.\n\n__\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  Robot,\n  Vehicle\n}\n"
                },
                "c29sdXRpb24=": {
                  "aW1wbGljaXRUaGlzLmpz": "// -> Define dos constructores: 'Robot' y 'Vehicle'\n// -> Cuando `Robot` se invoque con 'new' debe retornar el 'this' implícito\n// -> Cuando `Vehicle` se invoque con 'new', debe retornar un objeto cualquiera,\n//    no el 'this' implícito.\n\nfunction Robot() {\n\n}\n\nfunction Vehicle() {\n\treturn {};\n}\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n\tRobot,\n\tVehicle\n}\n"
                },
                "dGVzdA==": {
                  "aW1wbGljaXRUaGlzLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\n\nconst claim = globalScope.claim = (actual, expected) =>\n  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?\n    Assert.deepEqual(actual, expected) :\n    Assert.equal(actual,expected);\n\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/implicitThis');\nconst { Robot, Vehicle } = Submission;\n\ndescribe('implicitThis', () => {\n\n  it('debería exportar un objeto con las propiedades \"Robot\", \"Vehicle\"', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('Robot'));\n    Assert.ok(Submission.hasOwnProperty('Vehicle'));\n  });\n\n  describe('Robot', () => {\n\n    it('debería ser un constructor', () => {\n      Assert.equal(typeof Robot,'function');\n    });\n\n    describe('new Robot', () => {\n\n      it('debería retornar una instancia de robot', () => {\n        const robot = new Robot();\n        Assert.equal(robot instanceof Robot,true);\n      })\n    })\n\n  });\n\n  describe('Vehicle', () => {\n\n    it('debería ser un constructor', () => {\n      Assert.equal(typeof Vehicle, 'function');\n    });\n\n    describe('new Vehicle', () => {\n\n      it('no debería retornar una instancia de Vehicle', () => {\n        const vehicle = new Vehicle();\n        Assert.equal(vehicle instanceof Vehicle, false);\n      });\n\n    });\n\n\n  });\n\n\n});\n"
                }
              }
            },
            "10-function-prototype": {
              "title": "Prototipos de funciones",
              "env": "js",
              "body": "<p>Toda función en JavaScript tiene una propiedad especial llamada <code>prototype</code>.</p>\n<pre><code class=\"language-js\">function Alien() {}\n\nAlien.prototype;\n</code></pre>\n<p>Aunque parezca confuso, esta propiedad <code>prototype</code> no es el prototipo real\n(<code>__proto__</code>) de la función.</p>\n<pre><code class=\"language-js\">Alien.__proto__ === Alien.prototype; //=&gt; false\n</code></pre>\n<p>Esto obviamente genera mucha confusión a la hora de usar el término \"prototipo\"\npara refererirnos a cosas diferentes.</p>\n<p>Una buena acalaración es siempre usar '<strong>prototipo de función</strong>' para\nrefererirnos a este <code>prototype</code> especial, y nunca simplemente \"prototype\".</p>\n<p>Este <code>prototype</code> apunta al objeto que será asignado como el prototipo de\ninstancias creadas con la función (el constructor) cuando se use con <code>new</code>.</p>\n<p>Confundida? Veamos un ejemplo:</p>\n<pre><code class=\"language-js\">function Alien(name) {\n  this.name = name;\n}\n\n// la función Alien tiene una propiedad prototype\n// podemos añadir propiedades al prototipo de la función\nAlien.prototype.kind = 'alien';\n\n// creamos un objeto usando `new`\nconst zippy = new Alien('Zippy');\n\n// el __proto__ del nuevo objeto apunta a Alien.prototype\nzippy.__proto__ == Alien.prototype; //=&gt; true\n\n// en el nuevo objeto tenemos acceso a las propiedades definidas en Alien.prototype\nzippy.kind; //=&gt; alien\n</code></pre>\n<p>Acá puedes ver un <a href=\"https://docs.google.com/drawings/d/1AKJcvxs0t3iGtqkRV8rFAWlo7tojkOSwjfhr1NWaTb0/pub?w=889&amp;h=482\" target=\"_blank\">diagrama que muestra esta relación</a>.</p>\n<p>Así que si tienes dos instancias de <code>Alien</code>, ambas recibirán <code>Alien.prototype</code>\ncomo su <code>__proto__</code>. Lo que pongas ahí será compartido por todas las instancias.</p>\n<p>Esto es casi todo lo que hay que saber sobre el \"JavaScript object model\".\nEntender cómo se relacionan <code>__proto__</code> y <code>function.prototype</code> te dará\nincontables momentos de alegría y satisfacción. O quizás no ;-)</p>\n<h2 id=\"desafío\">Desafío</h2>\n<p>El 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Prototipos de funciones\n\n* Environment: `js`\n\n***\n\nToda función en JavaScript tiene una propiedad especial llamada `prototype`.\n\n```js\nfunction Alien() {}\n\nAlien.prototype;\n```\n\nAunque parezca confuso, esta propiedad `prototype` no es el prototipo real\n(`__proto__`) de la función.\n\n```js\nAlien.__proto__ === Alien.prototype; //=> false\n```\n\nEsto obviamente genera mucha confusión a la hora de usar el término \"prototipo\"\npara refererirnos a cosas diferentes.\n\nUna buena acalaración es siempre usar '__prototipo de función__' para\nrefererirnos a este `prototype` especial, y nunca simplemente \"prototype\".\n\nEste `prototype` apunta al objeto que será asignado como el prototipo de\ninstancias creadas con la función (el constructor) cuando se use con `new`.\n\nConfundida? Veamos un ejemplo:\n\n```js\nfunction Alien(name) {\n  this.name = name;\n}\n\n// la función Alien tiene una propiedad prototype\n// podemos añadir propiedades al prototipo de la función\nAlien.prototype.kind = 'alien';\n\n// creamos un objeto usando `new`\nconst zippy = new Alien('Zippy');\n\n// el __proto__ del nuevo objeto apunta a Alien.prototype\nzippy.__proto__ == Alien.prototype; //=> true\n\n// en el nuevo objeto tenemos acceso a las propiedades definidas en Alien.prototype\nzippy.kind; //=> alien\n```\n\nAcá puedes ver un [diagrama que muestra esta relación](https://docs.google.com/drawings/d/1AKJcvxs0t3iGtqkRV8rFAWlo7tojkOSwjfhr1NWaTb0/pub?w=889&h=482).\n\nAsí que si tienes dos instancias de `Alien`, ambas recibirán `Alien.prototype`\ncomo su `__proto__`. Lo que pongas ahí será compartido por todas las instancias.\n\nEsto es casi todo lo que hay que saber sobre el \"JavaScript object model\".\nEntender cómo se relacionan `__proto__` y `function.prototype` te dará\nincontables momentos de alegría y satisfacción. O quizás no ;-)\n\n## Desafío\n\nEl 'boilerplate' tiene las instrucciones y los\nlugares donde añadir tu código debidamente señalados.\n",
                "Ym9pbGVycGxhdGU=": {
                  "ZnVuY3Rpb25Qcm90b3R5cGUuanM=": "// -> Define un constructor 'Robot'\n// -> Crea dos instancias de Robot: 'robby' y 'cranky'\n// -> Tanto robby como cranky deben tener 'parts' y 'capabilities', éstas deben\n//    ser arrays vacíos al inicio\n\n__\n\n// -> ¿Cúal es el resultado de robby.parts?\nclaim(robby.parts, __);\n// -> ¿Cúal es el resultado de cranky.parts?\nclaim(cranky.parts, __);\n// -> ¿Cúal es el resultado de robby.capabilities?\nclaim(robby.capabilities, __);\n// -> ¿Cúal es el resultado de cranky.capabilities?\nclaim(cranky.capabilities, __);\n\n// -> Añade 'core' a robby.parts, cranky.parts debería tener todavía un arreglo vacío\n// -> Añade 'fly' a robby.capabilities, después de esto cranky.capabilities debe\n//    también tener 'fly' sin añadírselo directamente, así que esta propiedad\n//    debe ser compartida.\n\n__\n\n// -> ¿Cúal es el resultado de robby.parts?\nclaim(robby.parts, __);\n// -> ¿Cúal es el resultado de cranky.parts?\nclaim(cranky.parts, __);\n// -> ¿Cúal es el resultado de robby.capabilities?\nclaim(robby.capabilities, __);\n// -> ¿Cúal es el resultado de cranky.capabilities?\nclaim(cranky.capabilities, __);\n\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n  Robot,\n  robby,\n  cranky\n}\n"
                },
                "c29sdXRpb24=": {
                  "ZnVuY3Rpb25Qcm90b3R5cGUuanM=": "// -> Define un constructor 'Robot'\n// -> Crea dos instancias de Robot: 'robby' y 'cranky'\n// -> Tanto robby como cranky deben tener 'parts' y 'capabilities', éstas deben\n//    ser arrays vacíos al inicio\nfunction Robot() {\n\tthis.parts = [];\n}\n\nRobot.prototype.capabilities = [];\n\nconst robby = new Robot();\nconst cranky = new Robot();\n\n// -> ¿Cúal es el resultado de robby.parts?\nclaim(robby.parts, []);\n// -> ¿Cúal es el resultado de cranky.parts?\nclaim(cranky.parts, []);\n// -> ¿Cúal es el resultado de robby.capabilities?\nclaim(robby.capabilities, []);\n// -> ¿Cúal es el resultado de cranky.capabilities?\nclaim(cranky.capabilities, []);\n\n// -> Añade 'core' a robby.parts, cranky.parts debería tener todavía un arreglo vacío\n// -> Añade 'fly' a robby.capabilities, después de esto cranky.capabilities debe\n//    también tener 'fly' sin añadírselo directamente, así que esta propiedad\n//    debe ser compartida.\nrobby.parts.push('core');\nrobby.capabilities.push('fly');\n\n// -> ¿Cúal es el resultado de robby.parts?\nclaim(robby.parts, ['core']);\n// -> ¿Cúal es el resultado de cranky.parts?\nclaim(cranky.parts, []);\n// -> ¿Cúal es el resultado de robby.capabilities?\nclaim(robby.capabilities, ['fly']);\n// -> ¿Cúal es el resultado de cranky.capabilities?\nclaim(cranky.capabilities, ['fly']);\n\n// ------------------------------------------------\n// Exports de Common JS para verificación, no modificar\nmodule.exports = {\n\tRobot,\n\trobby,\n\tcranky\n}\n"
                },
                "dGVzdA==": {
                  "ZnVuY3Rpb25Qcm90b3R5cGUuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst globalScope = (typeof self !== 'undefined' ? self : global);\n\nconst claim = globalScope.claim = (actual, expected) =>\n  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?\n    Assert.deepEqual(actual, expected) :\n    Assert.equal(actual,expected);\n\nconst spy = Sinon.spy(globalScope, 'claim');\nconst Submission = require('../solution/functionPrototype');\nconst { Robot, robby, cranky } = Submission;\n\ndescribe('functionPrototype', () => {\n\n  it('debería exportar un objeto con las propiedades \"Robot\", \"robby\", \"cranky\" ', () => {\n    Assert.equal(typeof Submission, 'object');\n    Assert.ok(Submission.hasOwnProperty('Robot'));\n    Assert.ok(Submission.hasOwnProperty('robby'));\n    Assert.ok(Submission.hasOwnProperty('cranky'));\n  });\n\n  describe('Robot',() => {\n\n    it('debería ser una función', () => {\n      Assert.isFunction(Robot);\n    });\n\n    it('debería tener una instancia de parts', () => {\n      const other = new Robot();\n      Assert.isDefined(other.parts);\n    });\n\n    it('debería tener una instancia de capabilities', () => {\n      const other = new Robot();\n      Assert.isDefined(other.capabilities);\n    });\n\n    it('debería comenzar vacío',() => {\n      const other = new Robot();\n      Assert.equal(other.parts.length,0);\n    });\n\n    describe('Robot.parts',() => {\n\n      it('debería ser un array', () => {\n        const other = new Robot();\n        Assert.isArray(other.parts);\n      })\n    });\n\n    describe('Robot.capabilities',() => {\n\n      it('debería ser un array', () => {\n        const other = new Robot();\n        Assert.isArray(other.capabilities);\n      });\n    });\n\n  });\n\n  describe('robby',() => {\n\n    it ('debería ser una instancia de Robot',() => {\n      Assert.instanceOf(robby, Robot);\n    });\n\n    it('debería tener un elemento', () => {\n      Assert.equal(robby.parts.length, 1);\n    });\n\n    it('debería tener un elemento que sea \"core\"', () => {\n      Assert.equal(robby.parts[0],'core');\n    });\n\n    describe('robby.capabilities', () => {\n\n      it ('debería tener un elemento', () => {\n        Assert.equal(robby.capabilities.length, 1);\n      });\n\n      it('Su primer elemento debería ser \"fly\"', () => {\n        Assert.equal(robby.capabilities[0],'fly');\n      });\n    });\n\n  });\n\n  describe('cranky',() => {\n\n    it ('debería ser una instancia de Robot',() => {\n      Assert.instanceOf(cranky, Robot);\n    });\n\n    describe('cranky.parts', () => {\n\n      it('debería tener 0 elementos', () => {\n        Assert.equal(cranky.parts.length, 0);\n      });\n\n    });\n\n    describe('cranky.capabilities', () => {\n\n      it('no esta agregado directamente a cranky', () => {\n        Assert.isFalse(cranky.hasOwnProperty('capabilities'));\n      });\n\n      it('debería tener un elemento', () => {\n        Assert.equal(cranky.capabilities.length, 1);\n      });\n\n      it('Su primer elemento debería ser \"fly\"', () => {\n        Assert.equal(cranky.capabilities[0],'fly');\n      });\n\n    })\n  });\n\n\n});\n"
                }
              }
            }
          },
          "order": 4,
          "durationString": "1.5h"
        },
        "06-closing": {
          "title": "Cierre",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<h2 id=\"resumen\">Resumen</h2>\n<p><code>this</code> es una pseudo-variable que existe dentro de las funciones. El valor de\n<code>this</code> debe ser <em>inferido</em> del contexto donde aparece, y por eso puede ser\nmotivo de confusión.</p>\n<p>El método <code>bind</code> de las funciones nos permite crear una nueva versión de la\nfunción pero con <code>this</code> seteado a un valor específico.</p>\n<p>Cuando usamos una función como un <em>método</em> de un objeto, <code>this</code> toma el valor\ndel objeto que contiene al <em>método</em>.</p>\n<p>También podemos usar constructores para crear objetos con un prototipo\nespecífico, así como <code>Object.create</code>.</p>\n<p>El operador <code>instanceof</code> nos permite determinar si un objeto fue creado con un\nconstructor específico y <code>Object.prototype.isPrototypeOf</code> para determinar si un\nobjeto está la cadena de prototipos de otro objeto.</p>\n<p>Todo objeto tiene un prototipo, que a su vez es un objeto que puede tener su\npropio prototipo. Esto crea lo que llamamos <strong>cadena de prototipos</strong> y nos\npermite implementar herencia.</p>\n<h2 id=\"respondamos-juntxs-las-preguntas-de-la-apertura\">Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Qué valor toma <code>this</code> cuando no puede ser inferido por el contexto?</li>\n<li>Qué hace el método <code>bind</code> que tienen todas las funciones?</li>\n<li>Cómo infiere JavaScript el valor de <code>this</code> dentro de una función?</li>\n<li>Qué es un <strong>constructor</strong>?</li>\n<li>Cómo usar <code>new</code> para crear instancias de un constructor?</li>\n<li>Cómo usar <code>instanceof</code> para determinar si un objeto fue creado con un\nconstructor específico?</li>\n<li>Cómo usar <code>Object.prototype.isPrototypeOf</code> para determinar si un objeto está\nla cadena de prototipos de otro objeto?</li>\n<li>Cómo añadir propiedades al prototipo de un constructor usando <code>Function.prototype</code>?</li>\n<li>Cómo usar <code>Object.create</code> para crear objetos con un prototipo específico?</li>\n<li>Cómo implementar <strong>herencia prototipal</strong>?</li>\n</ul>\n",
          "order": 5,
          "durationString": "5min"
        }
      },
      "order": 1,
      "stats": {
        "duration": 132,
        "durationString": "2.2h",
        "exerciseCount": 10,
        "partCount": 6
      }
    },
    "06-composition": {
      "title": "Object factories and composition",
      "bonus": false,
      "description": "<p>En esta lección veremos en detalle cómo usar composición como una alternativa a\nlas jerarquías de herencia, y así poder comparar el enfoque funcional frente al\norientado a objetos en un ámbito concreto de arquitectura y reuso de código.</p>\n",
      "parts": {
        "00-opening": {
          "title": "Apertura",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<h2 id=\"¿por-qué-aprender-esto\">¿Por qué aprender esto?</h2>\n<p>Como parte de los paradigmas de programación, veremos <strong>composición</strong>. Para\nesto, emprenderemos un camino visitando cierto conceptos fundamentales, que a lo\nlargo de esta lección nos darán nociones claras de ¿qué es?, ¿para qué sirve? y\n¿cómo se utiliza? la <strong>composición</strong>.</p>\n<p>Como vimos en la lección anterior, revisamos los conceptos que definen la\n<strong>P</strong>rogramación <strong>O</strong>rientada a <strong>O</strong>bjetos (POO), y como vimos, ésta nos\npermite modelar el comportamiento de ciertos elementos del mundo real, en otras\npalabras, respondimos la pregunta \"¿qué son?\", utilizando propiedades y acciones\npara definir su comportamiento. En cambio con la <strong>composición</strong>, y a medida que\navanzamos en esta lección será más claro, modelamos \"qué hacen\", definiendo sus\nmétodos/acciones por medio de las <strong>funciones</strong>.</p>\n<p>Es por esto, que revisaremos algunos conceptos asociados a la programación\nfuncional. Analizaremos las diferencias entre <strong>composición</strong> y <strong>herencia</strong>,\nventajas y desventajas de este nuevo paradigma; y revisaremos ejemplos concretos\ndonde se verá aplicado este nuevo paradigma.</p>\n<p>Al final de esta unidad, habremos aprendido una nueva técnica de programación,\nque nos permitirá crear y mantener mejor código y que además tendremos en\nnuestra caja de herramientas, para utilizar en nuestros futuros proyectos.</p>\n<h2 id=\"guía-de-preguntas-y-conceptos-clave\">Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Principios básicos de la <strong>programación funcional</strong>.</li>\n<li>Cómo usar <strong>composición</strong> como alternativa a la <em>herencia</em>.</li>\n<li><code>Object.assign</code>.</li>\n<li>Qué beneficios tienen las <strong>Factories</strong>.</li>\n<li>Cómo beneficiarse del <strong>Clousure</strong>.</li>\n</ul>\n",
          "order": 0,
          "durationString": "5min"
        },
        "01-closures": {
          "title": "Closures",
          "type": "read",
          "format": "self-paced",
          "duration": 3,
          "body": "<p>Para poder entender las funciones <em>factory</em> y el mecanismo de composición de\nobjetos que vamos ver más adelante, es esencial sentirse cómoda con el concepto\nde <em>closure</em>.</p>\n<p>En JavaScript las <em>funciones</em> no son sólo \"funciones\", también son <em>closures</em>.\nEsto quiere decir que cuando declaramos una función, el cuerpo de la función\ntiene acceso al scope dónde se declaró la funcíon además de su scope local.\n<em>Closure</em> significa que las funciones se \"cierran\" alrededor de las variables a\nlas que tiene acceso. Por lo tanto, una función creada dentro de otra función\ntiene acceso a las variables del scope de la función que la envuelve, incluso\ndespués de que ésta haya retornado. Considera el siguiente snippet:</p>\n<pre><code class=\"language-js\">const makeFunction = function () {\n  const foo = true;\n  return function () {\n    return foo;\n  };\n};\n\nconst myFunc = makeFunction();\nmyFunc(); // true\n</code></pre>\n<p>En el ejemplo de arriba podemos ver que <code>makeFunction</code> es una función anónima\nque retorna otra función anónima, y ésta última todavía tiene acceso a <code>foo</code>\n(una variable local de <code>makeFunction</code>) después de que <code>makeFunction</code> ya ha\nretornado.</p>\n<p>Los closures son un \"feature\" muy poderoso y nos van a permitir crear scopes\n\"privados\" (sólo visibles para aquellas funciones creadas dentro de un scope\ncompartido.</p>\n<p>Esto no sólo se aplica a variables declaradas dentro del scope, sino a todas las\nvariables \"visibles\" dentro de ese scope, incluyendo los argumentos de\ninvocación.</p>\n<pre><code class=\"language-js\">// una función que crea un objeto, y sus métodos tienen acceso a los argumentos\n// con los que se invocó la función que creó el objeto.\nconst createNote = text =&gt; ({\n  print: () =&gt; console.log(text)\n});\n\nconst note = createNote('lorem ipsum')\nnote.print() // Outputs: \"lorem ipsum\"\n\n\n// una función que hace referencia a una variable declarada fuera de su scope\nlet name = 'Lupo';\nfunction say() {\n  console.log('Hola soy ' + name);\n}\nsay(); // \"Hola soy Lupo\"\nname = 'Pedro Picapiedra';\nsay(); // \"Hola soy Pedro Picapiedra\"\n</code></pre>\n<p>En un lenguaje sin \"closures\", a la hora de invocar <code>say()</code> en este ejemplo,\ntendríamos que haber explícitamente pasado <code>name</code> como argumento. En JavaScript\nla función <code>say()</code> tiene acceso al contexto exterior, incluso si invocáramos la\nfunción desde otro lugar, o como un callback de una operación asíncrona, siempre\nva a recordar ese contexto exterior (outer scope) y puede hacer referencia a él.</p>\n<p>Pero... por qué, para qué? Veamos un ejemplo.</p>\n<pre><code class=\"language-js\">function fetchData() {\n  const reqId = 123;\n  $.get('/some-url', function () {\n    alert('Request ' + reqId + ' completed');\n  });\n}\n</code></pre>\n<p>En el código de arriba la función <code>fetchData()</code> va a hacer una llamada AJAX\n(usando jQuery), y cuando la llamada retorna (esto ocurre después de que\n<code>fetchData</code> haya retornado) el callback todavía tiene acceso a <code>reqId</code>. Esto es\nmuy útil a la hora programar operaciones asíncronas, ente otras cosas.</p>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Capítulos de libros:</p>\n<ul>\n<li><a href=\"http://eloquentjavascript.net/03_functions.html\" target=\"_blank\">Eloquent JavaScript - Chapter 3: Functions</a></li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\">MDN - Closures</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" target=\"_blank\">MDN - Function</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\">MDN - Arrow functions</a></li>\n</ul>\n",
          "order": 1,
          "durationString": "3min"
        },
        "02-factories": {
          "title": "Factories",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<p>Las <code>factories</code> o <code>factory functions</code> son simplemente funciones que crean\nobjetos. Podemos usar factories como alternativa a los constructores, siendo más\nsimples y por la tanto más fácil visualizar lo que hacen. Nada de <code>this</code>, <code>new</code>\no <code>Function.prototype</code>. En la lección anterior vimos una función <code>createNote</code>\nque creaba un objeto. Era una factory!</p>\n<pre><code class=\"language-js\">const createNote = text =&gt; ({\n  text,\n  createdAt: new Date(),\n  completed: false\n});\n</code></pre>\n<p>Esta función es muy sencilla, pero comparada al constructor <code>Note</code>, que también\nvimos en la lección pasada, le falta añadir la funcionalidad que le habíamos\nañadido a los objetos creados con <code>Note</code> a través de <code>Note.prototype</code> (habíamos\nañadido un método <code>Note.prototype.toString</code>). Para solventar esto, podríamos\nañadir el método <code>toString</code> directamente sobre la instancia que retorna nuestro\nfactory:</p>\n<pre><code class=\"language-js\">const createNote = text =&gt; ({\n  text,\n  createdAt: new Date(),\n  completed: false,\n  toString: () =&gt; {}\n});\n</code></pre>\n<p>Pero, cómo hacemos referencia a <code>createdAt</code> y <code>completed</code> desde <code>toString</code>?\nClosures al rescate!</p>\n<pre><code class=\"language-js\">const createNote = text =&gt; {\n  let createdAt = new Date();\n  let completed = false;\n\n  return {\n    text,\n    createdAt,\n    completed,\n    toString: () =&gt; '[' + (completed ? 'X' : ' ') + '] | ' +\n      createdAt.toDateString() + ' | ' + text\n  }\n};\n\nconsole.log(createNote('hahah').toString());\n// [ ] | Sat Jul 01 2017 | hahah\n</code></pre>\n<p>Esta nueva implementación hace uso de un closure para dar acceso a <code>text</code>,\n<code>createdAt</code> y <code>completed</code> a todos los métodos del objeto que crea nuestra\nfactory.</p>\n<p>Vayamos un paso más allá. Cuando usábamos constructores resultaba cómodo tener\nlas propiedades del objeto creado disponibles en <code>this</code>, de esa manera\ncompartíamos \"estado\" entre los métodos de nuestro objeto. Organicemos el\n\"estado\" de nuestra nota en un objeto, y ahora sólo expongamos métodos en el\nobjeto que retorna nuestra factory. Esto nos va a permitir esconder esta data\ny tratarla como privada. Esto es una gran ventaja con respecto a los\nconstructores, ya que nos permite decidir qué data queremos que se pueda acceder\ny cómo.</p>\n<pre><code class=\"language-js\">const createNote = text =&gt; {\n  const state = {\n    text,\n    createdAt: new Date(),\n    completed: false\n  };\n\n  return {\n    complete: bool =&gt; typeof bool !== 'undefined' ?\n      state.completed = !!bool : state.completed,\n    toString: () =&gt; '[' + (state.completed ? 'X' : ' ') + '] | ' +\n      state.createdAt.toDateString() + ' | ' + state.text\n  };\n};\n\nconst note = createNote('comprar arroz');\n\nconsole.log(note.complete()); // false\nconsole.log(note.complete(true)); // true\nconsole.log(note.complete()); // true\n\nconsole.log(note.toString());\n// [X] | Sat Jul 01 2017 | comprar arroz\n</code></pre>\n<p>En esta nueva versión el objeto retornado por <code>createNote</code> tiene los métodos\n<code>complete()</code>, que nos permite marcar la nota como completada y comprobar si está\ncompletada, y <code>toString()</code>, sin necesidad de exponer sus estado interno, lo cual\npuede ser muy útil además de resultar en <em>interfaces</em> más limpias.</p>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Videos:</p>\n<ul>\n<li>Playlist: <a href=\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub\" target=\"_blank\">Object Creation in JavaScript</a>,\n<code>aprox. 3h</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\" target=\"_blank\">funfunfunction</a>,\n2016</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\">MDN - Arrow functions</a></li>\n</ul>\n",
          "order": 2,
          "durationString": "5min"
        },
        "03-object-assign": {
          "title": "Object.assign()",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<p>Llegado a este punto, probablemente te estés preguntando cómo podemos acceder\nahora a <code>text</code> y <code>createdAt</code>. En nuestro caso, estas propiedades no necesitan\nser \"privadas\", así que vamos a \"exponerlas\". Para ello, en vez de exponerlas\ndirectamente sobre el objeto, vamos a añadir un método que nos de una \"copia\"\ndel estado, y así asegurar la immutabilidad del estado desde afuera. Vamos a\nllamar a éste nuevo método <code>toJSON</code>.</p>\n<pre><code class=\"language-js\">const createNote = text =&gt; {\n  const state = {\n    text,\n    createdAt: new Date(),\n    completed: false\n  };\n\n  return {\n    complete: bool =&gt; typeof bool !== 'undefined' ?\n      state.completed = !!bool : state.completed,\n    toString: () =&gt; '[' + (state.completed ? 'X' : ' ') + '] | ' +\n      state.createdAt.toDateString() + ' | ' + state.text,\n    toJSON: () =&gt; Object.assign({}, state)\n  };\n};\n\nconst note = createNote('comprar arroz');\nconsole.log(note.toJSON());\n</code></pre>\n<p>En la consola deberías de ver algo así:</p>\n<pre><code class=\"language-text\">{ text: 'comprar arroz',\n  createdAt: 2017-07-01T07:06:24.345Z,\n  completed: false }\n</code></pre>\n<p>En la implementación de <code>toJSON</code> hemos usado <code>Object.assign()</code>. Esto significa\nque retornamos un nuevo objeto, al cual le hemos copiado todas las propiedades\nde <code>state</code>. <code>Object.assign(destino, fuente1, fuente2, ... fuenteN)</code> se utiliza\npara copiar los valores de todas la <em>propiedades enumerables</em> de uno o más\nobjetos fuente a un objeto destino, y retorna el objeto destino. Esto nos\npermite fácilmente \"mezclar\" objetos o simplemente copiar un objeto.</p>\n<pre><code class=\"language-js\">const obj = { foo: 'bar', baz: true };\nconst objCopy = Object.assign({}, obj);\nconsole.log(objCopy); // { foo: 'bar', baz: true }\n\nobjCopy.foo = 'aaaa';\nconsole.log(objCopy); // { foo: 'aaaa', baz: true } MODIFICADO!\nconsole.log(obj); // { foo: 'bar', baz: true } NO MODIFICADO!\n\n// como comparación, en el caso de los arrays usamos `Array#slice` para esto\nconst arr = [1, 2, 3];\nconst arrCopy = arr.slice(0);\nconsole.log(arrCopy); // [1, 2, 3]\n\narrCopy.push(4);\nconsole.log(arrCopy); // [1, 2, 3, 4] MODIFICADO!\nconsole.log(arr); // [1, 2, 3] NO MODIFICADO!\n</code></pre>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\">MDN - Object.assign</a></li>\n</ul>\n",
          "order": 3,
          "durationString": "5min"
        },
        "04-composition-over-inheritance": {
          "title": "Composition over inheritance",
          "type": "read",
          "format": "self-paced",
          "duration": 10,
          "body": "<p>Por lo general, a la hora de \"diseñar\" programas tratamos de favorecer la\ncomposición con respecto a la herencia. El motivo principal es la flexibilidad\nde no estar amarrado a una jerarquía rígida de herencia, que además debe existir\ndesde el principio del desarrollo, a veces obligándonos a modelar un problema\nque todavía no conocemos.</p>\n<p>La composición se concentra en la \"funcionalidad\", los métodos que implementa\nun objeto, y para ello en vez de heredar, simplemente \"tenemos\" otros objetos\na partir de los cuales vamos a componer una nueva interfaz.</p>\n<p>En programación funcional tratamos de evitar el estado compartido, y para ello\nnormalmente vamos a enviar todo lo que necesitemos explícitamente como\nargumentos.</p>\n<p>Ahora que hemos abstraido el estado a un objeto y ya conocemos\n<code>Object.assign()</code>, podemos descomponer nuestra implementación de <code>createNote</code> en\ndiferentes funciones puras, cada una responsable de una parte de la\nfuncionalidad, y así poder componer nuestro objeto a partir de varios objetos.</p>\n<pre><code class=\"language-js\">const serializer = state =&gt; ({\n  toString: _ =&gt; '[' + (state.completed ? 'X' : ' ') + '] | ' +\n    state.createdAt.toDateString() + ' | ' + state.text,\n  toJSON: _ =&gt; Object.assign({}, state)\n});\n\nconst completer = state =&gt; ({\n  complete: bool =&gt; typeof bool !== 'undefined' ?\n    state.completed = !!bool : state.completed\n});\n\nconst createNote = text =&gt; {\n  const state = {\n    text,\n    createdAt: new Date(),\n    completed: false\n  };\n  return Object.assign({}, completer(state), serializer(state));\n};\n\nconst note = createNote('comprar arroz');\n\nconsole.log(note);\nconsole.log(note.complete()); // false\nconsole.log(note.complete(true)); // true\nconsole.log(note.complete()); // true\n\nconsole.log(note.toString());\nconsole.log(note.toJSON());\n</code></pre>\n<p>Continuando el paralelo con herencia prototipal, implementemos ahora una función\nque cree objetos que extiendan la funcionalidad de nuestras notas:</p>\n<pre><code class=\"language-js\">const createImageNote = url =&gt; {\n  const note = createNote('an image');\n  return Object.assign({}, note, {\n    toString: () =&gt; note.toString() + ' | ' + url,\n    toJSON: () =&gt; Object.assign(note.toJSON(), { url: url })\n  });\n};\n\n\nconst imageNote = createImageNote('http://foo.com/bar.png');\n\nconsole.log(imageNote.complete()); // false\nconsole.log(imageNote.complete(true)); // true\nconsole.log(imageNote.complete()); // true\n\nconsole.log(imageNote.toString());\nconsole.log(imageNote.toJSON());\n</code></pre>\n<p>La función <code>createImageNote</code> simplemente usa un objeto creado con <code>createNote</code>\ninternamente (<code>note</code>) y de ahí reemplaza los métodos <code>toString</code> y <code>toJSON</code>, los\ncuales a su vez hacen uso de los métodos de <code>note</code>.</p>\n<p>Nótese que podríamos usar muchos otros objetos con los componer la interfaz de\nlos objetos creados con <code>createImageNote</code>. No estamos limitados a heredar de\nun sólo objeto (o jerarquía de objetos).</p>\n<p>Como conclusión, la mayor diferencia entre composición y herencia es que cuando\npensamos en herencia nos concentramos en \"qué\" es un objeto, a qué familia\npertenece, mientreas que cuando usamos composición nos centramos en qué\nfuncionalidad implementa. En herencia pensamos en \"qué es un objeto\" (es un X),\nmientras que en composición pensamos en \"lo que tiene\", independientemente de\ncadenas de herencia. De esta forma, usando composición tenemos mucho más\nflexibilidad a la hora de \"componer\" objetos, ya que no estamos amarrados a una\njerarquía de herencia que quizás nos obligue a heredar funcionalidad que no\nnecesitamos además de no permitirnos heredar de jerarquías separadas.</p>\n<hr>\n<h2 id=\"referencias\">Referencias</h2>\n<p>Videos:</p>\n<ul>\n<li>Playlist: <a href=\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub\" target=\"_blank\">Object Creation in JavaScript</a>,\n<code>aprox. 3h</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\" target=\"_blank\">funfunfunction</a>,\n2016</li>\n</ul>\n",
          "order": 4,
          "durationString": "10min"
        },
        "05-exercises": {
          "title": "Ejercicios",
          "type": "practice",
          "format": "self-paced",
          "duration": 90,
          "exercises": {
            "01-hof": {
              "title": "Higher Order Functions",
              "env": "js",
              "body": "<p>Una función de orden superior (higher-order function) es una función que cumple\npor lo menos una de estas condiciones:</p>\n<ul>\n<li>Recibe una o más funciones como input</li>\n<li>Devuelve una función</li>\n</ul>\n<p>Todas las demás funciones son de primer orden (first order functions). [1]</p>\n<p>A diferencia de muchos otros lenguajes con características imperativas,\nJavaScript nos permite usar higher-order functions ya que tiene funciones\n\"first-class\". Lo que significa que las funciones pueden ser tratadas como\ncualquier otro valor en JavaScript: igual que Strings o Numbers, valores de tipo\nFunction pueden ser almacenados en variables, propiedades de objetos o pasados\na otras funciones como argumentos. Los valores de tipo Function de hecho son\nObjects (que heredan de <code>Function.prototype</code>), así que podemos incluso añadir\npropiedades y asignar valores igual que en cualquir otro objeto.</p>\n<p>La principal diferencia entre las funciones y el resto de valores en JavaScript\nes la sintáxis de invocación. Si una referencia a una función está seguida de\nparéntesis y opcionalmente una lista de argumentos separados por comas:\n<code>someFunctionValue(arg1, arg2, etc)</code>, entonces el cuerpo de la función será\nejecutada con los argumentos pasados (si hubiere).</p>\n<p>En este ejercicio vamos a demostrar que las funciones pueden ser pasadas como\nvalores. Te vamos a pasar una función como argumento.</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa una función que reciba una función como primer argumento, y un número\n<code>num</code> como segundo argumento. La función debe ejecutar la función <code>num</code> veces.</p>\n<p>Usa el boilerplate provisto para empezar. Todos (o casi todos) los ejercicios\nincluirán un boilerplate.</p>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li><code>operation</code>: Una función, no recibe argumentos, no retorna ningún valor útil.</li>\n<li><code>num</code>: el número de veces que queremos invocar <code>operation</code></li>\n</ul>\n<h2 id=\"pistas\">Pistas</h2>\n<ul>\n<li>No lo des demasiadas vueltas, el código debe ser muy simple.</li>\n<li>No pasa nada si usas un loop. Bonus para quien implemente usando recursión.</li>\n<li>No te despistes si ves output. Esto viene de la función que te estamos pasando.</li>\n<li>No tienes que usar console.log para nada.</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions_and_function_scope\" target=\"_blank\">Funciones y alcance de la función - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\" target=\"_blank\">Function.prototype - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Higher Order Functions\n\n* Environment: `js`\n\n***\nUna función de orden superior (higher-order function) es una función que cumple\npor lo menos una de estas condiciones:\n\n* Recibe una o más funciones como input\n* Devuelve una función\n\nTodas las demás funciones son de primer orden (first order functions). [1]\n\nA diferencia de muchos otros lenguajes con características imperativas,\nJavaScript nos permite usar higher-order functions ya que tiene funciones\n\"first-class\". Lo que significa que las funciones pueden ser tratadas como\ncualquier otro valor en JavaScript: igual que Strings o Numbers, valores de tipo\nFunction pueden ser almacenados en variables, propiedades de objetos o pasados\na otras funciones como argumentos. Los valores de tipo Function de hecho son\nObjects (que heredan de `Function.prototype`), así que podemos incluso añadir\npropiedades y asignar valores igual que en cualquir otro objeto.\n\nLa principal diferencia entre las funciones y el resto de valores en JavaScript\nes la sintáxis de invocación. Si una referencia a una función está seguida de\nparéntesis y opcionalmente una lista de argumentos separados por comas:\n`someFunctionValue(arg1, arg2, etc)`, entonces el cuerpo de la función será\nejecutada con los argumentos pasados (si hubiere).\n\nEn este ejercicio vamos a demostrar que las funciones pueden ser pasadas como\nvalores. Te vamos a pasar una función como argumento.\n\n## Tarea\n\nImplementa una función que reciba una función como primer argumento, y un número\n`num` como segundo argumento. La función debe ejecutar la función `num` veces.\n\nUsa el boilerplate provisto para empezar. Todos (o casi todos) los ejercicios\nincluirán un boilerplate.\n\n## Argumentos\n\n* `operation`: Una función, no recibe argumentos, no retorna ningún valor útil.\n* `num`: el número de veces que queremos invocar `operation`\n\n## Pistas\n\n* No lo des demasiadas vueltas, el código debe ser muy simple.\n* No pasa nada si usas un loop. Bonus para quien implemente usando recursión.\n* No te despistes si ves output. Esto viene de la función que te estamos pasando.\n* No tienes que usar console.log para nada.\n\n## Recursos\n\n* [Funciones y alcance de la función - MDN](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions_and_function_scope)\n* [Function.prototype - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype)\n",
                "Ym9pbGVycGxhdGU=": {
                  "aG9mLmpz": "//\n// TAREA\n//\n// Implementa una función que reciba una función como primer argumento\n// `operation`, y un número `num` como segundo argumento. La función debe\n// ejecutar la función `num` veces.\n//\n\nmodule.exports = function repeat(operation, num) {\n  //Escribe aquí tu código.\n\n};\n"
                },
                "c29sdXRpb24=": {
                  "aG9mLmpz": "module.exports = function repeat(operation, num) {\n  if (num <= 0) {\n    return;\n  }\n  operation();\n  return repeat(operation, num - 1);\n};\n"
                },
                "dGVzdA==": {
                  "aG9mLnNwZWMuanM=": "'use strict';\n\n\nconst Assert =  require('chai').assert;\nconst Submission = require('../solution/hof');\n\n\ndescribe('repeat', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería invocar la operación num veces', () => {\n    let count = 0;\n    Submission(_ => count++, 3);\n    Assert.equal(count, 3);\n  });\n\n});\n"
                }
              }
            },
            "02-map": {
              "title": "Map",
              "env": "js",
              "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Refactorizar el siguiente código reemplazando el bucle <code>for</code> con <code>Array#map</code>:</p>\n<pre><code class=\"language-js\">const doubleAll =&gt; (numbers) =&gt; {\n  const result = [];\n\n  for (let i = 0; i &lt; numbers.length; i++) {\n    result.push(numbers[i] * 2);\n  }\n\n  return result;\n};\n</code></pre>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li>numbers: Un Array de 0 a 20 números enteros entre 0 y 9</li>\n</ul>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Tu solución debe usar <code>Array.prototype.map()</code>.</li>\n<li>No uses ningún bucle <code>for/while</code> o <code>Array.prototype.forEach</code>.</li>\n<li>No crees ninguna función extra (helpers, ...).</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\">Array.map - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Map\n\n* Environment: `js`\n\n***\n\n## Tarea\n\nRefactorizar el siguiente código reemplazando el bucle `for` con `Array#map`:\n\n```js\nconst doubleAll => (numbers) => {\n  const result = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 2);\n  }\n\n  return result;\n};\n```\n\n## Argumentos\n\n* numbers: Un Array de 0 a 20 números enteros entre 0 y 9\n\n## Requisitos\n\n* Tu solución debe usar `Array.prototype.map()`.\n* No uses ningún bucle `for/while` o `Array.prototype.forEach`.\n* No crees ninguna función extra (helpers, ...).\n\n## Recursos\n\n* [Array.map - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n",
                "Ym9pbGVycGxhdGU=": {
                  "bWFwLmpz": "//\n// TAREA\n//\n// Refactorizar la siguiente función reemplazando el bucle `for` con\n// `Array#map`.\n//\n\nmodule.exports = function doubleAll(numbers) {\n  const result = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * 2);\n  }\n\n  return result;\n};\n"
                },
                "c29sdXRpb24=": {
                  "bWFwLmpz": "module.exports = numbers => numbers.map(num => num * 2);\n"
                },
                "dGVzdA==": {
                  "bWFwLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/map');\n\n\ndescribe('doubleAll()', () => {\n\n  it('debería retornar array con números multiplicados por 2', () => {\n    Assert.deepEqual(Submission([1, 2, 3]), [2, 4, 6]);\n  });\n\n  it('NO debería modificar array de entrada', () => {\n    const input = [1, 2, 3];\n    Assert.deepEqual(Submission(input), [2, 4, 6]);\n    Assert.deepEqual(input, [1, 2, 3]);\n  });\n\n  it('NO debería usar for o while', () => {\n    Assert.equal(/(for|while)\\s+\\(/g.test(Submission.toString()), false);\n  });\n\n  it('debería invocar Array.prototype.map', () => {\n    const map = Array.prototype.map;\n    let mapCount = 0;\n    let operationCount = 0;\n\n    Array.prototype.map = function (fn) {\n      mapCount++;\n      return map.call(this, function () {\n        operationCount++;\n        return fn.apply(null, Array.prototype.slice.call(arguments));\n      });\n    };\n\n    Assert.deepEqual(Submission([1, 2, 3]), [2, 4, 6]);\n    Assert.equal(mapCount, 1);\n    Assert.equal(operationCount, 3);\n\n    Array.prototype.map = map;\n  });\n\n});\n"
                }
              }
            },
            "03-filter": {
              "title": "Filter",
              "env": "js",
              "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Usa <code>Array#filter</code> para implementar una función llamada <code>getShortMessages</code>.</p>\n<p>La función <code>getShortMessages</code> recibe un array de objetos con una propiedad\n<code>message</code> y retorna un array con los mensajes que tengan <em>menos de &lt; 50\ncaracteres</em>.</p>\n<p>La función debe retornar un array con los mensajes (strings), <em>no objetos</em>.</p>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li><code>messages</code>: un <code>Array</code> de 10 a 100 objetos con este formato:</li>\n</ul>\n<pre><code class=\"language-js\">{\n  message: 'Esse id amet quis eu esse aute officia ipsum.' // random\n}\n</code></pre>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>No uses ningún bucle <code>for/while</code> o <code>Array.prototype.forEach</code>.</li>\n<li>No crees ninguna función extra (helpers, ...).</li>\n</ul>\n<h2 id=\"pistas\">Pistas</h2>\n<ul>\n<li>Prueba a \"encadenar\" métodos de <code>Array</code>!</li>\n</ul>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<p>La función debe retornar algo parecido a:</p>\n<pre><code class=\"language-js\">[ 'Tempor quis esse consequat sunt ea eiusmod.',\n  'Id culpa ad proident ad nulla laborum incididunt.',\n  'Ullamco in ea et ad anim anim ullamco est.',\n  'Est ut irure irure nisi.' ]\n</code></pre>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\" target=\"_blank\">Array.filter - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\">Array.map - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Filter\n\n* Environment: `js`\n\n***\n\n## Tarea\n\nUsa `Array#filter` para implementar una función llamada `getShortMessages`.\n\nLa función `getShortMessages` recibe un array de objetos con una propiedad\n`message` y retorna un array con los mensajes que tengan *menos de < 50\ncaracteres*.\n\nLa función debe retornar un array con los mensajes (strings), *no objetos*.\n\n## Argumentos\n\n* `messages`: un `Array` de 10 a 100 objetos con este formato:\n\n```js\n{\n  message: 'Esse id amet quis eu esse aute officia ipsum.' // random\n}\n```\n\n## Requisitos\n\n* No uses ningún bucle `for/while` o `Array.prototype.forEach`.\n* No crees ninguna función extra (helpers, ...).\n\n## Pistas\n\n* Prueba a \"encadenar\" métodos de `Array`!\n\n## Ejemplo\n\nLa función debe retornar algo parecido a:\n\n```js\n[ 'Tempor quis esse consequat sunt ea eiusmod.',\n  'Id culpa ad proident ad nulla laborum incididunt.',\n  'Ullamco in ea et ad anim anim ullamco est.',\n  'Est ut irure irure nisi.' ]\n```\n\n## Recursos\n\n* [Array.filter - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n* [Array.map - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n",
                "Ym9pbGVycGxhdGU=": {
                  "ZmlsdGVyLmpz": "//\n// TAREA\n//\n// La función `getShortMessages` recibe un array de objetos con una propiedad\n// `message` y retorna un array con los mensajes que tengan menos de < 50\n// caracteres.\n//\n\nmodule.exports = function getShortMessages(messages) {\n  // Escribe aquí tu código.\n\n};\n"
                },
                "c29sdXRpb24=": {
                  "ZmlsdGVyLmpz": "module.exports = messages =>\n  messages\n    .filter(item => item.message.length < 50)\n    .map(item => item.message);\n"
                },
                "dGVzdA==": {
                  "ZmlsdGVyLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/filter');\n\n\nconst message = () => {\n  return Assert.deepEqual(Submission([{\n      message: 'Tempor quis esse consequat sunt ea eiusmod.'\n    }, {\n      message: 'Id culpgetShortMessages.speca ad proident ad nulla laborum incididunt. Blah blah'\n    }, {\n      message: 'Ullamco in ea et ad anim anim ullamco est.'\n    }, {\n      message: 'Est ut irure irure nisi.'\n    }]), [\n      'Tempor quis esse consequat sunt ea eiusmod.',\n      'Ullamco in ea et ad anim anim ullamco est.',\n      'Est ut irure irure nisi.'\n    ]);\n};\n\n\ndescribe('getShortMessages()', () => {\n\n  it('debería retornar [ ] cuando input array es [ ]', ( )  => {\n    Assert.deepEqual(Submission([]), []);\n  });\n\n  it('debería retornar arreglo de strings con mensajes de menos de 50 chars', () => {\n    message();\n  });\n\n  it('NO debería usar for o while', () => {\n    Assert.equal(/(for|while)\\s+\\(/g.test(Submission.toString()), false);\n  });\n\n  it('debería invocar Array.prototype.filter' , () => {\n    const filter = Array.prototype.filter;\n    let filterCount = 0;\n\n    Array.prototype.filter = function (fn) {\n      filterCount++;\n      return filter.call(this, function () {\n        return fn.apply(null, Array.prototype.slice.call(arguments));\n      });\n    };\n\n    message();\n    Assert.equal(filterCount, 1);\n\n    Array.prototype.filter = filter;\n  });\n\n  it('debería invocar Array.prototype.map', () => {\n    const map = Array.prototype.map;\n    let mapCount = 0;\n\n    Array.prototype.map = function (fn) {\n      mapCount++;\n      return map.call(this, function () {\n        return fn.apply(null, Array.prototype.slice.call(arguments));\n      });\n    };\n    message();\n    Assert.equal(mapCount, 1);\n    Array.prototype.map = map;\n  });\n\n});\n"
                }
              }
            },
            "04-reduce": {
              "title": "Reduce",
              "env": "js",
              "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Dado un <code>Array</code> de strings, usa <code>Array#reduce</code> para crear un objeto que contenga\nel número de veces que aparece cada string en el array. Retorna el object\ndirectamente (no hay necesidad de hacer <code>console.log</code>).</p>\n<h2 id=\"ejemplo\">Ejemplo</h2>\n<pre><code class=\"language-js\">const inputWords = ['Apple', 'Banana', 'Apple', 'Durian', 'Durian', 'Durian']\n\nconsole.log(countWords(inputWords))\n\n// =&gt; { Apple: 2, Banana: 1, Durian: 3 }\n</code></pre>\n<h2 id=\"argumentos\">Argumentos</h2>\n<ul>\n<li><code>inputWords</code>: Un array de Strings.</li>\n</ul>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>No uses ningún bucle <code>for/while</code> o <code>Array.prototype.forEach</code>.</li>\n<li>No crees ninguna función extra (helpers, ...).</li>\n</ul>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Reduce_(higher-order_function)\" target=\"_blank\">Reduce - Wikipedia</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\" target=\"_blank\">Array.reduce - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Reduce\n\n* Environment: `js`\n\n***\n\n## Tarea\n\nDado un `Array` de strings, usa `Array#reduce` para crear un objeto que contenga\nel número de veces que aparece cada string en el array. Retorna el object\ndirectamente (no hay necesidad de hacer `console.log`).\n\n## Ejemplo\n\n```js\nconst inputWords = ['Apple', 'Banana', 'Apple', 'Durian', 'Durian', 'Durian']\n\nconsole.log(countWords(inputWords))\n\n// => { Apple: 2, Banana: 1, Durian: 3 }\n```\n\n## Argumentos\n\n* `inputWords`: Un array de Strings.\n\n## Requisitos\n\n* No uses ningún bucle `for/while` o `Array.prototype.forEach`.\n* No crees ninguna función extra (helpers, ...).\n\n## Recursos\n\n* [Reduce - Wikipedia](https://en.wikipedia.org/wiki/Reduce_(higher-order_function))\n* [Array.reduce - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n",
                "Ym9pbGVycGxhdGU=": {
                  "cmVkdWNlLmpz": "//\n// TAREA\n//\n// Dado un `Array` de strings, usa `Array#reduce` para crear un objeto\n// que contenga el número de veces que aparece cada string en el array.\n// Retorna el object directamente (no hay necesidad de hacer `console.log`).\n//\n\nmodule.exports = (arr) => {\n  // ...\n};\n"
                },
                "c29sdXRpb24=": {
                  "cmVkdWNlLmpz": "module.exports = (arr) => arr.reduce((countMap, word) => {\n  countMap[word] = ++countMap[word] || 1;\n  return countMap;\n}, {});\n"
                },
                "dGVzdA==": {
                  "cmVkdWNlLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/reduce');\n\n\ndescribe('countWords()', () => {\n\n  it('debería retornar un objeto que contenga el número de veces que aparece cada string en el array', () => {\n    const input = ['Apple', 'Banana', 'Apple', 'Durian', 'Durian', 'Durian'];\n    Assert.deepEqual(Submission(input), { Apple: 2, Banana: 1, Durian: 3 });\n  });\n\n  it('NO debería usar for o while', () => {\n    Assert.equal(/(for|while)\\s+\\(/g.test(Submission.toString()), false);\n  });\n\n  it('debería invocar Array.prototype.reduce', () => {\n    const reduce = Array.prototype.reduce;\n    let reduceCount = 0;\n\n    Array.prototype.reduce = function (fn, initial) {\n      reduceCount++;\n      return reduce.call(this, function () {\n        return fn.apply(null, Array.prototype.slice.call(arguments));\n      }, initial);\n    };\n\n    Assert.deepEqual(Submission(['foo', 'foo']), { foo: 2 });\n    Assert.equal(reduceCount, 1);\n\n    Array.prototype.reduce = reduce;\n  });\n\n});\n"
                }
              }
            },
            "05-arrow-functions": {
              "title": "Arrow Functions",
              "env": "js",
              "body": "<p>Una <em>función flecha</em> (arrow function) es una expresión con una sintáxis más\ncorta comparada con la expresión de función convencional (<code>function</code>) y se\ndiferencia de ésta en los siguiente:</p>\n<ul>\n<li>no vincula su propio <code>this</code>, <code>arguments</code>, <code>super</code>, o <code>new.target</code></li>\n<li>siempre son anónimas</li>\n<li>no pueden ser usadas como constructores</li>\n</ul>\n<p>Por todo esto, las funciones flecha se prestan para funciones que no sean\n<em>métodos</em> (miembros de un objeto).</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa las funciones implementadas en los ejercicios anteriores (<code>repeat</code>,\n<code>doubleAll</code>, <code>getShortMessages</code> y <code>countWords</code>), pero esta vez usando funciones\nflecha, y haciendo uso de retorno implícito cuando sea posible.</p>\n<h2 id=\"requisitos\">Requisitos</h2>\n<p>Los mismos que en los ejercicios anteriores, pero esta vez debes usar funciones\nflecha.</p>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\">Arrow_functions - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Arrow Functions\n\n* Environment: `js`\n\n***\nUna _función flecha_ (arrow function) es una expresión con una sintáxis más\ncorta comparada con la expresión de función convencional (`function`) y se\ndiferencia de ésta en los siguiente:\n\n* no vincula su propio `this`, `arguments`, `super`, o `new.target`\n* siempre son anónimas\n* no pueden ser usadas como constructores\n\nPor todo esto, las funciones flecha se prestan para funciones que no sean\n_métodos_ (miembros de un objeto).\n\n## Tarea\n\nImplementa las funciones implementadas en los ejercicios anteriores (`repeat`,\n`doubleAll`, `getShortMessages` y `countWords`), pero esta vez usando funciones\nflecha, y haciendo uso de retorno implícito cuando sea posible.\n\n## Requisitos\n\nLos mismos que en los ejercicios anteriores, pero esta vez debes usar funciones\nflecha.\n\n## Recursos\n\n* [Arrow_functions - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n",
                "Ym9pbGVycGxhdGU=": {
                  "YXJyb3dGdW5jdGlvbnMuanM=": "exports.repeat = (operation, num) => {\n  // Escribe tu código aquí.\n\n};\n\nexports.doubleAll = (numbers) => {\n  // Escribe tu código aquí.\n\n};\n\nexports.getShortMessages = (messages) => {\n  //Escribe tu código aquí.\n\n};\n\nexports.countWords = (arr) => {\n  //Escribe tu código aquí.\n\n};\n\n//\n// TAREA\n//\n// Implementa las funciones implementadas en los ejercicios anteriores\n// (`repeat`,`doubleAll`, `getShortMessages` y `countWords`), pero esta vez\n// usando funciones flecha, y haciendo uso de retorno implícito cuando sea\n// posible.\n"
                },
                "c29sdXRpb24=": {
                  "YXJyb3dGdW5jdGlvbnMuanM=": "exports.repeat = (operation, num) => {\n  if (num <= 0) {\n    return;\n  }\n  operation();\n  return exports.repeat(operation, --num);\n};\n\nexports.doubleAll = numbers => numbers.map(num => num * 2);\n\nexports.getShortMessages = messages => messages\n  .filter(item => item.message.length < 50)\n  .map(item => item.message);\n\nexports.countWords = arr => arr.reduce((countMap, word) => {\n  countMap[word] = ++countMap[word] || 1;\n  return countMap;\n}, {});\n"
                },
                "dGVzdA==": {
                  "YXJyb3dGdW5jdGlvbnMuc3BlYy5qcw==": "'use strict';\n\nconst Assert = require('chai').assert;\nconst { getShortMessages, repeat, doubleAll, countWords } = require('../solution/arrowFunctions');\n\nconst message = (_ => {\n  return Assert.deepEqual(getShortMessages([{\n      message: 'Tempor quis esse consequat sunt ea eiusmod.'\n    }, {\n      message: 'Id culpgetShortMessages.speca ad proident ad nulla laborum incididunt. Blah blah'\n    }, {\n      message: 'Ullamco in ea et ad anim anim ullamco est.'\n    }, {\n      message: 'Est ut irure irure nisi.'\n    }]), [\n      'Tempor quis esse consequat sunt ea eiusmod.',\n      'Ullamco in ea et ad anim anim ullamco est.',\n      'Est ut irure irure nisi.'\n    ]);\n});\n\ndescribe('Arrow functions', () => {\n\n  describe('getShortMessages()', () => {\n\n    it('debería retornar [] cuando input array es []', () => {\n      Assert.deepEqual(getShortMessages([]), []);\n    });\n\n    it('debería retornar arreglo de strings con mensajes de menos de 50 chars', () => {\n      message();\n    });\n\n    it('NO debería usar for o while', () => {\n      Assert.equal(/(for|while)\\s+\\(/g.test(getShortMessages.toString()), false);\n    });\n\n    it('debería invocar Array.prototype.filter', () => {\n      const filter = Array.prototype.filter;\n      let filterCount = 0;\n\n      Array.prototype.filter = function (fn) {\n        filterCount++;\n        return filter.call(this, function () {\n          return fn.apply(null, Array.prototype.slice.call(arguments));\n        });\n      };\n\n      message();\n      Assert.equal(filterCount, 1);\n\n      Array.prototype.filter = filter;\n    });\n\n    it('debería invocar Array.prototype.map', () => {\n      const map = Array.prototype.map;\n      let mapCount = 0;\n\n      Array.prototype.map = function (fn) {\n        mapCount++;\n        return map.call(this, function () {\n          return fn.apply(null, Array.prototype.slice.call(arguments));\n        });\n      };\n\n      message();\n\n      Assert.equal(mapCount, 1);\n\n      Array.prototype.map = map;\n    });\n\n  });\n\n  describe('repeat', () => {\n\n    it('debería exportar una función', () => {\n      Assert.equal(typeof repeat, 'function');\n    });\n\n    it('debería invocar la operación num veces', () => {\n      let count = 0;\n      repeat( _ => count++, 3);\n      Assert.equal(count, 3);\n    });\n\n  });\n\n  describe('doubleAll()', () => {\n\n    it('debería retornar array con números multiplicados por 2', () => {\n      Assert.deepEqual(doubleAll([1, 2, 3]), [2, 4, 6]);\n    });\n\n    it('NO debería modificar array de entrada', () => {\n      const input = [1, 2, 3];\n      Assert.deepEqual(doubleAll(input), [2, 4, 6]);\n      Assert.deepEqual(input, [1, 2, 3]);\n    });\n\n    it('NO debería usar for o while', () => {\n      Assert.equal(/(for|while)\\s+\\(/g.test(doubleAll.toString()), false);\n    });\n\n    it('debería invocar Array.prototype.map', () => {\n      const map = Array.prototype.map;\n      let mapCount = 0;\n      let operationCount = 0;\n\n      Array.prototype.map = function (fn) {\n        mapCount++;\n        return map.call(this, function () {\n          operationCount++;\n          return fn.apply(null, Array.prototype.slice.call(arguments));\n        });\n      };\n\n      Assert.deepEqual(doubleAll([1, 2, 3]), [2, 4, 6]);\n      Assert.equal(mapCount, 1);\n      Assert.equal(operationCount, 3);\n\n      Array.prototype.map = map;\n    });\n\n  });\n\n  describe('countWords()', () => {\n\n    it('debería retornar un objeto que contenga el número de veces que aparece cada string en el array', () => {\n      const input = ['Apple', 'Banana', 'Apple', 'Durian', 'Durian', 'Durian'];\n      Assert.deepEqual(countWords(input), { Apple: 2, Banana: 1, Durian: 3 });\n    });\n\n    it('NO debería usar for o while', () => {\n      Assert.equal(/(for|while)\\s+\\(/g.test(countWords.toString()), false);\n    });\n\n    it('debería invocar Array.prototype.reduce', () => {\n      const reduce = Array.prototype.reduce;\n      let reduceCount = 0;\n\n      Array.prototype.reduce = function (fn, initial) {\n        reduceCount++;\n        return reduce.call(this, function () {\n          return fn.apply(null, Array.prototype.slice.call(arguments));\n        }, initial);\n      };\n\n      Assert.deepEqual(countWords(['foo', 'foo']), { foo: 2 });\n      Assert.equal(reduceCount, 1);\n\n      Array.prototype.reduce = reduce;\n    });\n\n  });\n\n});\n"
                }
              }
            },
            "06-closures": {
              "title": "Closures",
              "env": "js",
              "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa una función llamada <code>createLogger</code>. Esta función debe recibir un\nargumento (<code>namespace</code>) de tipo string, y debe retornar una función anónima que\na su vez reciba un string (<code>str</code>) e imprima a la consola el string recibido,\nprecedido de <code>[namespace]:</code>.</p>\n<p>Por ejemplo:</p>\n<pre><code class=\"language-js\">const warn = createLogger('warning');\nwarn('houston, we have a problem');\n</code></pre>\n<p>Debe producir el siguiente output en la consola:</p>\n<pre><code class=\"language-text\">[warning]: houston, we have a problem\n</code></pre>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\">Closures - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Closures\n\n* Environment: `js`\n\n***\n\n## Tarea\n\nImplementa una función llamada `createLogger`. Esta función debe recibir un\nargumento (`namespace`) de tipo string, y debe retornar una función anónima que\na su vez reciba un string (`str`) e imprima a la consola el string recibido,\nprecedido de `[namespace]:`.\n\nPor ejemplo:\n\n```js\nconst warn = createLogger('warning');\nwarn('houston, we have a problem');\n```\n\nDebe producir el siguiente output en la consola:\n\n```text\n[warning]: houston, we have a problem\n```\n\n## Recursos\n\n* [Closures - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)\n",
                "Ym9pbGVycGxhdGU=": {
                  "Y2xvc3VyZXMuanM=": "const createLogger = function (namespace) {\n  //Escribe aquí tu código\n\n};\n\nmodule.exports = createLogger;\n"
                },
                "c29sdXRpb24=": {
                  "Y2xvc3VyZXMuanM=": "const createLogger = namespace => str => console.log(`[${namespace}]: ${str}`);\n\nmodule.exports = createLogger;\n"
                },
                "dGVzdA==": {
                  "Y2xvc3VyZXMuc3BlYy5qcw==": "'use strict';\n\n\nconst Assert =  require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/closures');\n\n\ndescribe('createLogger()', () => {\n\n  it('debería de ser una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería de retornar una función', () => {\n    Assert.equal(typeof Submission(), 'function');\n  });\n\n  it('debería de retornar una función que imprime a la consola con el namespace', () => {\n    const stub = Sinon.stub(console, 'log');\n    const warn = Submission('warning');\n    warn('houston, we have a problem');\n\n    Assert.equal(stub.callCount, 1);\n    Assert.equal(stub.getCall(0).args[0], '[warning]: houston, we have a problem');\n\n    stub.restore();\n  });\n\n});\n"
                }
              }
            },
            "07-factories": {
              "title": "Object factories",
              "env": "js",
              "body": "<p>Las factories o factory functions son simplemente functiones que crean objetos.\nPodemos usar factories como alternativa a los constructores, siendo más simples\ny por la tanto más fácil visualizar lo que hacen.</p>\n<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa una función que se llame <code>createStore</code>. Esta función no recibe ningún\nargumento y retorna un objeto con los siguientes métodos:</p>\n<ul>\n<li><code>get(key)</code>: retorna el valor guardado en la \"llave\" (<code>key</code>).</li>\n<li><code>set(key, value)</code>: guarda el valor (<code>value</code>) en la \"llave\" (<code>key</code>) del store y\n  retorna el valor guardado.</li>\n<li><code>keys()</code>: retorna un array con las llaves que tiene el store.</li>\n<li><code>clear()</code>: borra todas las llaves/valores del store.</li>\n</ul>\n<p>Ejemplo:</p>\n<pre><code class=\"language-js\">const store = createStore();\nconsole.log(store.keys()); // =&gt; []\nconsole.log(store.get('foo')); // =&gt; undefined\nconsole.log(store.set('foo', 'lalala')); // =&gt; lalala\nconsole.log(store.get('foo')); // =&gt; lalala\nconsole.log(store.keys()); // =&gt; ['foo']\nconsole.log(store.clear()); // =&gt; {}\nconsole.log(store.keys()); // =&gt; []\nconsole.log(store.get('foo')); // =&gt; undefined\n</code></pre>\n<h2 id=\"pistas\">Pistas</h2>\n<p>Puedes usar <code>Object.keys()</code> para obtener un arreglo con las propiedades de un\nobjeto.</p>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Object factories\n\n* Environment: `js`\n\n***\nLas factories o factory functions son simplemente functiones que crean objetos.\nPodemos usar factories como alternativa a los constructores, siendo más simples\ny por la tanto más fácil visualizar lo que hacen.\n\n## Tarea\n\nImplementa una función que se llame `createStore`. Esta función no recibe ningún\nargumento y retorna un objeto con los siguientes métodos:\n\n* `get(key)`: retorna el valor guardado en la \"llave\" (`key`).\n* `set(key, value)`: guarda el valor (`value`) en la \"llave\" (`key`) del store y\n    retorna el valor guardado.\n* `keys()`: retorna un array con las llaves que tiene el store.\n* `clear()`: borra todas las llaves/valores del store.\n\nEjemplo:\n\n```js\nconst store = createStore();\nconsole.log(store.keys()); // => []\nconsole.log(store.get('foo')); // => undefined\nconsole.log(store.set('foo', 'lalala')); // => lalala\nconsole.log(store.get('foo')); // => lalala\nconsole.log(store.keys()); // => ['foo']\nconsole.log(store.clear()); // => {}\nconsole.log(store.keys()); // => []\nconsole.log(store.get('foo')); // => undefined\n```\n\n## Pistas\n\nPuedes usar `Object.keys()` para obtener un arreglo con las propiedades de un\nobjeto.\n",
                "Ym9pbGVycGxhdGU=": {
                  "ZmFjdG9yaWVzLmpz": "module.exports = function createStore() {\n  // TAREA\n  // Implementa una función que se llame `createStore`. Esta función no recibe\n  // ningún argumento y retorna un objeto con los siguientes métodos:\n  // `get(key)`, `set(key, value)` ,`keys()` y `clear()`.\n  let data = {};\n  return {\n    // Escribe aquí  tu código.\n  };\n};\n"
                },
                "c29sdXRpb24=": {
                  "ZmFjdG9yaWVzLmpz": "module.exports = function createStore() {\n\n  let data = {};\n\n  return {\n    get  : (key) => data[key],\n    set  : (key, value) => data[key] = value,\n    keys : () => Object.keys(data),\n    clear: () => data = {}\n  };\n};\n"
                },
                "dGVzdA==": {
                  "ZmFjdG9yaWVzLnNwZWMuanM=": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/factories');\nconst store = Submission();\n\n\ndescribe('Factories', () => {\n\n  describe('createStore()', () => {\n\n    it('debería exportar una función', () => {\n      Assert.equal(typeof Submission, 'function');\n    });\n\n    it('debería retornar un objeto con método get', () => {\n      Assert.equal(typeof store.get, 'function');\n    });\n\n    it('debería retornar un objeto con método set', () => {\n      Assert.equal(typeof store.set, 'function');\n    });\n\n    it('debería retornar un objeto con método keys', () => {\n      Assert.equal(typeof store.keys, 'function');\n    });\n\n    it('debería retornar un objeto con método clear', () => {\n      Assert.equal(typeof store.clear, 'function');\n    });\n\n  });\n\n  describe('store.get() / store.set()', () => {\n\n    it('deberían retornar el valor guardado en la llave específicada', () => {\n      const store = Submission();\n      Assert.equal(store.get('foo'), undefined);\n      Assert.equal(store.set('foo', true), true);\n      Assert.equal(store.get('foo'), true);\n      Assert.equal(store.set('foo', 'lalala'), 'lalala');\n      Assert.equal(store.get('foo'), 'lalala');\n    });\n\n  });\n\n  describe('store.keys()', () => {\n\n    it('debería retornar un arreglo con las llaves del store', () => {\n      const store = Submission();\n      Assert.deepEqual(store.keys(), []);\n      Assert.equal(store.set('foo', true), true);\n      Assert.deepEqual(store.keys(), ['foo']);\n      Assert.equal(store.set('bar', 'lalala'), 'lalala');\n      Assert.deepEqual(store.keys(), ['foo', 'bar']);\n    });\n\n  });\n\n  describe('store.clear()', () => {\n\n    it('debería vaciar el store', () => {\n      Assert.deepEqual(store.keys(), []);\n      Assert.equal(store.set('foo', true), true);\n      Assert.deepEqual(store.keys(), ['foo']);\n      Assert.equal(store.set('bar', 'lalala'), 'lalala');\n      Assert.deepEqual(store.keys(), ['foo', 'bar']);\n      Assert.deepEqual(store.clear(), {});\n      Assert.deepEqual(store.keys(), []);\n    });\n\n  });\n});\n"
                }
              }
            },
            "08-object-assign": {
              "title": "Object.assign()",
              "env": "js",
              "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Implementa una función llamada <code>extend</code>. Esta función debe comportarse muy\nparecido a <code>Object.assign()</code>, pero siempre retorna un objeto nuevo, con las\npropiedades de todas los objetos que reciba como argumentos.</p>\n<pre><code class=\"language-js\">const obj1 = { foo: true, bar: false };\nconst obj2 = { baz: 1, bar: true };\nconsole.log(extend(obj1, obj2));\n// { foo: true, bar: true, baz: 1 }\n</code></pre>\n<h2 id=\"requisitos\">Requisitos</h2>\n<ul>\n<li>Tu implementación debe hacer uso de <code>Object.assign</code>.</li>\n</ul>\n<h2 id=\"pistas\">Pistas</h2>\n<p>En las funciones flecha no tenemos <code>arguments</code>, pero podemos usar <code>...args</code>. Más\ninfo sobre esto en la página de MDN (ver link más abajo).</p>\n<h2 id=\"recursos\">Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\">Arrow.function - MDN</a></li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Object.assign()\n\n* Environment: `js`\n\n***\n\n## Tarea\n\nImplementa una función llamada `extend`. Esta función debe comportarse muy\nparecido a `Object.assign()`, pero siempre retorna un objeto nuevo, con las\npropiedades de todas los objetos que reciba como argumentos.\n\n```js\nconst obj1 = { foo: true, bar: false };\nconst obj2 = { baz: 1, bar: true };\nconsole.log(extend(obj1, obj2));\n// { foo: true, bar: true, baz: 1 }\n```\n\n## Requisitos\n\n* Tu implementación debe hacer uso de `Object.assign`.\n\n## Pistas\n\nEn las funciones flecha no tenemos `arguments`, pero podemos usar `...args`. Más\ninfo sobre esto en la página de MDN (ver link más abajo).\n\n## Recursos\n\n* [Arrow.function - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n",
                "Ym9pbGVycGxhdGU=": {
                  "b2JqZWN0QXNzaWduLmpz": "exports.extend = function () {\n  // Escribe aquí tu código.\n};\n"
                },
                "c29sdXRpb24=": {
                  "b2JqZWN0QXNzaWduLmpz": "exports.extend = (...sources) => Object.assign({}, ...sources);\n\n// Implementación usando `bind` (aplicación parcial)\n// exports.extend = Object.assign.bind(Object, {});\n"
                },
                "dGVzdA==": {
                  "b2JqZWN0QXNzaWduLnNwZWMuanM=": "'use strict';\n\n\nconst Assert =  require('chai').assert;\nconst Submission = require('../solution/objectAssign');\n\n\ndescribe('extend', () => {\n\n  it('debería exportar un objeto', () => {\n    Assert.equal(typeof Submission, 'object');\n  });\n\n  it('debería exportar el objeto con un método \"extend\"', () => {\n    Assert.equal(typeof Submission.extend, 'function');\n  });\n\n  it('debería crear un objeto nuevo con todas las propiedades de las fuentes', () => {\n    const obj1 = { foo: true, bar: false };\n    const obj2 = { baz: 1, bar: true };\n    const obj3 = { baz: 2, bar: false };\n\n    const obj4 = Submission.extend(obj1);\n    Assert.deepEqual(obj4, { foo: true, bar: false });\n    obj4.foo = 'hola';\n    Assert.deepEqual(obj4, { foo: 'hola', bar: false });\n    Assert.deepEqual(obj1, { foo: true, bar: false });\n\n    Assert.deepEqual(Submission.extend(obj1, obj2), { foo: true, bar: true, baz: 1 });\n    Assert.deepEqual(Submission.extend(obj1, obj2, obj3), { foo: true, bar: false, baz: 2 });\n  });\n\n});\n"
                }
              }
            },
            "09-composition": {
              "title": "Object composition",
              "env": "js",
              "body": "<h2 id=\"tarea\">Tarea</h2>\n<p>Tómate el tiempo para considerar este snippet. Las funciones <code>pooper</code>, <code>barker</code>,\n<code>driver</code> y <code>killer</code> crean un objeto cada una. Después, creamos <code>dog</code>, <code>robot</code> y\n<code>murderRobot</code>, que simplemente \"componen\" los objetos creados por las funciones\nanteriores.</p>\n<pre><code class=\"language-js\">const pooper = state =&gt; ({\n  poop: () =&gt; console.log('💩')\n});\n\nconst barker = state =&gt; ({\n  bark: () =&gt; console.log('woof! my name is ' + state.name)\n});\n\nconst driver = state =&gt; ({\n  drive: () =&gt; state.position = state.position + state.speed\n});\n\nconst killer = state =&gt; ({\n  kill: () =&gt; console.log('time to kill!')\n});\n\nconst dog = name =&gt; {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n\n  return Object.assign({}, pooper(state), barker(state));\n};\n\nconst robot = name =&gt; {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n\n  return Object.assign({}, driver(state));\n};\n</code></pre>\n<p>Siguiendo este patrón, implementa:</p>\n<ul>\n<li><code>murderRobot</code> (con lo mismo que <code>robot</code> pero además de <code>killer</code>)</li>\n<li><code>murderDog</code> (con todo lo que tiene <code>dog</code> además de <code>killer</code>)</li>\n<li><code>murderRobotDog</code>, que debe combinar la capacidad de ladrar (bark) con la\nfuncionalidad de <code>driver</code> y <code>killer</code>.</li>\n</ul>\n",
              "files": {
                "UkVBRE1FLnB0LUJSLm1k": "# Object composition\n\n* Environment: `js`\n\n***\n\n## Tarea\n\nTómate el tiempo para considerar este snippet. Las funciones `pooper`, `barker`,\n`driver` y `killer` crean un objeto cada una. Después, creamos `dog`, `robot` y\n`murderRobot`, que simplemente \"componen\" los objetos creados por las funciones\nanteriores.\n\n```js\nconst pooper = state => ({\n  poop: () => console.log('💩')\n});\n\nconst barker = state => ({\n  bark: () => console.log('woof! my name is ' + state.name)\n});\n\nconst driver = state => ({\n  drive: () => state.position = state.position + state.speed\n});\n\nconst killer = state => ({\n  kill: () => console.log('time to kill!')\n});\n\nconst dog = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n\n  return Object.assign({}, pooper(state), barker(state));\n};\n\nconst robot = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n\n  return Object.assign({}, driver(state));\n};\n```\n\nSiguiendo este patrón, implementa:\n\n* `murderRobot` (con lo mismo que `robot` pero además de `killer`)\n* `murderDog` (con todo lo que tiene `dog` además de `killer`)\n* `murderRobotDog`, que debe combinar la capacidad de ladrar (bark) con la\n  funcionalidad de `driver` y `killer`.\n",
                "Ym9pbGVycGxhdGU=": {
                  "Y29tcG9zaXRpb24uanM=": "const pooper = state => ({\n  poop: () => console.log('💩')\n});\n\nconst barker = state => ({\n  bark: () => console.log('woof! my name is ' + state.name)\n});\n\nconst driver = state => ({\n  drive: () => state.position = state.position + state.speed\n});\n\nconst killer = state => ({\n  kill: () => console.log('time to kill!')\n});\n\nconst dog = name => {\n  const state = {\n    name: name,\n    speed: 20,\n    position: 0\n  };\n  return Object.assign({}, pooper(state), barker(state));\n};\n\nconst robot = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n  return Object.assign({}, driver(state));\n};\n\nexports.murderRobot = name => {\n  //Escribe aquí tu código\n\n};\n\nexports.murderDog = name => {\n  //Escribe aquí tu código\n\n};\n\nexports.murderRobotDog = name => {\n  //Escribe aquí tu código\n\n};\n"
                },
                "c29sdXRpb24=": {
                  "Y29tcG9zaXRpb24uanM=": "const pooper = state => ({\n  poop: () => console.log('💩')\n});\n\nconst barker = state => ({\n  bark: () => console.log('woof! my name is ' + state.name)\n});\n\nconst driver = state => ({\n  drive: () => state.position = state.position + state.speed\n});\n\nconst killer = state => ({\n  kill: () => console.log('time to kill!')\n});\n\nconst dog = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n  return Object.assign({}, pooper(state), barker(state));\n};\n\nconst robot = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n  return Object.assign({}, driver(state));\n};\n\nexports.murderRobot = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n  return Object.assign({}, driver(state), killer(state));\n};\n\nexports.murderDog = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n  return Object.assign({}, barker(state), pooper(state), killer(state));\n};\n\nexports.murderRobotDog = name => {\n  const state = {\n    name: name,\n    speed: 100,\n    position: 0\n  };\n  return Object.assign({}, barker(state), driver(state), killer(state));\n};\n"
                },
                "dGVzdA==": {
                  "Y29tcG9zaXRpb24uc3BlYy5qcw==": "'use strict';\n\n\nconst Assert = require('chai').assert;\nconst Submission = require('../solution/composition');\n\n\ndescribe('Object composition', () => {\n\n  describe('murderDog()', () => {\n\n    it('debería ser una función', () => {\n      Assert.equal(typeof Submission.murderDog, 'function');\n    });\n\n    it('debería retornar un objeto con bark, poop y kill', () => {\n      const obj = Submission.murderDog();\n      Assert.deepEqual(Object.keys(obj), ['bark', 'poop', 'kill']);\n      Assert.equal(typeof obj.bark, 'function');\n      Assert.equal(typeof obj.poop, 'function');\n      Assert.equal(typeof obj.kill, 'function');\n    });\n\n  });\n\n  describe('murderRobot()', () => {\n\n    it('debería ser una función', () => {\n      Assert.equal(typeof Submission.murderRobot, 'function');\n    });\n\n    it('debería retornar un objeto con drive y kill', () => {\n      const obj = Submission.murderRobot();\n      Assert.deepEqual(Object.keys(obj), ['drive', 'kill']);\n      Assert.equal(typeof obj.drive, 'function');\n      Assert.equal(typeof obj.kill, 'function');\n    });\n\n  });\n\n  describe('murderRobotDog()', () => {\n\n    it('debería ser una función', () => {\n      Assert.equal(typeof Submission.murderRobotDog, 'function');\n    });\n\n    it('debería retornar un objeto con bark, drive y kill', () => {\n      const obj = Submission.murderRobotDog();\n      Assert.deepEqual(Object.keys(obj), ['bark', 'drive', 'kill']);\n      Assert.equal(typeof obj.bark, 'function');\n      Assert.equal(typeof obj.drive, 'function');\n      Assert.equal(typeof obj.kill, 'function');\n    });\n\n  });\n});\n"
                }
              }
            }
          },
          "order": 5,
          "durationString": "1.5h"
        },
        "07-closing": {
          "title": "Cierre",
          "type": "read",
          "format": "self-paced",
          "duration": 5,
          "body": "<h2 id=\"resumen\">Resumen</h2>\n<p><code>Clousure</code> es el cuerpo de la función, dónde ésta tiene acceso al <em>scope</em> donde\nse declaró, además de su scope local. Closure significa que las funciones se\n\"cierran\" alrededor de las variables a las que tiene acceso.</p>\n<p>Las <code>factories</code> o <code>factory functions</code> son simplemente funciones que crean\nobjetos. Podemos usar factories como alternativa a los constructores, siendo más\nsimples y por la tanto, más fácil de visualizar qué hacen.</p>\n<p><code>Object.assign()</code> recibe un objeto como primer argumento, al cual se le copian\ntodas las propiedades de los objetos \"fuente\" que se le pasan al objeto destino.\nEsto nos permite fácilmente \"mezclar\" objetos o simplemente copiar un objeto.</p>\n<ul>\n<li><code>Object.assign(destino, fuente1, fuente2, ... fuenteN)</code></li>\n</ul>\n<p><code>Composition over inheritance</code>, la composición se concentra en la\n\"funcionalidad\", los métodos que implementa un objeto, y para ello en vez de\nheredar, simplemente \"tenemos\" otros objetos a partir de los cuales vamos a\ncomponer una nueva interfaz. La composición no nos ata a la jerarquia que impone\nla herecia, haciendo que ésta sea muchisimo más flexible a la hora de\ndesarrollar.</p>\n<h2 id=\"respondamos-juntxs-las-preguntas-de-la-apertura\">Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Cómo usar <strong>composición</strong> como alternativa a la <em>herencia</em>?</li>\n<li>Qué beneficios tienen las <strong>Factories</strong>?</li>\n<li>Cómo beneficiarse del <strong>Clousure</strong>?</li>\n</ul>\n",
          "order": 6,
          "durationString": "5min"
        }
      },
      "order": 2,
      "stats": {
        "duration": 123,
        "durationString": "2.0h",
        "exerciseCount": 9,
        "partCount": 7
      }
    }
  },
  "grades": "",
  "contributors": "<ul>\n<li>Lupo Montero (autor)</li>\n<li>Mariano Crowe (technical review)</li>\n</ul>\n",
  "books": "<ul>\n<li><a href=\"http://www.oreilly.com/programming/free/object-oriented-vs-functional-programming.csp\">Object-Oriented vs. Functional Programming</a>,\nRichard Warburton, O&#39;Reilly Media</li>\n<li><a href=\"http://eloquentjavascript.net/\">Eloquent JavaScript</a>, Marijn Haverbeke, 2014</li>\n<li><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch4.md\">You Don&#39;t Know JS Yet: Objects &amp; Classes - 2nd Edition, Chapter 4: This Works</a>,\nKyle Simpson, O&#39;Reilly Media, Jul 2014</li>\n<li><a href=\"https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf\">Programming Paradigms for Dummies: What Every Programmer Should Know</a>,\nPeter Van Roy, Université Catholique de Louvain, Bélgica, circa 2010.</li>\n</ul>\n",
  "benchmarks": "<p>Cursos similares que sirven como referencia:</p>\n<ul>\n<li><a href=\"https://www.video2brain.com/mx/cursos/fundamentos-de-la-programacion-paradigmas-de-programacion\">Fundamentos de la programación: Paradigmas de programación</a>,\nJosé Dimas Luján Castillo, video2brain, 8 Mar 2017</li>\n<li><a href=\"https://www.udacity.com/course/object-oriented-javascript--ud015\">Object-Oriented JavaScript</a>,\nHack Reactor en Udacity</li>\n<li><a href=\"https://github.com/madbernard/blinky-dance-party\">Ejercicio de ejemplo del curso de Hack Reactor</a></li>\n<li><a href=\"http://people.cs.aau.dk/~normark/prog3-03/html/notes/paradigms_themes-paradigm-overview-section.html\">Overview of the four main programming paradigms</a>,\nKurt Nørmarks, Aalborg University, Dinamarca.</li>\n</ul>\n",
  "references": "<p>Capítulos de libros:</p>\n<ul>\n<li><a href=\"http://eloquentjavascript.net/03_functions.html\">Eloquent JavaScript - Chapter 3: Functions</a></li>\n<li><a href=\"http://eloquentjavascript.net/05_higher_order.html\">Eloquent JavaScript - Chapter 5: Higher-Order Functions</a></li>\n<li><a href=\"http://eloquentjavascript.net/06_object.html\">Eloquent JavaScript - Chapter 6: The Secret Life of Objects</a></li>\n</ul>\n<p>Blog posts:</p>\n<ul>\n<li><a href=\"http://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/\">Six programming paradigms that will change how you think about coding</a>,\nYevgeniy Brikman, Apr 09 2014</li>\n<li><a href=\"https://css-tricks.com/understanding-javascript-constructors/\">Understanding JavaScript Constructors</a>,\nFaraz Kelhini, CSS Tricks, Sep 24 2015</li>\n<li><a href=\"http://2ality.com/2014/09/es6-modules-final.html\">ECMAScript 6 modules: the final syntax</a>,\nAxel Rauschmayer, 07 Sep 2014</li>\n<li><a href=\"https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\">JavaScript Modules: A Beginner’s Guide</a>,\nPreethi Kasireddy (FreeCodeCamp), Jan 22 2016</li>\n<li><a href=\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\">Why Learn Functional Programming in JavaScript? (Composing Software)</a>,\nEric Elliott en Medium, Feb 20 2017</li>\n<li><a href=\"https://bethallchurch.github.io/JavaScript-and-Functional-Programming/\">JavaScript and Functional Programming</a>,\nBeth Allchurch, 29 of June, 2016</li>\n<li><a href=\"https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming\">An introduction to functional programming</a>,\nMary Rose Cook</li>\n<li><a href=\"https://medium.com/laboratoria-how-to/introducci%C3%B3n-a-la-programaci%C3%B3n-funcional-en-javascript-parte-1-e0b1d0b2142e\">Introducción a programación funcional en JavaScript — Parte 1</a>,\nLupo Montero en Medium, Feb 15 2017</li>\n</ul>\n<p>Videos:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=sqV3pL5x8PI\">Programming Paradigms</a>,\n<code>10:43</code>, <a href=\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\">Computerphile</a>,\n30 Aug 2013</li>\n<li><a href=\"https://www.youtube.com/watch?v=4A2mWqLUpzw\">HTML IS a Programming Language (Imperative vs Declarative)</a>,\n<code>8:27</code>, <a href=\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\">Computerphile</a>,\nJun 28 2016</li>\n<li><a href=\"https://www.video2brain.com/mx/tutorial/que-es-un-paradigma-de-programacion\">Qué es un paradigma de programación</a>,\n<code>5:15</code>, José Dimas Luján Castillo, <a href=\"https://www.video2brain.com/\">video2brain</a>,\n8 Mar 2017</li>\n<li><a href=\"https://frontendmasters.com/courses/javascript-jquery-dom/prototypal-inheritance/\">Prototypal Inheritance</a>,\n<code>8:52</code>, Justin Meyer, <a href=\"https://frontendmasters.com/\">Frontend Masters</a></li>\n<li>Playlist: <a href=\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub\">Object Creation in JavaScript</a>,\n<code>aprox. 3h</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\">funfunfunction</a>,\n2016</li>\n<li><a href=\"https://www.youtube.com/watch?v=riDVvXZ_Kb4\">Prototypes in JavaScript - FunFunFunction #16</a>,\n<code>11:55</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\">funfunfunction</a>,\n25 Jan 2016</li>\n<li><a href=\"https://www.youtube.com/watch?v=YkoelSTUy7A\">Prototype basics - Object Creation in JavaScript P3 - FunFunFunction #46</a>,\n<code>19:19</code>, <a href=\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\">funfunfunction</a>,\n22 ago. 2016</li>\n<li><a href=\"https://www.youtube.com/watch?v=e-5obm1G_FY\">Learning Functional Programming with JavaScript- JSUnconf</a>,\n<code>29:56</code>, Anjana Vakil,\n<a href=\"https://www.youtube.com/channel/UCzoVCacndDCfGDf41P-z0iA\">JSConf</a>\n2016</li>\n</ul>\n<p>Otros recursos:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Programming_paradigm\">Definición de Programming_paradigm en Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Comparison_of_programming_paradigms\">Comparativa de paradigmas de programación en Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/History_of_programming_languages\">History of programming languages</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Declarative_programming\">Declarative programming</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Procedural_programming\">Procedural programming</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">Object-oriented programming</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\">MDN - instanceof</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">MDN - this</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">MDN - Function.bind</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\">MDN - Function.call</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">MDN - Arrow functions</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">MDN - Array.prototype.map</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\">MDN - Closures</a></li>\n</ul>\n",
  "repo": "Laboratoria/bootcamp",
  "path": "topics/paradigms",
  "version": "5.6.0",
  "parserVersion": "4.0.0",
  "track": "js",
  "locale": "es-ES",
  "stats": {
    "duration": 362,
    "durationString": "6.0h",
    "exerciseCount": 23,
    "unitCount": 3,
    "partCount": 26
  }
}
