{
  "slug": "functional",
  "repo": "Laboratoria/curriculum",
  "path": "topics/functional",
  "version": "9.1.0",
  "parserVersion": "6.0.0",
  "createdAt": "2024-06-21T17:34:26.948Z",
  "track": "web-dev",
  "tracks": [
    "web-dev"
  ],
  "intl": {
    "es": {
      "title": "Functional JavaScript",
      "summary": "<p>La programación funcional es un paradigma de programación de suma relevancia hoy\nen día, ya que se presta a resolver problemas de paralelización, asincronía y\nprogramación reactiva entre otros. La programación funcional (<em>Functional\nProgramming</em> o FP por sus siglas en inglés) no es realmente un paradigma nuevo,\nexiste desde hace medio siglo, pero recientemente, y en particular en el mundo\nde JavaScript, se ha convertido en tanto una moda como una necesidad. Poco a\npoco, desde la proliferación de librerías como [underscore][] y [lodash][],\ndespués la adición de <code>map()</code>, <code>filter()</code>, <code>reduce()</code> y compañía, y ahora con\n<em>frameworks</em> como [React][] y [Redux][], conocer el paradigma funcional y estilo\ndeclarativo se han convertido en una necesidad para cualquier desarrolladora de\nJavaScript.</p>\n<p>Familiarizarnos con la programción funcional en JavaScript y ES2015 nos\npermitirá más adelante desenvolvernos con naturalidad con herramientas como\nReact o Redux.</p>\n<p><strong><em>Tags</em></strong>: <code>functional</code>, <code>es6</code>, ...</p>"
    }
  },
  "cover": null,
  "thumb": "data:image/png;base64,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",
  "units": [
    {
      "slug": "state",
      "intl": {
        "es": {
          "title": "Evitando el estado compartido y cambiante"
        }
      },
      "prefix": "01",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Apertura",
              "body": "<h2>¿Por qué aprender esto?</h2>\n<p>En esta unidad veremos dos de los principios fundamentales de la programación\nfuncional: cómo evitar el estado compartido usando <strong>funciones puras</strong> y el\nconcepto de <strong>inmutabilidad</strong>. Ambos conceptos son esenciales en el paradigma\nfuncional y su uso presenta un montón de beneficios, a veces sutiles, pero muy\nimportantes.</p>\n<ul>\n<li>Representan bloques de código reusable dentro de un programa.</li>\n<li>Promueven buenas prácticas de desarrollo como [DRY][]\n(<em>Don’t Repeat Yourself</em>) y [KISS][] (<em>Keep It Simple, Stupid</em>).</li>\n<li>Al no depender del contexto externo, son inmunes a toda clase de errores o\n<em>bugs</em> que tienen que ver con el estado mutable compartido.</li>\n<li>Su naturaleza independiente las hace excelentes candidatos para procesamiento\nconcurrente a lo largo de muchos CPUs e incluso para la computación\ndistribuida, lo cual las hace esenciales para la ejecución de tareas de\ncálculo científico y de uso intensivo de recursos.</li>\n<li>Su aislamiento facilita la refactorización y reorganización del código,\nhaciendo tú código más adaptable y flexible a futuros cambios.</li>\n<li>Es mucho más sencillo el desarrollo de pruebas unitarias contra funciones\npuras.</li>\n<li>Las funciones puras representan la base de la programación funcional.</li>\n</ul>\n<h2>Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Cómo evitar que nuestras funciones tengan efectos colaterales?</li>\n<li>Por qué es beneficioso evitar el estado compartido?</li>\n<li>Cuáles son las ventajas que ofrecen las funciones puras, en particular a la\nhora de hacer testing?</li>\n<li>Cómo evitar la mutación de objetos y arreglos?</li>\n<li>Qué tipos de datos son mutables e inmutables en JavaScript?</li>\n<li>Cómo usar métodos de arreglos como <code>Array#concat</code>, <code>Array#slice</code>, <code>Array#map</code>,\n<code>Array#filter</code>, ... para crear arreglos nuevos en vez de mutar (modificar)\nvalores existentes?</li>\n<li>Cómo usar métodos de objetos (por ejemplo <code>Object.assign()</code>) para copiar\npropiedades y así <em>clonar</em> objetos?</li>\n<li>Cómo usar el <em>spread operator</em> (<code>...</code>) para copiar objetos y arreglos?</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "pure-fun",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Funciones puras",
              "body": "<p>Las funciones puras tienen aplicaciones en muchos ámbitos, entre ellos la\nprogramación funcional. También facilitan la concurrencia, y como veremos en\nsiguientes etapas serán muy empleadas en aplicaciones basadas en React+Redux.</p>\n<p>Anteriormente mencionamos que una función es básicamente un proceso que toma una\nentrada o argumentos, y produce una salida o valor de retorno. También hemos\nvisto que las funciones se emplean con ciertos propósitos:</p>\n<ul>\n<li><em>Manipulación de datos:</em> Transforma una serie de argumentos o entrada en un\nvalor de retorno. Un ejemplo de esto sería hacer <em>flattening</em>1 de\nun objeto muy anidado.</li>\n<li><em>Procedimientos:</em> Una función puede ser llamada para realizar una serie de\npasos (receta). <strong>La secuencia es conocida como procedimiento</strong> (primero haz\nesto, luego haz aquello), el estilo de programación bajo este estilo se\ndenomina <strong>programación por procedimientos</strong>, la cual está enmarcada en la\n<strong>programación imperativa</strong>, donde se usan sentencias que modifican o mutan el\nestado del programa, de la misma forma en la que mandatos imperativos expresan\ncomandos en nuestro lenguaje natural, un programa imperativo consiste en\ncomandos que la computadora debe realizar. La programación imperativa se\nenfoca en describir <em>cómo</em> un programa opera, mientras que en la programación\nfuncional nos enfocamos en <em>qué</em> debe realizar un programa sin especificar\n<em>cómo</em> dicho programa debe alcanzar el resultado.</li>\n<li><em>Entrada/Salida:</em> Algunas funciones existen para comunicarse con otras partes\no subsistemas, por ejemplo: la pantalla, almacenamiento, registro de\noperaciones en disco, operaciones a través de la red.</li>\n</ul>\n<p>Una vez vistas las diversas aplicaciones de las funciones procedamos a dejar\nclaro que significa una <em>función pura</em>.</p>\n<blockquote>\n<p>Toda función que dados los mismos inputs siempre retorna lo mismo, y sin\nefectos secundarios, es una <em>función pura</em>.</p>\n</blockquote>\n<p>En <strong>programación funcional</strong>, el comportamiento de las funciones depende de una\ny solo una cosa: los argumentos pasados explícitamente a la función. Esto quiere\ndecir que si proporcionas los mismos datos como argumentos o entrada, la función\nsiempre debe producir el mismo valor de retorno. A esta propiedad se le conoce\ncomo <strong>transparencia referencial</strong>.</p>\n<p>Lo mencionado en el párrafo anterior, hace que en las funciones puras sea más\nfácil apreciar todas las circunstancias que pueden presentarse, incluyendo\naquellos escenarios que resultan en errores. Escribir funciones que solo\ndependen de sus argumentos para definir su comportamiento también facilita\nreplicar <em>bugs</em> o poner en práctica <em>Test-Driven Development</em> (TDD por sus\nsiglas en inglés).</p>\n<p>Comencemos desarrollando nuestros casos de pruebas:</p>\n<p><strong>lowercaser.test.js.</strong></p>\n<pre><code class=\"language-js\">const lowerCaser = require('./lowercaser')\n\ntest('Should take an input string and returns it lowercased', () => {\n  expect(lowerCaser('LOREM IPSUM')).toBe('lorem ipsum')\n})\n</code></pre>\n<hr>\n<p>NOTA:</p>\n<p>A lo largo del curso usaremos <a href=\"https://facebook.github.io/jest/\">Jest</a> como <em>framework</em> para la ejecución de\npruebas unitarias. Puedes instalar <strong>Jest</strong> por medio de <code>npm</code> al ejecutar el\nsiguiente comando:</p>\n<pre><code class=\"language-sh\">npm install --save-dev jest\n</code></pre>\n<p>O también puedes usar <code>yarn</code> al ejecutar:</p>\n<pre><code class=\"language-sh\">yarn add --dev jest\n</code></pre>\n<p>Para correr las pruebas haremos:</p>\n<pre><code class=\"language-sh\">yarn run jest -- fichero.test.js\n</code></pre>\n<hr>\n<p>Ahora, pasemos a implementar lo especificado en nuestros casos de pruebas:</p>\n<p><strong>lowercaser.js.</strong></p>\n<pre><code class=\"language-js\">const lowerCaser = input => input.toString().toLowerCase()\n\nmodule.exports = lowerCaser\n</code></pre>\n<p>Una vez completada nuestra implementación inicial, corroboremos nuestro trabajo\npor medio de la ejecución de las pruebas:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- lowercaser.test.js\n\nPASS  ./lowercaser.test.js\n   ✓ Should take an input string and returns it lowercased (15ms)\n\n   Test Suites: 1 passed, 1 total\n   Tests:       1 passed, 1 total\n   Snapshots:   0 total\n   Time:        0.859s, estimated 1s\n   Ran all test suites matching \"lowercaser.test.js\".\n</code></pre>\n<p>Parece que todo funciona como se espera. Continuemos.</p>\n<h2>Dada la misma entrada, devuelve siempre la misma salida</h2>\n<p>Con nuestra función <code>lowerCaser()</code>, podemos reemplazar la llamada de la función\npor el resultado, y el código tendrá el mismo significado <code>lowerCaser('LOREM IPSUM')</code> siempre será lo mismo que <code>lorem ipsum</code> en su programa, sin importar el\ncontexto, cuántas veces lo llame o cuándo lo llame.</p>\n<p>Pero no se puede decir lo mismo de todas las funciones. Algunas funciones se\nbasan en información distinta de los argumentos que se transmiten para producir\nresultados. Considera este ejemplo:</p>\n<pre><code class=\"language-js\">Math.random() // => 0.4011148700956255\nMath.random() // => 0.8533405303023756\nMath.random() // => 0.3550692005082965\n</code></pre>\n<p>A pesar de que no pasamos ningún argumento en ninguna de las llamadas a la\nfunción, todos produjeron resultados diferentes, lo que significa que\n<code>Math.random()</code> <strong>no es una función pura</strong>. <code>Math.random()</code> produce un nuevo\nnúmero aleatorio entre 0 y 1 cada vez que lo ejecutas, entonces es obvio que no\nse podría simplemente reemplazarlo por <code>0.4011148700956255</code> sin cambiar el\nsignificado del programa.</p>\n<p>Eso produciría el mismo resultado cada vez que se ejecute el programa. Cuando le\npedimos a la computadora un número aleatorio, por lo general significa que\nqueremos un resultado diferente al que obtuvimos la última vez. ¿Cuál es el\nsentido de un par de dados con los mismos números impresos en todas las caras? A\nveces tenemos que preguntarle a la computadora por la hora actual. No vamos a\nentrar en detalles de cómo funcionan las funciones de tiempo. Por ahora,\nsimplemente copia este código:</p>\n<pre><code class=\"language-js\">const time = () => new Date().toLocaleTimeString()\ntime() // => \"5:15:45 PM\"\n</code></pre>\n<p>¿Qué sucedería si reemplazo la llamada de la función <code>time()</code> con la hora\nactual? Siempre diría que es la misma hora: la hora con la cual la llamada a la\nfunción se reemplazó. En otras palabras, solo podría producir la salida correcta\nuna vez al día, y solo si se ejecuta el programa en el momento exacto en que la\nhora se reemplazó por la función.</p>\n<p>Entonces, claramente, <code>time()</code> no es como la función <code>lowerCaser()</code>.</p>\n<p>Una función solo es pura si, dada la misma entrada, siempre producirá la misma\nsalida. Tal vez recuerdes esta regla de la clase de álgebra: los mismos valores\nde entrada se asignarán siempre al mismo valor de salida. Sin embargo, muchos\nvalores de entrada se pueden asignar al mismo valor de salida. Por ejemplo, la\nsiguiente función es pura:</p>\n<pre><code class=\"language-js\">const highpass = (cutoff, value) => value >= cutoff;\n</code></pre>\n<p>Los mismos valores de entrada se asignarán siempre al mismo valor de salida:</p>\n<pre><code class=\"language-js\">highpass(5, 5) // => true\nhighpass(5, 5) // => true\nhighpass(5, 5) // => true\n</code></pre>\n<p>Muchos valores de entrada tal vez se pueden asignar al mismo valor de salida:</p>\n<pre><code class=\"language-js\">highpass(5, 123) // true\nhighpass(5, 6)   // true\nhighpass(5, 18)  // true\nhighpass(5, 1)   // false\nhighpass(5, 3)   // false\nhighpass(5, 4)   // false\n</code></pre>\n<h2>Efectos colaterales</h2>\n<p>En este punto cabe aclarar que las funciones puras no producen <strong>efectos\ncolaterales</strong> o <em>side-effects</em>, pues el propósito de vida de una función pura es\núnicamente calcular el valor de retorno, solo eso y nada más.</p>\n<p>En las ciencias de la computación, una función o expresión se dice que tiene\nefectos colaterales si modifica algún estado fuera de su ámbito (<em>scope</em>), o si\ntiene interacciones observables con la función que la invocó, o si modifica el\nmundo exterior aparte de retornar el valor esperado. Por ejemplo, una función\nparticular podría modificar una variable global (estado fuera de su ámbito),\nmodificar uno de los argumentos mutables (interactuar con la función la invocó),\nlevantar una excepción, escribir datos a un fichero o llamar a otra función que\nsi tiene efectos colaterales. Ten en cuenta que ante la presencia de funciones\ncon efectos colaterales, el comportamiento de un programa podría depender de su\nhistoria, esto quiere decir que el orden de evaluación importa. Por lo tanto, la\ncomprensión y análisis de una función con efectos colaterales requiere\nconocimientos acerca de su contexto y su posible historia, lo cual hace más\ndifícil la corrección de errores. En la programación funcional, los efectos\ncolaterales se usan con moderación.</p>\n<p>Veamos un ejemplo de efecto colateral y cómo podemos evitarlo.</p>\n<p>Supongamos que deseamos crear una función que concatene dos <em>arrays</em> que pueden\ncontener elementos anidados, tratemos de emular el siguiente comportamiento:</p>\n<p><strong>concat.test.js.</strong></p>\n<pre><code class=\"language-js\">const concat = require('./concat')\n\ntest('should concatenate array on the right with array on the left', () => {\n  const left = [1, [2], 3]\n  const right = [[4], 5, [6, 7], 8]\n  const expected = [1, [2], 3, [4], 5, [6, 7], 8]\n\n  expect(concat(left, right)).toEqual(expected)\n})\n</code></pre>\n<p>Una implementación inicial puede ser la siguiente:</p>\n<p><strong>concat.js.</strong></p>\n<pre><code class=\"language-js\">const concat = (left, right) => {\n  const result = left\n\n  right.map(item => {\n    result.push(item)\n  })\n\n  return result\n}\n\nmodule.exports = concat\n</code></pre>\n<blockquote>\n<p><strong>Nota</strong></p>\n<p>Ten en cuenta que esta implementación es a modo de ejemplo, en realidad\npodríamos usar <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/concat\">Array.prototype.concat()</a> directamente.</p>\n</blockquote>\n<p>Comprobemos nuestro trabajo:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- concat.test.js\n\n PASS  ./concat.test.js\n   ✓ should concatenate the array on the right with the array on the left (3ms)\n\n   Test Suites: 1 passed, 1 total\n   Tests:       1 passed, 1 total\n   Snapshots:   0 total\n   Time:        0.67s, estimated 1s\n   Ran all test suites matching \"concat.test.js\".\n</code></pre>\n<p>Todo parece indicar que nuestra función tiene un comportamiento correcto, ahora\nagreguemos un caso de prueba para comprobar que no estamos alterando el contexto\nexterno:</p>\n<p><strong>concat.test.js.</strong></p>\n<pre><code class=\"language-js\">const concat = require('./concat')\n\ntest('should concatenate array on the right with array on the left', () => {\n  const left = [1, [2], 3]\n  const right = [[4], 5, [6, 7], 8]\n  const expected = [1, [2], 3, [4], 5, [6, 7], 8]\n\n  expect(concat(left, right)).toEqual(expected)\n})\n\ntest('should not mutate external context', () => {\n  const left = [1, [2], 3]\n  const right = [[4], 5, [6, 7], 8]\n  const backup = Object.assign([], left)\n\n  concat(left, right)\n\n  expect(left).toEqual(backup)\n})\n</code></pre>\n<p>Al ejecutar las pruebas obtenemos lo siguiente:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- concat.test.js\n FAIL  ./concat.test.js\n  ● should not mutate external context\n\n    expect(received).toEqual(expected)\n\n    Expected value to equal:\n      [1, [2], 3]\n    Received:\n      [1, [2], 3, [4], 5, [6, 7], 8]\n\n  ...\n\n  ✓ should concatenate the array on the right with the array on the left (4ms)\n  ✕ should not mutate external context (6ms)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 passed, 2 total\nSnapshots:   0 total\nTime:        1.011s\nRan all test suites matching \"concat.test.js\".\n</code></pre>\n<p><strong>Ouch!</strong>, con esto se demuestra que nuestra <strong>función no es pura</strong>, pues\nestamos alterando el contexto externo, lo cual es un tipo de efecto colateral.</p>\n<p>El comportamiento anterior sucede porque los objetos o arreglos pasados a las\nfunciones como argumento se pasan por referencia, no por copia, lo que significa\nque si una función muta una propiedad en un objeto o arreglo, supondría que\ndicha mutación sería accesible desde afuera de la función. Las funciones puras\nno deben alterar el estado externo.</p>\n<p>Si bien el valor de retorno de nuestra función es el esperado, el problema con\nla implementación actual es que hemos mutado un estado compartido. Imagina por\nun momento que otras funciones pueden depender del estado del arreglo u objeto\nasumiendo que su estado es el original (antes de llamar a nuestra función\n<code>concat</code>), y ahora que hemos mutado ese estado compartido, tenemos que\npreocuparnos por el impacto que tendrá dicho cambio en la lógica del programa si\ncambiamos el orden en que se han llamado las funciones. Refactorizar el código\npodría resultar en errores apareciendo aquí y allá, lo que podría arruinar la\nlógica general de nuestra aplicación, y como resultado muchos clientes\ndisgustados.</p>\n<p>Veamos ahora cómo podemos corregir esta situación:</p>\n<p><strong>concat.js.</strong></p>\n<pre><code class=\"language-js\">const concat = (left, right) => {\n  const result = Object.assign([], left)\n\n  right.map(item => {\n    result.push(item)\n  })\n\n  return result\n}\n\nmodule.exports = concat\n</code></pre>\n<p>Ahora al ejecutar las pruebas obtenemos lo siguiente:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- concat.test.js\n PASS  ./concat.test.js\n  ✓ should concatenate the array on the right with the array on the left (5ms)\n  ✓ should not mutate external context (1ms)\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        0.977s\nRan all test suites matching \"concat.test.js\".\n</code></pre>\n<p>¿Recuerdas que antes habíamos mencionado que podíamos haber usado\n<code>Array.prototype.concat</code> directamente?, pues veamos una simplificación del\ncódigo:</p>\n<p><strong>concat.js.</strong></p>\n<pre><code class=\"language-js\">const concat = (left, right) => {\n  return left.concat(right)\n}\n\nmodule.exports = concat\n</code></pre>\n<p>Si ejecutas de nuevo las pruebas unitarias verás que cumplimos con todas las\ncondiciones.</p>\n<hr>\n<p>NOTA: Es común usar métodos como <code>Array#slice</code>, <code>Array#map</code> o <code>Array#filter</code>\nademás de <code>Array#concat</code> para crear copias de arreglos. En <strong>ES6</strong> también\ntenemos el <em>spread operator</em> que nos permite copiar las propiedades enumerables\nde un arreglo u objeto de esta forma:</p>\n<pre><code class=\"language-js\">const array = [1, 2, 3];\nconst arrayCopy = [...a]; // `b` es un nuevo arreglo con los elementos de `a`.\n\nconst obj = { foo: 'bar' };\nconst objCopy = {...obj};\n</code></pre>\n<hr>\n<h2>Beneficios</h2>\n<p>Una vez analizadas las funciones puras, volvamos a repasar los beneficios que\nofrecen, tal como vimos en la apertura de esta unidad:</p>\n<ul>\n<li>Toman ciertos argumentos como entrada y generan un valor de retorno que\nexclusivamente depende de los argumentos dados.</li>\n<li>Representan bloques de código reusable dentro de un programa.</li>\n<li>Promueven buenas prácticas de desarrollo como <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\">DRY</a>\n(<em>Don’t Repeat Yourself</em>) y <a href=\"https://en.wikipedia.org/wiki/KISS_principle\">KISS</a> (<em>Keep It Simple, Stupid</em>).</li>\n<li>Al no depender del contexto externo, son inmunes a toda clase de errores o\n<em>bugs</em> que tienen que ver con el estado mutable compartido.</li>\n<li>Su naturaleza independiente las hace excelentes candidatos para procesamiento\nconcurrente a lo largo de muchos CPUs e incluso para la computación\ndistribuida, lo cual las hace esenciales para la ejecución de tareas de\ncálculo científico y de uso intensivo de recursos.</li>\n<li>Su aislamiento facilita la refactorización y reorganización del código,\nhaciendo tú código más adaptable y flexible a futuros cambios.</li>\n<li>Es mucho más sencillo el desarrollo de pruebas unitarias contra funciones\npuras.</li>\n<li>Las funciones puras representan la base de la programación funcional.</li>\n</ul>\n<p>Por las razones antes mencionadas, recomendamos favorecer la implementación de\nfunciones puras. Por lo tanto, siempre que sea práctico implementar los\nrequerimientos de un programa usando funciones puras, debes darle preferencia\nsobre otras opciones.</p>\n<h2>Referencias</h2>\n<ul>\n<li>Conrad Barski. 2010. Land of Lisp: Learn to Program in Lisp, One Game at a\nTime! (1st ed.). No Starch Press, San Francisco, CA, USA. Page 301.</li>\n<li><a href=\"https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976\">Master the JavaScript Interview: What is a Pure Function?</a>. En Medium.\nConsultado el 11 de Julio de 2017</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\">Side effect (computer science)</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Imperative_programming\">Imperative Programming</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase\">String.prototype.toLowerCase()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\">Math.random()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString\">Date.prototype.toLocaleDateString()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">Array.prototype.concat()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\">Object.assign()</a></li>\n</ul>\n<h2>Notas al pie</h2>\n<ol>\n<li>Algunas veces necesitamos aplanar árboles u objetos muy anidados que son\nresultado de una consulta o <em>query</em>, un patrón común es convertirlos en\narreglos o <em>arrays</em> para luego poder aplicar operaciones como <code>filter()</code> o\n<code>map()</code> sobre ellos.</li>\n</ol>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "practice",
          "type": "practice",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Ejercicios de funciones puras",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "discount",
              "prefix": "01",
              "path": "topics/functional/01-state/02-practice/01-discount",
              "createdAt": "2024-06-21T17:34:26.946Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Aplicando descuentos",
                  "body": "<p>Un día aparece un bug en una tienda online en la que estás trabjando. Alguien\ndel equipo ha añadido una nueva funcionalidad para poder aplicar descuentos a\nclientes frecuentes. Para ello, se ha implementado una función\n(<code>applyDiscount(cart, discount)</code>) que recibe un arreglo de objetos (el <code>cart</code>),\ncada uno con un precio, y un porcentaje de descuento. La función retorna un\narreglo de objetos con los precios modificados de acuerdo al descuento.</p>\n<p>Por ejemplo:</p>\n<pre><code class=\"language-js\">const myCart = [\n  { price: 1 },\n  { price: 2 },\n  { price: 3 }\n];\n\nconst cartWithDiscount = applyDiscount(myCart, .3);\nconsole.log(myCart, cartWithDiscount);\n</code></pre>\n<p>Ahora, después de investigar un rato descubrimos dos problemas:</p>\n<ol>\n<li>La función parece estar mutando los objetos dentro del arreglo en vez de\ncrear objetos nuevos!</li>\n<li>La función parece estar ignorando el descuento que le indicamos en el\nargumento <code>discount</code> y siempre aplica un 20%!</li>\n</ol>\n<p>El código en cuestión es este:</p>\n<pre><code class=\"language-js\">const discount = .2;\n\n// Broken: returns new array but mutates objects.\nconst applyDiscount = (cart) => {\n  if (!cart.length) {\n    return [];\n  }\n\n  const current = cart.shift();\n  current.price *= (1 - discount);\n  return [current].concat(applyDiscount(cart));\n};\n\nmodule.exports = applyDiscount;\n</code></pre>\n<p>En resumen, tal y como está ahora, la función no es <em>pura</em> ya que tiene efectos\ncolaterales (modifica el arreglo <code>cart</code>) y hace uso de una variable fuera de su\nscope (<code>discount</code>) en vez de un <em>argumento</em>.</p>\n<h2>Tarea</h2>\n<p>Refactoriza la función <code>applyDiscount()</code> para convertirla en una función pura.\nPara ello tendrás que:</p>\n<ul>\n<li>Evitar mutar los objetos del arreglo que recibe como argumento.</li>\n<li>Usar el argumento <code>discount</code> que recibe la función durante la invocación en\nvez de la variable <code>discount</code> declarada fuera de la función.</li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/discount.js": "const discount = .2;\n\n// Broken: returns new array but mutates same object references.\nconst applyDiscount = (cart) => {\n  if (!cart.length) {\n    return [];\n  }\n\n  const current = cart.shift();\n  current.price *= (1 - discount);\n  return [current].concat(applyDiscount(cart));\n};\n\nmodule.exports = applyDiscount;\n",
                "/solution/discount.js": "// Broken: returns new array but mutates same object references.\n// const applyDiscount = (cart) => {\n//   if (!cart.length) {\n//     return [];\n//   }\n//\n//   const current = cart.shift();\n//   current.price *= (1 - discount);\n//   return [current].concat(applyDiscount(cart));\n// };\n\n// Broken: mutates array and objects\n// const applyDiscount = (cart) => {\n//   for (let i = 0; i < cart.length; i++) {\n//     cart[i] *= (1 - discount);\n//   }\n//   return cart;\n// };\n\n// Broken: new array but mutates same object references!!\n// const applyDiscount = (cart, discount) => cart.map(item => {\n//   item.price *= (1 - discount);\n//   return item;\n// });\n\n// Solución 1\nconst applyDiscount = (cart, discount) => {\n  if (!cart.length) {\n    return [];\n  }\n\n  const current = Object.assign({}, cart[0], {\n    price: cart[0].price * (1 - discount)\n  });\n\n  return [current].concat(applyDiscount(cart.slice(1), discount));\n};\n\n// Solución 2\n// const applyDiscount = (cart, discount) =>\n//   (!cart.length && []) || [Object.assign({}, cart[0], {\n//     price: cart[0].price * (1 - discount)\n//   })].concat(applyDiscount(cart.slice(1), discount));\n\n\nmodule.exports = applyDiscount;\n",
                "/test/discount.spec.js": "const Assert = require('chai').assert;\nconst Submission = require('../solution/discount');\n\n\ndescribe('applyDiscount()', () => {\n\n  it('debería devolver un nuevo array', () => {\n    const cart = [];\n    const result = Submission(cart, .2);\n    Assert.notStrictEqual(cart, result);\n  });\n\n  it('debería devolver un array con mismo length que input', () => {\n    [\n      [],\n      [{ price: 1 }],\n      [{ price: 1 }, { price: 7 }, { price: 19 }]\n    ].forEach(cart => Assert.equal(cart.length, Submission(cart, .2).length));\n  });\n\n  it('no debería mutar array de entrada', () => {\n    const item1 = { price: 1 };\n    const item2 = { price: 2 };\n    const item3 = { price: 3 };\n    const cart = [item1, item2, item3];\n    const cartWithDiscount = Submission(cart, .3);\n    Assert.strictEqual(cart.length, 3);\n    Assert.strictEqual(cart[0], item1);\n    Assert.strictEqual(cart[1], item2);\n    Assert.strictEqual(cart[2], item3);\n    Assert.deepEqual(cart[0], { price: 1 });\n    Assert.deepEqual(cart[1], { price: 2 });\n    Assert.deepEqual(cart[2], { price: 3 });\n  });\n\n  it('no debería mutar objetos', () => {\n    const item1 = { price: 1 };\n    const item2 = { price: 2 };\n    const item3 = { price: 3 };\n    const cart = [item1, item2, item3];\n    const cartWithDiscount = Submission(cart, .3);\n    Assert.strictEqual(cart.length, 3);\n    Assert.strictEqual(cart[0].price, 1);\n    Assert.strictEqual(cart[1].price, 2);\n    Assert.strictEqual(cart[2].price, 3);\n  });\n\n  it('debería retornar objetos con descuento indicado', () => {\n    const item1 = { price: 1 };\n    const item2 = { price: 2 };\n    const item3 = { price: 3 };\n    const cart = [item1, item2, item3];\n    const cartWithDiscount = Submission(cart, .3);\n    Assert.strictEqual(cartWithDiscount[0].price, 1 * (1 - .3));\n    Assert.strictEqual(cartWithDiscount[1].price, 2 * (1 - .3));\n    Assert.strictEqual(cartWithDiscount[2].price, 3 * (1 - .3));\n  });\n\n});\n"
              }
            },
            {
              "slug": "serialize-user",
              "prefix": "02",
              "path": "topics/functional/01-state/02-practice/02-serialize-user",
              "createdAt": "2024-06-21T17:34:26.946Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "serializeUser()",
                  "body": "<p>Imagínate que estás trabajando en una aplicación donde tienes una función\nllamada <code>serializeUser()</code> que lo que hace es convertir un objeto de usuario en\nun string en formato JSON. Además, hace un par de modificaciones (limita el\nnombre a 10 caracteres y convierte la fecha en un string).</p>\n<p>Veamos un ejemplo:</p>\n<pre><code class=\"language-js\">const grace = {\n  userId: 'xxx',\n  name: 'Grace Hopper',\n  country: 'us',\n  date: new Date()\n};\n\nserializeUser(grace);\n// => {\"userId\":\"xxx\",\"name\":\"Grace H...\",\"country\":\"us\",\"date\":\"2017-09-07T21:42:09.152Z\"}\n</code></pre>\n<p>Ahora, el problema es que cuando implementaron la función <code>serializeUser()</code>, lo\nhicieron de tal forma que la función muta el objeto que le mandamos como\nargumento!</p>\n<p>La implementación actual luce así:</p>\n<pre><code class=\"language-js\">const serializeUser = user => {\n  user.name = (user.name.length > 10) ? `${user.name.slice(0, 7)}...` : user.name;\n  user.date = user.date.toJSON();\n  return JSON.stringify(user);\n};\n\nmodule.exports = serializeUser;\n</code></pre>\n<h2>Tarea</h2>\n<p>Refactoriza la función <code>serializeUser()</code> para convertirla en una función pura y\nevitar que modifique el objeto que recibe como argumento.</p>"
                }
              },
              "files": {
                "/boilerplate/serializeUser.js": "const serializeUser = user => {\n\tuser.name = (user.name.length > 10) ? `${user.name.slice(0, 7)}...` : user.name;\n\tuser.date = user.date.toJSON();\n\treturn JSON.stringify(user);\n};\n\nmodule.exports = serializeUser;\n",
                "/solution/serializeUser.js": "const serializeUser = user => JSON.stringify(Object.assign({}, user, {\n  name: (user.name.length > 10) ? `${user.name.slice(0, 7)}...` : user.name,\n  date: user.date.toJSON(),\n}));\n\nmodule.exports = serializeUser;\n",
                "/test/serializeUser.spec.js": "const Assert = require('chai').assert;\nconst Submission = require('../solution/serializeUser');\n\n\ndescribe('serializeUser()', () => {\n\n  it('debería retornar un string con el objeto serializado como JSON', () => {\n    const grace = {\n      userId: 'xxx',\n      name: 'Grace Hopper',\n      country: 'us',\n      date: new Date()\n    };\n    const dateStr = grace.date.toJSON();\n    Assert.equal(\n      Submission(grace),\n      `{\"userId\":\"xxx\",\"name\":\"Grace H...\",\"country\":\"us\",\"date\":\"${dateStr}\"}`\n    );\n  });\n\n  it('no debería mutar el objeto que recibe como argumento', () => {\n    const grace = {\n      userId: 'xxx',\n      name: 'Grace Hopper',\n      country: 'us',\n      date: new Date()\n    };\n    Submission(grace);\n    Assert.equal(grace.name, 'Grace Hopper');\n    Assert.ok(grace.date instanceof Date);\n  });\n\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "03",
          "slug": "immutability",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Inmutabilitidad",
              "body": "<p>La inmutabilidad es un principio fundamental en la programación funcional, y\ntambién tiene ventajas que ofrecer a otros paradigmas como el orientado a\nobjetos. En esta lección mostraremos qué es la inmutabilidad, cómo podemos\naprovechar este concepto en JavaScript, y por qué es tan útil.</p>\n<h2>¿Qué es la inmutabilidad?</h2>\n<p>La definición de mutabilidad indica que algo está sujeto a cambios o\nmodificaciones. En programación, cuando decimos que un objeto es mutable nos\nreferimos a que está permitido modificar el estado de dicho objeto a lo largo\ndel tiempo. Un valor <strong>inmutable</strong> indica exactamente lo opuesto, después que\ndicho valor es creado, no puede ser cambiado o alterado nunca.</p>\n<p>Esto parece ser un poco extraño, pero recordemos que muchos valores que usamos\ntodo el tiempo en realidad son inmutables.</p>\n<p>Algunos tipos de datos en JavaScript son inmutables por omisión. Las cadenas de\ncaracteres o <em>strings</em> son un ejemplo de un tipo de dato que no puede ser\ncambiado.</p>\n<p><strong>strings.test.js.</strong></p>\n<pre><code class=\"language-js\">test('should not change the value of the original string', () => {\n  const lesson = 'immutability'\n\n  expect(lesson.toUpperCase()).toBe('IMMUTABILITY')\n  expect(lesson).toBe('immutability')\n})\n</code></pre>\n<p>Si ejecutamos las pruebas anteriores veremos que el valor original de la cadena\n(<code>immutability</code>) no es modificado tras la operación ejecutada:</p>\n<pre><code class=\"language-sh\">$ yarn run jest strings.test.js\nPASS  ./strings.test.js\n✓ should not change the value of the original string (5ms)\n\n  Test Suites: 1 passed, 1 total\n  Tests:       1 passed, 1 total\n  Snapshots:   0 total\n  Time:        0.941s, estimated 1s\n  Ran all test suites matching \"strings.test.js\".\n  ✨  Done in 1.56s.\n</code></pre>\n<p>De hecho, ningún método sobre cadenas de caracteres puede cambiar la cadena\nsobre la que opera, todos ellos retornan nuevas cadenas de caracteres. La razón\ntras esto radica en que las cadenas de caracteres son inmutables. Por lo tanto,\nsu valor no puede cambiar, nosotros solo podemos crear nuevos <em>strings</em>.</p>\n<p>Las cadenas de caracteres no son los únicos valores inmutables dentro de\nJavaScript. Los números también son inmutables. ¿Te puedes imaginar un entorno\nen donde al evaluar la expresión 2 + 3 cambie automáticamente el significado del\nnúmero 2?, suena absurdo, ¿verdad?. Sin embargo, solemos modificar nuestros\nobjetos y arreglos todo el tiempo!</p>\n<h2>Inmutabilidad y su relación con la recursividad</h2>\n<p>Más adelante hablaremos con mayor detalle sobre recursividad. Sin embargo, vale\nacotar que es un patrón que se suele ver en la programación funcional.</p>\n<p>En algunos lenguajes funcionales no puedes escribir la siguiente función\nhaciendo uso de mutación local:</p>\n<pre><code class=\"language-js\">const range = require('lodash.range')\n\nconst summ = array => {\n  let result = 0\n  const size = array.length\n\n  for (let i = 0; i &#x3C; size; i++) {\n    result += array[i]\n  }\n\n  return result\n}\n\nsumm(range(11))\n// => 55\n</code></pre>\n<p>El problema es que la función anterior modifica el estado de dos variables\nlocales. Sin embargo, en lenguajes funcionales tradicionales, las variables\nlocales no son <em>variables</em> en sí, son inmutables. En este caso, la única vía\npara modificar el valor de una variable local es por medio del <em>call stack</em>, y\nesto es lo que precisamente logramos con la recursión. Veamos una\nreimplementación de la función previa usando recursividad:</p>\n<pre><code class=\"language-js\">const range = require('lodash.range')\nconst isEmpty = require('lodash.isempty')\n\nconst summRec = (array, seed = 0) => {\n  const [head, ...tail] = array\n  return isEmpty(array) ? seed : summRec(tail, head + seed)\n}\n\nsummRec([])\n// => 0\n\nsummRec(range(11))\n// => 55\n</code></pre>\n<p>Cuando usamos recursividad, el cambio de estado es modelado por medio de los\nargumentos pasados en la función recursiva. JavaScript permite el manejo del\nestado de manera recursiva, pero tiene ciertos límites que veremos más adelante.\nLo importante es hacer notar que existe cierta relación entre la recursividad y\nla inmutabilidad de las variables locales.</p>\n<h2>En JavaScript, los tipos de datos mutables abundan</h2>\n<p>Ya esto lo hemos mencionado, pero vale la pena ahondar en ello:</p>\n<pre><code class=\"language-js\">let initial = ['hello']\nlet greeting = initial.push('world')\n</code></pre>\n<p>Podríamos asumir que el resultado sería el siguiente:</p>\n<pre><code class=\"language-js\">initial = ['hello']\ngreeting = ['hello', 'world']\n</code></pre>\n<p>Parece lógico, ¿no?, pues resulta que en realidad el resultado es el siguiente:</p>\n<pre><code class=\"language-js\">initial = ['hello', 'world']\ngreeting = 2\n</code></pre>\n<p>El método <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push\">Array.prototype.push()</a> agrega uno o más elementos al final del\narray <em>in situ</em> y retorna la <em>longitud</em> del array. Es decir, a diferencia de los\nmétodos sobre las cadenas de caracteres, en este caso observamos que se esta\nmutando la variable (<code>arr</code>) original.</p>\n<p>Ahora imagina por un momento que tenemos un tipo de dato denominado\n<code>ImmutableArray</code> y tiene un comportamiento similar a las cadenas de caracteres\ny números:</p>\n<pre><code class=\"language-js\">const initial = new ImmutableArray(['hello'])\nconst greeting = initial.push('world')\n\ninitial.toArray() // => ['hello']\ngreeting.toArray() // => ['hello', 'world']\n</code></pre>\n<p>También imagina que tenemos un tipo de dato mapa inmutable, en donde el\nestablecimiento de nuevas propiedades sobre el objeto o mapa en realidad no\nestablece el valor <em>in situ</em>, en vez de ello devuelve un nuevo objeto con los\ncambios deseados:</p>\n<pre><code class=\"language-js\">const firstOrder = new ImmutableMap({name: 'Julia', details: 'espresso macchiato'})\nconst newOrder = firstOrder.set('details': 'doppio')\n\nfirstOrder.toObject() // => {name: 'Julia', details: 'espresso macchiato'}\nnewOrder.toObject() // => {name: 'Julia', details: 'doppio'}\n</code></pre>\n<p>Al igual que las operaciones con cadenas de caracteres, el cambio de la orden\nde Julia, no implica que originalmente no haya solicitado un <em>espresso\nmacchiato</em>.</p>\n<p>Si quisieramos incluir este tipo de estructuras de datos en nuestras\naplicaciones al menos por ahora debemos recurrir a bibliotecas externas, por\nejemplo, haciendo uso de <a href=\"http://facebook.github.io/immutable-js/\">immutable.js</a> tendríamos lo siguiente:</p>\n<pre><code class=\"language-js\">const Map = require('immutable')\nconst firstOrder = Map({name: 'Julia', details: 'espresso macchiato'})\nconst newOrder = firstOrder.set('details': 'doppio')\n\nfirstOrder.get('details') // => 'espresso macchiato'\nnewOrder.get('details') // => 'doppio'\n</code></pre>\n<hr>\n<h2>Lecturas complementarias</h2>\n<h3>Object.freeze() y clone</h3>\n<p>Dado que JavaScript pasa <em>arrays</em> y objetos por referencia, nada en realidad es\ninmutable en estos casos. También, dado que los campos o propiedades de los\nobjetos en JavaScrit son siempre visibles, no hay una manera sencilla de\nhacerlos inmutables. Existen maneras de ocultar datos usando encapsulación para\nevitar cambios accidentales, pero en líneas generales, todos los objetos en\nJavaScrit son mutables, a menos que sean congelados.</p>\n<p>Versiones recientes de JavaScript proveen el método <code>Object#freeze</code>, que dado un\nobjeto o <em>array</em>, causará que las siguientes mutaciones fallen. En el caso de\nestar usando el modo estricto, la falla generará una excepción <code>TypeError</code>, de\nlo contrario, cualquier mutación fallará silenciosamente.</p>\n<p>El método <code>freeze</code> funciona como sigue a continuación:</p>\n<pre><code class=\"language-js\">let a = [1, 2, 3]\na[1] = 42\na // => [1, 42, 3]\n\nObject.freeze(a)\n</code></pre>\n<p>Un <em>array</em> normal es mutable por omisión, pero después de llamar a\n<code>Object#freeze</code>, lo que ocurre es lo siguiente:</p>\n<pre><code class=\"language-js\">a[1] = 108\na // => [1, 42, 3]\n</code></pre>\n<p>Esto es, la mutación que se intentó hacer sobre el <em>array</em> no tuvo efecto.\nTambién podemos hacer uso del método <code>Object#isFrozen</code> para verificar si el\n<em>array</em> está congelado:</p>\n<pre><code class=\"language-js\">Object.isFrozen(a)\n// => true\n</code></pre>\n<p>Existen dos problemas al usar <code>Object#freeze</code> para asegurar inmutabilidad.</p>\n<ul>\n<li>A menos que tengas completo control de la base de código del proyecto, algunos\nerrores podrían ocurrir.</li>\n<li>El método <code>Object#freeze</code> es <em>shallow</em>.</li>\n</ul>\n<p>En el primer punto podríamos argumentar que otras compañeras de trabajo podrían\nasumir por ejemplo que el objeto o <em>array</em> es mutable, cuando no es así. También\npodríamos considerar que una biblioteca que uses explota la mutabilidad de los\nobjetos o <em>arrays</em>. Por lo tanto, congelar objetos y pasarlos a otras APIs\narbitrarias podría ser causa de problemas.</p>\n<p>Ahora bien, el otro argumento en contra de <code>Object#freeze</code> es que es una\noperación <em>shallow</em>. Esto es, <code>freeze</code> solo aplicará en el nivel superior de la\nestructura de datos y no recorrerá niveles anidados. Por ejemplo:</p>\n<pre><code class=\"language-js\">let x = [{a: [1, 2, 3], b: 42}, {c: {d: []}}]\n\nObject.freeze(x)\n\nx[0] = ''\nx\n// => [{a: [1, 2, 3], b: 42}, {c: {d: []}}]\n</code></pre>\n<p>El intento de modificación del <em>array</em> falla. Sin embargo, realizar una mutación\nde una porción anidada dentro de dicho arreglo es posible:</p>\n<pre><code class=\"language-js\">x[1]['c']['d'] = 100000\nx\n// => [ { a: [ 1, 2, 3 ], b: 42 }, { c: { d: 100000 } } ]\n</code></pre>\n<p>Para aplicar un congelamiento profundo sobre un objecto, tendremos que usar\nrecursión para recorrer la estructura de datos:</p>\n<pre><code class=\"language-js\">const _ = require('lodash')\n\nconst deepFreeze = obj => {\n  if (!Object.isFrozen(obj)) {\n    Object.freeze(obj)\n  }\n\n  for (const key in obj) {\n    if (!obj.hasOwnProperty(key) || !_.isObject(obj[key])) {\n      continue\n    }\n    deepFreeze(obj[key])\n  }\n}\n</code></pre>\n<p>Ahora, podemos usar <code>deepFreeze</code> y esperar el comportamiento adecuado:</p>\n<pre><code class=\"language-js\">const x = [{a: [1, 2, 3], b: 42}, {c: {d: []}}]\ndeepFreeze(x)\nx[0] = null\nx\n// => [ { a: [ 1, 2, 3 ], b: 42 }, { c: { d: [] } } ]\nx[1]['c']['d'] = 100000\nx\n// => [ { a: [ 1, 2, 3 ], b: 42 }, { c: { d: [] } } ]\n</code></pre>\n<p>Sin embargo, es necesario considerar de nuevo que el congelamiento de objetos\npuede generar errores al interactuar con APIs terceras. Por lo que nuestras\nopciones se ven reducidas a las siguientes:</p>\n<ul>\n<li>Usar <code>_.clone</code> si conoces de antemano que un <em>shallow</em> copy es apropiado</li>\n<li>Crear <code>deepClone</code> (similar a la función <code>deepFreeze</code>) para hacer copias de\nestructuras de datos anidadas</li>\n<li>Construir tú código basado en funciones puras</li>\n<li>Usar bibliotecas externas que te permitan manejar estructuras de datos\ninmutables</li>\n</ul>\n<h3>Acerca del rendimiento</h3>\n<p>Puedes pensar que al usar estructuras de datos inmutables estás afectando\nsobremanera el rendimiento de tú aplicación y puede que tengas razón. Siempre\nque se ejecute alguna operación que modifica al objeto inmutable, se\nnecesitará crear una nueva instancia copiando los valores existentes y\nagregando las nuevas propiedades necesarias. Esto ciertamente pueden ser\noperaciones costosas a nivel computacional que simplemente mutar un simple\nobjeto.</p>\n<p>Sin embargo, al saber que un objeto inmutable nunca cambiará, dichas\nestructuras pueden ser implementadas usando una estrategía denominada\n<em>structural sharing</em>, lo cual resulta ser menos costoso en el uso de la memoria\nde lo que imaginas.  Por supuesto, no será tan rápido si lo comparamos con los\n<em>arrays</em> y <em>objetos</em> nativos, pero los beneficios que brindan las estructuras\nde datos inmutables pueden ser mayores. En la practica, es posible que el uso de\nestructuras de datos inmutables mejore el rendimiento global de tú aplicación,\nsin importar que ciertas operaciones particulares sean más costosas por el tipo\nde operaciones que realizan.</p>\n<h3>Seguimiento de cambios</h3>\n<p>Las operaciones a nivel de DOM, o determinar qué componentes de la vista deben\nser actualizados dado ciertos cambios en el modelo, suelen ser costosas por lo\nque minimizar el número de operaciones necesarias para la actualizar la UI\nsiempre es bienvenido.</p>\n<p>Una manera eficiente de reducir el número de operaciones necesarias para\nactualizar la UI es utilizar estructuras de datos que cumplan con las siguientes\ncondiciones:</p>\n<ul>\n<li>Inmutables: Una vez creadas, una colección no puede ser alterada en ningún\notro momento.</li>\n<li>Persistente: Nuevas colecciones pueden ser creadas a partir de previas, (ej.\npor medio de operaciones como <code>set</code>). La colección original seguirá siendo\nválida incluso después de la creación de la nueva colección.</li>\n<li><em>structural sharing</em>: Nuevas colecciones son creadas usando tanto como sea\nposible la misma estructura de la colección original, reduciendo la copia al\nmínimo para mejorar el rendimiento.</li>\n</ul>\n<p>La inmutabilidad hace que el seguimiento de cambios sea barato. Un cambio\nsiempre resultará en un nuevo objeto, por lo que solo es necesario verificar si\nla referencia al objeto ha cambiado. Por ejemplo, en este ejemplo de código\nregular JavaScript:</p>\n<pre><code class=\"language-js\">const x = { foo: 'bar' };\nconst y = x;\ny.foo = 'baz';\nx === y; // => true\n</code></pre>\n<p>Sin embargo, <code>y</code> fue editada, dado que es una referencia al mismo objeto <code>x</code>,\nesta comparación retorna <code>true</code>. Podemos escribir código similar con\nimmutable.js:</p>\n<pre><code class=\"language-js\">const SomeRecord = Immutable.Record({ foo: null });\nconst x = new SomeRecord({ foo: 'bar' });\nconst y = x.set('foo', 'baz');\nconst z = x.set('foo', 'bar');\nx === y; // => false\nx === z; // => true\n</code></pre>\n<p>En este caso, dado que una referencia se retorna al realizar una mutación sobre\n<code>x</code>, podemos utilizar el chequeo de igualdad (<code>x === y</code>) para verificar que un\nnuevo valor se ha almacenado en <code>y</code> y es diferente al original almacenado en\n<code>x</code>. Esto puede implicar un incremento significativo en el rendimiento.</p>\n<h2>Referencias</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze()</a></li>\n<li><a href=\"https://www.sitepoint.com/immutability-javascript/\">Immutability in JavaScript</a></li>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\">Functional JavaScript</a> de\nMichael Fogus</li>\n<li><a href=\"https://facebook.github.io/react/docs/optimizing-performance.html\">React: Optimizing Performance</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "practice-2",
          "type": "practice",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Ejercicios de inmutabilidad",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "parse-items",
              "prefix": "01",
              "path": "topics/functional/01-state/04-practice-2/01-parse-items",
              "createdAt": "2024-06-21T17:34:26.946Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Parse items",
                  "body": "<p>Refactoriza le siguiente función para que devuelva un nuevo arreglo en vez de\nmodificar el arreglo que recibe como argumento.</p>\n<pre><code class=\"language-js\">const parseItems = items => {\n  for (let i = 0; i &#x3C; items.length; i++) {\n    items[i] = parseInt(items[i]);\n  }\n  return items.sort();\n};\n</code></pre>\n<h2>Pistas</h2>\n<ul>\n<li>Puedes usar <code>Array#map()</code> para iterar sobre el array y aplicar la\ntransformación requerida (<code>parseInt()</code>).</li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/parseItems.js": "const parseItems = (items) => {\n  for (let i = 0; i < items.length; i++) {\n    items[i] = parseInt(items[i]);\n  }\n  return items.sort();\n};\n\nmodule.exports = parseItems;\n",
                "/solution/parseItems.js": "const parseItems = items => items.map(item => parseInt(item)).sort();\n\nmodule.exports = parseItems;\n",
                "/test/parseItems.spec.js": "const Assert = require('chai').assert;\nconst Submission = require('../solution/parseItems');\n\n\ndescribe('parseItems()', () => {\n\n  it('debería retornar un nuevo arreglo', () => {\n    const original = ['6', '3', '5', '2', '4'];\n    const parsed = Submission(original);\n\n    Assert.notDeepEqual(original, parsed);\n    Assert.notEqual(original, parsed);\n  });\n\n  it('debería retornar un arreglo de números', () => {\n    Submission(['6', '3', '5', '2', '4']).forEach(Assert.isNumber);\n  });\n\n  it('debería retornar un arreglo ordenado', () => {\n    Assert.deepEqual(Submission(['6', '3', '5', '2', '4']), [2, 3, 4, 5, 6]);\n  });\n\n  it('no debería mutar arreglo de entrada', () => {\n    const original = ['6', '3', '5', '2', '4'];\n    const parsed = Submission(original);\n    Assert.deepEqual(original, ['6', '3', '5', '2', '4']);\n  });\n\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "08",
          "slug": "closing",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Cierre",
              "body": "<h2>Resumen</h2>\n<p>Llegamos al final de la unidad ;-)</p>\n<p>En la programación funcional, las programadoras tienden a evitar dos hábitos\ncomunes en otros lenguajes:</p>\n<ul>\n<li><em>Mutación:</em> Cambio de los datos <em>in-situ</em> en vez de retornar un valor.</li>\n<li><em>Estado compartido:</em> Contexto extra que no se provee como argumento a la\nfunción, por ejemplo, variables globales.</li>\n</ul>\n<p>Al no depender del estado ni de las mutaciones, el comportamiento de cada\nfunción está contenido. Por lo tanto, es más sencillo realizar pruebas del\ncomportamiento de dichas funciones, entre otra serie de beneficios.</p>\n<p>Una vez dicho todo esto, existen ocasiones donde el uso de funciones puras no es\nposible, especialmente en funciones que emplean <em>side-effects</em> para llevar a\ncabo su cometido, por ejemplo el uso de promesas en JavaScript. Pero este tema,\nlo veremos en una siguiente lección.</p>\n<h2>Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Cómo evitar que nuestras funciones tengan efectos colaterales?</li>\n<li>Por qué es beneficioso evitar el estado compartido?</li>\n<li>Cuáles son las ventajas que ofrecen las funciones puras, en particular a la\nhora de hacer testing?</li>\n<li>Cómo evitar la mutación de objetos y arreglos?</li>\n<li>Qué tipos de datos son mutables e inmutables en JavaScript?</li>\n<li>Cómo usar métodos de arreglos como <code>Array#concat</code>, <code>Array#slice</code>, <code>Array#map</code>,\n<code>Array#filter</code>, ... para crear arreglos nuevos en vez de mutar (modificar)\nvalores existentes?</li>\n<li>Cómo usar métodos de objetos (por ejemplo <code>Object.assign()</code>) para copiar\npropiedades y así <em>clonar</em> objetos?</li>\n<li>Cómo usar el <em>spread operator</em> (<code>...</code>) para copiar objetos y arreglos?</li>\n</ul>"
            }
          }
        }
      ]
    },
    {
      "slug": "hof",
      "intl": {
        "es": {
          "title": "Higher Order Functions"
        }
      },
      "prefix": "03",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Apertura",
              "body": "<h2>¿Por qué aprender esto?</h2>\n<p>Las funciones de orden superior (Higher Order Functions) son simplemente\nfunciones que reciben funciones como argumentos o que devuelven una función como\nvalor de retorno. Este tipo de funciones son muy comunes en JavaScript, tanto\nen utilidades del lenguage (por ejemplo los métodos de arrays <code>map</code>, <code>filter</code> o\n<code>reduce</code>) como en <em>event handlers</em> o composición de funciones.</p>\n<p>Todo desarrollador JavaScript debe conocer en profundidad estos conceptos para\npoder desenvolverse en el lenguaje.</p>\n<h2>Guía de preguntas y conceptos clave</h2>\n<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los\nconceptos más importantes de lo que vamos a aprender y de los temas centrales\nque debemos prestar particular atención.</p>\n<p>A continuación te presentamos una serie de preguntas que debes ser capaz de\nresponder al terminar esta unidad. Utiliza estas preguntas como guía para\norientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida\nque avanzas para validar que estás avanzando en la dirección correcta. Que te\nsirva como un \"checklist\" que vas marcando a medida que vas progresando.</p>\n<ul>\n<li>Qué significa que las funciones son de primera clase en JavaScript?</li>\n<li>Qué es una función de orden superior</li>\n<li>Qué es una función de primer orden</li>\n<li>Qué es la técnica de la aplicación parcial</li>\n<li>Qué es el <em>currying</em> en programación funcional</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "hof",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Funciones de orden superior (Higher Order Functions)",
              "body": "<p>Una función de orden superior se adhiere a una definición muy específica:</p>\n<ul>\n<li>Toma una función como argumento, o ...</li>\n<li>Devuelve una función como resultado</li>\n</ul>\n<p>Veamos entonces algunos ejemplos de funciones que toman otras funciones como\nargumento, verás que este patrón es palpable en el estilo de programación\nfuncional.</p>\n<h2>Funciones que toman otras funciones</h2>\n<p>Ya has visto un montón de funciones que toman otras funciones, quizá las más\nprominentes hasta ahora son <code>map</code>, <code>reduce</code>, y <code>filter</code>. Todas estas funciones\nse adhieren a la definición de orden superior ya que reciben una función como\nargumento. Ahora exploremos este concepto en más detalle y veamos su importancia\nen el contexto de la programación funcional.</p>\n<h3>Pensando en pasar funciones: <code>max</code>, <code>finder</code> y <code>best</code></h3>\n<p>Empecemos con un ejemplo. Muchos lenguajes de programación incluyen una función\nllamada algo como <code>max</code>, que se utiliza para encontrar el valor más grande\n(generalmente de un número) en una lista o una matriz.</p>\n<p>De hecho, módulos populares como <a href=\"https://lodash.com\">Lodash</a> o\n<a href=\"http://ramdajs.com/\">Ramda</a> incluyen una función que realiza esta misma tarea:</p>\n<pre><code class=\"language-js\">const _ = require('lodash')\n\n_.max([1, 2, 3, 4, 5]);\n// => 5\n\n_.max([1, 2, 3, 4.75, 4.5])\n// => 4.75\n\nMath.max.apply(null, [1, 2, 3, 4.75, 4.5])\n// => 4.75\n\nMath.max(1, 2, 3, 4.75, 4.5)\n// => 4.75\n</code></pre>\n<p>No hay nada sorprendente en ninguno de los resultados, pero hay una limitación\nparticular en este caso de uso. Es decir, ¿qué pasa si queremos encontrar el\nvalor máximo en una matriz de objetos en lugar de números? Afortunadamente,\n<code>_.max</code> es una función de orden superior que toma un segundo argumento opcional.\nEste segundo argumento es, como habrás adivinado, una función que se utiliza\npara generar un valor numérico a partir del objeto que se le suministra. Por\nejemplo:</p>\n<pre><code class=\"language-js\">const people = [{name: \"Fred\", age: 65}, {name: \"Lucy\", age: 36}]\n\n_.max(people, p => p.age)\n// => { name: 'Fred', age: 65 }\n</code></pre>\n<p>Esta es una manera muy útil de construir funciones porque en lugar de enfocarse\nen la comparación de valores numéricos, <code>_.max</code> proporciona una forma arbitraria\nde comparar objetos. Sin embargo, esta función sigue siendo algo limitada ya que\nla comparación se hace a través del operador <em>mayor que</em> (<code>></code>).</p>\n<p>Creemos una nueva función llamada <code>finder</code> que tome dos funciones: una que\nconstruya el valor comparable y la otra que compare dos valores y retorne el\n\"mejor\" valor de los dos.</p>\n<pre><code class=\"language-js\">const finder = (valueFun, bestFun, coll) =>\n  _.reduce(coll, (best, current) => {\n    const bestValue = valueFun(best)\n    const currentValue = valueFun(current)\n    return (bestValue === bestFun(bestValue, currentValue)) ? best : current\n  })\n</code></pre>\n<p>Ahora, usando la función <code>finder</code>, la operación <code>_.max</code> se puede\nsimular de la siguiente forma:</p>\n<pre><code class=\"language-js\">finder(_.identity, Math.max, [1, 2, 3, 4, 5])\n// => 5\n</code></pre>\n<p>En este último ejemplo nota el uso de la función <code>_.identity</code>, dicha función\nsólo toma un valor y lo devuelve. Parece poco inútil, ¿verdad?, pero en el\námbito de la programación funcional es necesario pensar en términos de\nfunciones.</p>\n<p>En cualquier caso, ahora con <code>finder</code> podemos usar diferentes funciones para\nadaptarnos a cada caso:</p>\n<pre><code class=\"language-js\">const plucker = field => obj => obj &#x26;&#x26; obj[field]\n\nfinder(plucker('age'), Math.max, people)\n// => { name: 'Fred', age: 65 }\n\nfinder(plucker('name'), (x, y) => (x.charAt(0) === \"L\") ? x : y, people)\n// => { name: 'Lucy', age: 36 }\n</code></pre>\n<p>La última función filtra nombres que comiencen con la letra <code>L</code>.</p>\n<p>La implementación de <code>finder</code> es corta y funciona como esperamos, pero duplica\nalguna lógica para aportar máxima flexibilidad. Observa una similitud en la\nimplementación de <code>finder</code> y la lógica de comparación para la función de primera\nclase de <em>best-value</em>:</p>\n<pre><code class=\"language-js\">// en finder\nreturn (bestValue === bestFun(bestValue, currentValue)) ? best : current\n\n// en la función best-value\nreturn (x.charAt(0) === \"L\") ? x : y\n</code></pre>\n<p>Nota que la lógica es exactamente la misma en ambos casos. Es decir, ambos\nalgoritmos están devolviendo un valor u otro basado en cierta condición. La\nimplementación de <code>finder</code> puede ser ajustada haciendo dos suposiciones:</p>\n<ul>\n<li>La función <em>best-value</em> devuelve <code>true</code> si el primer argumento es \"mejor\" que\nel segundo argumento</li>\n<li>Que la función <em>best-value</em> sabe cómo \"descubrir\" sus argumentos</li>\n</ul>\n<p>Teniendo en cuenta estas suposiciones, se logra la siguiente implementación:</p>\n<pre><code class=\"language-js\">const best = (fun, coll) => _.reduce(coll, (x, y) => fun(x, y) ? x : y)\n\nbest((x, y) => x > y, [1, 2, 3, 4, 5])\n// => 5\n</code></pre>\n<p>Con la lógica duplicada eliminada, ahora tenemos una solución más elegante. De\nhecho, el ejemplo anterior muestra una vez más que el patrón\n<code>best((x, y) => x > y, ...)</code> proporciona la misma funcionalidad que <code>_.max</code> o\nincluso el <code>Math.max.apply(null, [1, 2, 3, 4, 5])</code>. Los programadores\nfuncionales tienden a capturar patrones como éste para crear funciones útiles.</p>\n<h2>Funciones que devuelven otras funciones</h2>\n<p>Ya hemos visto funciones que retornan otras funciones, la más reciente ha sido\n<code>plucker</code>. Como es de suponer, todas estas funciones son funciones de orden\nsuperior. Ahora hablaremos más profundamente sobre las funciones de orden\nsuperior que devuelven (y a veces también toman) funciones y cierres/closures.\nPara empezar, definamos <code>repeatedly</code>, una función que repite un cálculo\ncomputacional dado por otra función cierto número de veces.</p>\n<pre><code class=\"language-js\">const repeatedly = (times, fun) => _.map(_.range(times), fun)\n</code></pre>\n<p>Utilicemos una función que ignore sus argumentos y en su lugar devuelve una\nconstante y con ella alimentemos a <code>repeatedly</code>:</p>\n<pre><code class=\"language-js\">repeatedly(3, () => \"Odelay!\")\n// => [\"Odelay!\", \"Odelay!\", \"Odelay!\"]\n</code></pre>\n<p>El uso de una función que devuelve una constante es tan útil que es casi un\npatrón de diseño para la programación funcional y a menudo se llama simplemente\n<code>k</code>. Sin embargo, en aras de la claridad, lo llamaremos <code>always</code>; Se implementa\nde la siguiente manera:</p>\n<pre><code class=\"language-js\">const always = value => () => value\n</code></pre>\n<p>La operación <code>always</code> es útil para ilustrar algunos puntos sobre\nclosures/cierres. Primero, un cierre captura un solo valor (o referencia) y\ndevuelve repetidamente el mismo valor:</p>\n<pre><code class=\"language-js\">let f = always(function(){})\n\nf() === f()\n// => true\n</code></pre>\n<p>Debido a que la función <code>always</code> produce un valor único, se puede ver que desde\nuna invocación de <code>always</code> a otra, la función capturada vinculada a <code>value</code> es\nsiempre la misma.</p>\n<p>Cualquier función creada con <code>function</code> devolverá una instancia única,\nindependientemente del contenido de su cuerpo. El uso de <code>(function () {})</code> es\nuna forma rápida de garantizar que se generan valores únicos. Teniendo esto en\nmente, una segunda nota importante acerca de los cierres es que cada nuevo\ncierre captura un valor diferente que todos los demás:</p>\n<pre><code class=\"language-js\">let g = always(function(){})\n\nf() === g()\n// => false\n</code></pre>\n<p>Mantener estas dos reglas en mente al usar closures/cierres ayudará a evitar la\nconfusión.</p>\n<p>Continuemos con el ejemplo y reemplacemos la función anónima que usamos\npreviamente con <code>always</code>:</p>\n<pre><code class=\"language-js\">repeatedly(3, always(\"Odelay!\"))\n// => [\"Odelay!\", \"Odelay!\", \"Odelay!\"]\n</code></pre>\n<p>La función <code>always</code> es lo que se conoce como un combinador. Esta lección no se\ncentrará en gran medida en los combinadores, aunque verás que se utilizan en\nbases de código construido en un estilo funcional.</p>\n<p>Antes de seguir adelante, mostraremos la implementación de otra función que\nretorna otra función, <code>invoker</code>, que toma un método y devuelve una función que\ninvocará ese método en cualquier objeto dado. Observalo a continuación:</p>\n<pre><code class=\"language-js\">// Helpers\nconst existy = x => x != null\nconst truthy = x => (x !== false) &#x26;&#x26; existy(x)\nconst doWhen = (cond, action) => truthy(cond) ? action() : undefined\n\nconst fail = thing => {\n  throw new Error(thing)\n}\n\nconst invoker = (name, method) =>\n  (target, ...args) => {\n    if (!existy(target)) {\n      fail(\"Must provide a target\")\n    }\n\n    const targetMethod = target[name]\n\n    return doWhen((existy(targetMethod) &#x26;&#x26; method === targetMethod), () =>\n      targetMethod.apply(target, args)\n   )\n  }\n</code></pre>\n<p>La forma de <code>invoker</code> es muy similar a <code>always</code>, es decir, es una función que\ndevuelve una función que utiliza un argumento original, <code>method</code>, durante una\ninvocación posterior. La función devuelta en este caso es un closure/cierre.\nSin embargo, en lugar de devolver una constante, <code>invoker</code> realiza alguna\nacción especializada basada en el valor de la llamada original. El uso del\n<code>invoker</code> es el siguiente:</p>\n<pre><code class=\"language-js\">const rev = invoker('reverse', Array.prototype.reverse)\n\n_.map([[1, 2, 3]], rev)\n// => [[3, 2, 1]]\n</code></pre>\n<p>Si bien es perfectamente legítimo invocar directamente un método sobre una\ninstancia, en estilo funcional preferimos las funciones que se centran en la\naplicación de argumentos.</p>\n<h2>Referencias</h2>\n<ul>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\">Functional JavaScript</a> de\nMichael Fogus</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "practice",
          "type": "practice",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Ejercicios de Higher Order Functions",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "repeat",
              "prefix": "01",
              "path": "topics/functional/03-hof/02-practice/01-repeat",
              "createdAt": "2024-06-21T17:34:26.947Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Repite una operación n número de veces",
                  "body": "<p>Una función de orden superior (higher-order function) es una función que cumple\npor lo menos una de estas condiciones:</p>\n<ul>\n<li>Recibe una o más funciones como input</li>\n<li>Devuelve una función</li>\n</ul>\n<p>Todas las demás funciones son de primer orden (first order functions). [1]</p>\n<p>A diferencia de muchos otros lenguajes con características imperativas,\nJavaScript nos permite usar higher-order functions ya que tiene funciones\n\"first-class\". Lo que significa que las funciones pueden ser tratadas como\ncualquier otro valor en JavaScript: igual que Strings o Numbers, valores de tipo\nFunction pueden ser almacenados en variables, propiedades de objetos o pasados\na otras funciones como argumentos. Los valores de tipo Function de hecho son\nObjects (que heredan de <code>Function.prototype</code>), así que podemos incluso añadir\npropiedades y asignar valores igual que en cualquir otro objeto.</p>\n<p>La principal diferencia entre las funciones y el resto de valores en JavaScript\nes la sintáxis de invocación: si una referencia a una función está seguida de\nparéntesis y opcionalmente una lista de argumentos separados por comas:\n<code>someFunctionValue(arg1, arg2, etc)</code>, entonces el cuerpo de la función será\nejecutada con los argumentos pasados (si hubiere).</p>\n<p>En este ejercicio vamos a demostrar que las funciones pueden ser pasadas como\nvalores. Te vamos a pasar una función como argumento.</p>\n<h2>Tarea</h2>\n<p>Implementa una función que reciba una función como primer argumento, y un número\n<code>num</code> como segundo argumento. La función debe ejecutar la función <code>num</code> veces.</p>\n<p>Usa el boilerplate provisto para empezar. Todos (o casi todos) los ejercicios\nincluirán un boilerplate.</p>\n<h2>Argumentos</h2>\n<ul>\n<li>operation: Una función, no recibe argumentos, no retorna ningún valor útil.</li>\n<li>num: el número de veces que queremos invocar <code>operation</code></li>\n</ul>\n<h2>Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions_and_function_scope\">MDN - Functions and function scope</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\">MDN - Function.prototype</a></li>\n</ul>\n<h2>Pistas</h2>\n<ul>\n<li>No lo des demasiadas vueltas, el código debe ser muy simple.</li>\n<li>No pasa nada si usas un loop. Bonus para quien implemente usando recursión.</li>\n<li>No tienes que usar console.log para nada.</li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/repeat.js": "function repeat(operation, num) {\n  // TÚ SOLUCIÓN AQUÍ\n}\n\n// No borres la línea de abajo\nmodule.exports = repeat;\n",
                "/solution/repeat.js": "function repeat(operation, num) {\n  if (!num) {\n    return;\n  }\n  operation();\n  repeat(operation, num - 1);\n}\n\n// No borres la línea de abajo\nmodule.exports = repeat;\n",
                "/test/repeat.spec.js": "const Assert = require('chai').assert;\nconst Submission = require('../solution/repeat');\n\n\ndescribe('repeat()', () => {\n\n  it('debería invocar la función 5 veces cuando n es 5', () => {\n    let calls = 0;\n    const fn = () => calls++;\n    Submission(fn, 5);\n    Assert.equal(calls, 5);\n  });\n\n  it('debería invocar la función 8 veces cuando n es 8', () => {\n    let calls = 0;\n    const fn = () => calls++;\n    Submission(fn, 8);\n    Assert.equal(calls, 8);\n  });\n\n  it('no debería invocar la función cuando n es 0', () => {\n    let calls = 0;\n    const fn = () => calls++;\n    Submission(fn, 0);\n    Assert.equal(calls, 0);\n  });\n\n  it('debería retornar undefined', () => {\n    const fn = () => true;\n    Assert.equal(Submission(fn, 5), undefined);\n  });\n\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "03",
          "slug": "partial-application",
          "type": "read",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Aplicación parcial",
              "body": "<p>Quizá la mejor manera de explicar este concepto es verlo directamente en acción.\nImagina la siguiente función:</p>\n<pre><code class=\"language-js\">const greetPart = greeting => name => `${greeting}, ${name}`\n\nconst greetHello = greetPart('Hello')\n\ngreetHello('Heidi')\n// => 'Hello, Heidi'\n</code></pre>\n<p>La función <code>greetPart()</code> recibe un argumento (<code>greeting</code>) y retorna una función,\nque a su vez recibe un argumento (<code>name</code>) y retorna un string. Al invocar\n<code>greetPart('Hello')</code> estamos parcialmente aplicando el primer argumento\n(<code>greeting</code>), para más tarde invocar <code>greetHello()</code> con el argumento que falta\n(<code>name</code>).</p>\n<p>Las funciones parcialmente aplicadas no necesariamente interactuan con un\nargumento a la vez, pueden interactuar con cualquier número de argumentos\nparcialmente aplicados que son almacenados para su posterior ejecución.</p>\n<h2>Aplicación parcial sobre uno y dos argumentos conocidos</h2>\n<p>Podríamos crear una función que nos permita aplicar parcialmente un argumento\na cualquier función que espere más de un argumento. Considera el siguiente\ncódigo:</p>\n<pre><code class=\"language-js\">// Función que espera más de un argumento\nconst greet = (greeting, name) => `${greeting}, ${name}`\n\n// Utilidad para aplicar parcialmente primer argumento\nconst partial1 = (fun, arg1) =>\n  (...args) => {\n    const params = Array.prototype.concat(arg1, args)\n    return fun.apply(fun, params)\n  }\n\n// Aplica parcialmente 'Hello' como primer argumento de `greet`\nconst greetHello = partial1(greet, 'Hello')\n\ngreetHello('Heidi')\n// => 'Hello, Heidi'\n</code></pre>\n<p><strong>NOTA</strong>: También es posible utilizar <code>Function.prototype.bind()</code> para\nimplementar <code>partial1</code> reemplazando su cuerpo por <code>fun.bind(null, arg1)</code></p>\n<p>De nuevo hemos logrado recrear la operación de la función <code>greetHello</code> al\ncomponer una función a partir de otra dado un argumento previo de\n\"configuración\". De igual manera pudimos haber hecho lo siguiente:</p>\n<pre><code class=\"language-js\">const partial2 = (fun, arg1, arg2) =>\n  (...args) => {\n    const params = Array.prototype.concat(arg1, arg2, args)\n    return fun.apply(fun, params)\n  }\n\nconst greetHelloHeidi = partial2(greet, 'Hello', 'Heidi')\n\ngreetHelloHeidi()\n// => 'Hello, Heidi'\n</code></pre>\n<h2>Aplicación parcial sobre un número arbitrario de argumentos</h2>\n<p>La aplicación parcial de un número arbitrario de argumentos es ciertamente una\nestrategia de composición. Afortunadamente, la implementación de la función\n<code>partial</code> no es significativamente más compleja que <code>partial1</code> y <code>partial2</code>. De\nhecho, aplicaremos la misma base:</p>\n<pre><code class=\"language-js\">const partial = (fun, ...args) =>\n  (...newArgs) => {\n    const params = Array.prototype.concat(args, newArgs)\n    return fun.apply(fun, params)\n  }\n\nconst greeter = (greeting, separator, emphasis, name) =>\n  `${greeting}${separator}${name}${emphasis}`\n\nconst greetHello = partial(greeter, 'Hello', ', ', '.')\n\ngreetHello('Heidi')\n// => 'Hello, Heidi.'\n</code></pre>\n<p>Como pudiste notar, el principio es el mismo, <code>partial</code> captura cierto número\nde argumentos y retorna una función que los usa como argumentos prefijo para su\nllamada final.</p>\n<p>Es importante hacer mencionar que podemos realizar aplicación parcial de manera\nsucinta por medio de <code>bind</code>, por ejemplo:</p>\n<pre><code class=\"language-js\">const greeter = (greeting, separator, emphasis, name) =>\n  `${greeting}${separator}${name}${emphasis}`\n\nconst greetHello = greeter.bind(null, 'Hello', ', ', '.')\n\ngreetHello('Heidi')\n// => 'Hello, Heidi.'\n</code></pre>\n<p>Finalmente, es importante mencionar que en este caso la función que estamos\nparcialmente aplicando espera un número fijo de argumentos, el hecho que pueda\naceptar cualquier cantidad de argumentos a veces puede causar confusión, fijate\nen el siguiente ejemplo:</p>\n<pre><code class=\"language-js\">greeter.bind(null, 'Hello', ', ', '.', 'Heidi', 'how', 'are', 'you', '?')()\n// => 'Hello, Heidi.'\n</code></pre>\n<p>Nuestra función <code>greeter</code> espera 4 argumentos, en este caso el resto de los\nargumentos pasados simplemente son ignorados.</p>\n<h2>Referencias</h2>\n<ul>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\">Functional JavaScript</a> de\nMichael Fogus</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\">Array.prototype.concat()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">Function.prototype.bind()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\">Function.prototype.apply()</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "practice-2",
          "type": "practice",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Ejercicios de aplicación parcial",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "bound-logger",
              "prefix": "01",
              "path": "topics/functional/03-hof/04-practice-2/01-bound-logger",
              "createdAt": "2024-06-21T17:34:26.948Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "With bind",
                  "body": "<p><strong>Usa Function#bind</strong> para implementar una función <code>logger</code> que nos permita\nseparar mensajes en diferentes ámbitos (namespaces).</p>\n<p>Tu implementación debe exportar dos funciones con las siguientes <em>firmas</em>:</p>\n<ul>\n<li><code>log(str1, str2, str3, ...)</code>: Retorna un string con los strings de entrada\nconcatenados y separados por espacios.</li>\n<li><code>logger(namespace)</code>: Retorna una función que combina un se comporta como <code>log</code>\npero siempre añade <code>namespace</code> al principio.</li>\n</ul>\n<p>Asegúrate de que la función que retorne <code>logger</code> haga uso de <em>todos</em> los\nargumentos que le pasen.</p>\n<h2>Ejemplo</h2>\n<pre><code class=\"language-js\">const { logger } = require('./tu-modulo');\n\nconst info = logger('INFO:')\ninfo('this is an info message')\n// => 'INFO: this is an info message'\n\nconst warn = logger('WARN:')\nwarn('this is a warning message', 'with more info')\n// => 'WARN: this is a warning message with more info'\n</code></pre>\n<h2>Requisitos</h2>\n<ul>\n<li>Usar <code>Function#bind</code></li>\n<li>La función <code>logger()</code> debe hacer uso de <code>log</code>.</li>\n</ul>\n<h2>Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">Function.bind</a></li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/boundLogger.js": "exports.log = null;\n\nexports.logger = null;\n",
                "/solution/boundLogger.js": "exports.log = (...args) => args.join(' ');\n\nexports.logger = namespace => exports.log.bind(null, namespace);\n",
                "/test/boundLogger.spec.js": "const Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/boundLogger');\n\n\ndescribe('with bind', () => {\n\n  it('debería exportar log() y logger()', () => {\n    Assert.equal(typeof Submission.log, 'function');\n    Assert.equal(typeof Submission.logger, 'function');\n  });\n\n  describe('log()', () => {\n\n    [\n      [['foo'], 'foo'],\n      [['foo', 'foo'], 'foo foo'],\n      [['foo', 'bar', 'baz'], 'foo bar baz'],\n      [['foo', 'bar', 'baz', 1, 2, 3], 'foo bar baz 1 2 3'],\n    ].forEach(pair => {\n      it(`debería retornar \"${pair[1]}\" para [${pair[0]}]`, () => {\n        Assert.equal(Submission.log.apply(null, pair[0]), pair[1]);\n      });\n    });\n\n  });\n\n  describe('logger()', () => {\n\n    it('debería combinar namespace + 1 string', () => {\n      const info = Submission.logger('INFO:');\n      Assert.equal(info('this is an info message'), 'INFO: this is an info message');\n    });\n\n    it('debería combinar namespace + 2 strings', () => {\n      const warn = Submission.logger('WARN:');\n      Assert.equal(\n        warn('this is a warning message', 'with more info'),\n        'WARN: this is a warning message with more info'\n      );\n    });\n\n    it('debería usar Function.prototype.bind', () => {\n      const spy = Sinon.spy(Function.prototype, 'bind');\n      Submission.logger('ERROR:')('foo');\n      Assert.equal(spy.callCount, 1);\n      Assert.equal(spy.args[0][0], null);\n      Assert.equal(spy.args[0][1], 'ERROR:');\n      spy.restore();\n    });\n\n  });\n\n})\n"
              }
            },
            {
              "slug": "logger",
              "prefix": "02",
              "path": "topics/functional/03-hof/04-practice-2/02-logger",
              "createdAt": "2024-06-21T17:34:26.947Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Without bind",
                  "body": "<p>La aplicación parcial nos permite crear nuevas funciones a partir de funciones\nexistentes, a la vez que fijamos algunos argumentos. Despues de fijar los\nargumentos para ser parcialmente aplicados, tenemos una nueva función lista para\nrecibir el resto de los argumentos y quizás ejecutar la función original.</p>\n<p>Más formalmente: La aplicación parcial hace referencia al proceso de fijar un\nnúmero de argumentos a una función, produciendo otra de menor \"arity\".</p>\n<h2>Tarea</h2>\n<p>Usa aplicación parcial para crear una función <code>logger</code> que añada un \"namespace\"\n(un string) al principio del resultado.</p>\n<p>Tu implementación debe recibir un string <code>namespace</code> y retornar una función que\ncombine mensajes separados por espacios con el namespace al principio.</p>\n<p>Asegúrate de que la función que retorne <code>logger</code> haga uso de <em>todos</em> los\nargumentos que le pasen.</p>\n<h2>Argumentos</h2>\n<ul>\n<li>namespace: un String con el nombre del namespace.</li>\n</ul>\n<h2>Ejemplo</h2>\n<pre><code class=\"language-js\">const info = logger('INFO:')\ninfo('this is an info message')\n// INFO: this is an info message\n\nconst warn = logger('WARN:')\nwarn('this is a warning message', 'with more info')\n// WARN: this is a warning message with more info\n</code></pre>\n<h2>Requisitos</h2>\n<ul>\n<li>No uses <code>Function#bind</code> ni <code>Function#apply</code></li>\n</ul>\n<h2>Recursos</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Partial_application\">Wikipedia - Partial application</a></li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/logger.js": "const logger = null;\n\nmodule.exports = logger;\n",
                "/solution/logger.js": "const logger = namespace => (...args) => `${namespace} ${args.join(' ')}`;\n\nmodule.exports = logger;\n",
                "/test/logger.spec.js": "const Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/logger');\n\n\ndescribe('logger()', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería combinar namespace + 1 string', () => {\n    const info = Submission('INFO:');\n    Assert.equal(info('this is an info message'), 'INFO: this is an info message');\n  });\n\n  it('debería combinar namespace + 2 strings', () => {\n    const warn = Submission('WARN:');\n    Assert.equal(\n      warn('this is a warning message', 'with more info'),\n      'WARN: this is a warning message with more info'\n    );\n  });\n\n  it('no debería usar Function.prototype.bind', () => {\n    const spy = Sinon.spy(Function.prototype, 'bind');\n    Submission('ERROR:')('foo');\n    Assert.equal(spy.callCount, 0);\n    spy.restore();\n  });\n\n})\n"
              }
            }
          ]
        },
        {
          "prefix": "05",
          "slug": "currying",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Aplicando curry en JavaScript funcional",
              "body": "<p>La técnica de definir funciones atadas a múltiples parámetros como una serie de\nfunciones anidadas que solo esperan un parámetro fue popularizada por el\nmatemático <a href=\"https://en.wikipedia.org/wiki/Haskell_Curry\">Haskell Curry</a>, aunque inicialmente observada por <a href=\"https://en.wikipedia.org/wiki/Gottlob_Frege\">Frege</a> en\n1893, a dicha cadena de funciones anidadas se les llama funciones curry o\n<em>curried functions</em>.</p>\n<h2>¿Qué es <em>currying</em>?</h2>\n<p>En pocas palabras, <em>currying</em> es una técnica que traduce la evaluación de una\nfunción que toma múltiples argumentos en una evaluación de una secuencia de\nfunciones, cada una de funciones de la secuencia espera un único argumento.\n<em>Currying</em> está relacionado con el concepto de <a href=\"https://en.wikipedia.org/wiki/Partial_application\">aplicación\nparcial</a>, pero no es lo mismo.</p>\n<p>Una función curry es una que retorna progresivamente una función más específica\npor cada uno de los argumentos dados hasta que ya no sean necesarios más\nparámetros. Una función parcialmente aplicada, por otra parte, es una función\nque es \"parcialmente\" ejecutada y está lista para su inmediata ejecución una vez\ndado el resto de los parámetros esperados.</p>\n<p>El <em>currying</em> es elemental en la mayoría de los lenguajes de programación\nfuncional, por ejemplo Haskell o Scala. A pesar que JavaScript ofrece soporte\npara algunas características funcionales, al menos en las versiones actuales, el\n<em>currying</em> no es una de ellas. Sin embargo, podemos <em>emular</em> este patrón con las\ncaracterísticas actuales del lenguaje.</p>\n<p>Para darte una idea de cómo este concepto podría funcionar, vamos a crear\nnuestra primera función <em>curry</em> en JavaScript, utilizando la sintaxis familiar\npara construir la funcionalidad <em>currying</em> que queremos. Como ejemplo,\nimaginemos una función que salude a alguien por su nombre. Todos sabemos cómo\ncrear una función simple de saludo que toma un nombre y un saludo, y registra el\nsaludo con el nombre:</p>\n<pre><code class=\"language-js\">const greet = (greeting, name) => `${greeting}, ${name}`\n\ntest('Should say Hello', () => {\n  expect(greet('Hello', 'Heidi')).toBe('Hello, Heidi')\n})\n</code></pre>\n<p>Esta función requiere que el nombre y el saludo se pasen como argumentos para\nque funcione correctamente. Pero podríamos reescribir la función usando\n<em>currying</em> anidado simple, de modo que la función básica sólo requiera un\nsaludo, y devuelve otra función que toma el nombre de la persona que queremos\nsaludar.</p>\n<h2>Nuestro primer <em>curry</em></h2>\n<pre><code class=\"language-js\">const greetCurried = greeting => name => `${greeting}, ${name}`\n</code></pre>\n<p>Este pequeño ajuste a la forma en que escribimos la función anterior nos permite\ncrear una nueva función para cualquier tipo de saludo, y pasar a esa nueva\nfunción el nombre de la persona que queremos saludar:</p>\n<pre><code class=\"language-js\">test('Should allow to reuse functions', () => {\n  const greetHello = greetCurried('Hello')\n\n  expect(greetHello('Heidi')).toBe('Hello, Heidi')\n  expect(greetHello('Eddie')).toBe('Hello, Eddie')\n})\n</code></pre>\n<p>También podemos llamar a la función en modo <em>curry</em> original directamente,\nsimplemente pasando cada uno de los parámetros en un conjunto separado de\nparéntesis, uno después del otro:</p>\n<pre><code class=\"language-js\">test('Should work with all the parameters', () => {\n  expect(greetCurried('Hi there')('Howard')).toBe('Hi there, Howard')\n})\n</code></pre>\n<h2>Apliquemos <em>curry</em> a todo</h2>\n<p>Lo bueno es que ahora que hemos aprendido a modificar nuestra función\ntradicional para usar este enfoque para manejar los argumentos, podemos hacerlo\ncon tantos argumentos como queramos:</p>\n<pre><code class=\"language-js\">const greetDeeplyCurried = greeting =>\n  separator =>\n    emphasis =>\n      name =>\n        `${greeting}${separator}${name}${emphasis}`\n</code></pre>\n<p>Tenemos la misma flexibilidad con cuatro argumentos que con dos. No importa lo\nlejos que vaya el anidamiento, podemos crear nuevas funciones personalizadas\npara saludar a tantas personas como escojamos de tantas maneras como nos\nconvenga:</p>\n<pre><code class=\"language-js\">test('Should allow nested calls', () => {\n  const greetAwkwardly = greetDeeplyCurried('Hello')('...')('?')\n\n  expect(greetAwkwardly('Heidi')).toBe('Hello...Heidi?')\n  expect(greetAwkwardly('Eddie')).toBe('Hello...Eddie?')\n})\n</code></pre>\n<p>Además, podemos pasar tantos parámetros como quisiéramos al crear variaciones\npersonalizadas de nuestra función <em>curry</em> original, creando nuevas funciones que\nson capaces de tomar el número apropiado de parámetros adicionales, cada uno se\npasa por separado en su propio conjunto de paréntesis:</p>\n<pre><code class=\"language-js\">test('Other variations', () => {\n  const sayHello = greetDeeplyCurried('Hello')(', ')\n\n  expect(sayHello('.')('Heidi')).toBe('Hello, Heidi.')\n  expect(sayHello('.')('Eddie')).toBe('Hello, Eddie.')\n</code></pre>\n<p>Y se pueden definir variaciones subordinadas:</p>\n<pre><code class=\"language-js\">  const askHello = sayHello('?')\n\n  expect(askHello('Heidi')).toBe('Hello, Heidi?')\n  expect(askHello('Eddie')).toBe('Hello, Eddie?')\n})\n</code></pre>\n<h2>Aplicando <em>curry</em> a funciones tradicionales</h2>\n<p>Puedes ver lo poderoso que es este enfoque, especialmente si necesitas crear\nmuchas funciones personalizadas muy detalladas. El único problema es la\nsintaxis, pues a medida que construyes estas funciones con <em>curry</em>, debes\nmantener las funciones devueltas anidadas, y llamarlas con nuevas funciones que\nrequieran varios conjuntos de paréntesis, cada uno conteniendo su propio\nargumento aislado. Se puede poner difícil y enredado.</p>\n<p>Antes de abordar la implementación de nuestra función <em>curry</em>, consideremos por\nejemplo que para toda función <code>f(x, y)</code>, existe una función <code>f'</code> tal que\n<code>f'(x)</code> es una función que puede ser aplicada a <code>y</code> que obtenga\n<code>(f'(x))(y) = f(x, y)</code>.</p>\n<p>La función <code>f'</code> del ejemplo anterior es llamada forma <em>curried</em> de la función.\nDesde una perspectiva de programación funcional, <em>currying</em> puede ser descrita\npor la función: <code>curry : ((a, b) -> c) -> (a -> b -> c)</code></p>\n<p>Ahora bien, un enfoque es crear una <strong>función de orden superior</strong> (<em>Higher\nOrder Function</em> en inglés) que tome como argumento una función existente que\nfue escrita sin todas las devoluciones anidadas (<em>uncurried form</em>). Nuestra\nfunción de orden superior debe retornar otra función que espera un solo\nargumento,...</p>\n<pre><code class=\"language-js\">const curryIt = f => x => {\n  // ...\n}\n</code></pre>\n<p>Luego que se suministra dicho argumento se procede a verificar si el número de\nargumentos esperados (<code>Function.length</code>) por la función <em>uncurried</em> es igual o\nmenor a 1, de ser así ejecuta dicha función, esta condición particular también\nnos servirá como condición de parada en nuestra llamada recursiva.</p>\n<pre><code class=\"language-js\">const curryIt = f => x => {\n  if (f.length &#x3C;= 1) {\n    f(x)\n  } else {\n    // ...\n  }\n}\n</code></pre>\n<p>En cambio, si el número de parámetros esperados es mayor a 1 debemos recurrir a\nla recursión y aplicar de nuevo nuestra función de orden superior, en este\núltimo caso pasaremos como argumento una nueva función equivalente, por medio\nde <code>Function.prototype.bind()</code>, a la función <em>uncurried</em> excepto por su\nparámetro inicial. Algo similar a los siguiente:</p>\n<pre><code class=\"language-js\">// función uncurried\nconst greet = (greeting, name) => `${greeting}, ${name}`\n// función equivalente a excepción del argumento inicial\nconst greetWithGreeting = greet.bind(null, 'Hello') // [Function: bound greet]\ngreetWithGreeting('Heidi')\n// => 'Hello, Heidi'\n</code></pre>\n<p>Sin mayor preámbulo veamos el resultado final de nuestra función <code>curryIt</code>:</p>\n<pre><code class=\"language-js\">const curryIt = f => x => f.length &#x3C;= 1 ? f(x) : curryIt(f.bind(null, x))\n</code></pre>\n<p>Para usar esto, le pasamos una referencia a una función que toma cualquier\nnúmero de argumentos, junto con tantos de los argumentos como queremos\npre-poblar. Lo que recuperamos es una función que está a la espera de los\nargumentos restantes:</p>\n<pre><code class=\"language-js\">const greeter = (greeting, separator, emphasis, name) =>\n  `${greeting}${separator}${name}${emphasis}`\n\ntest('should return a curried equivalent of the provided function', () => {\n  const greetHello = curryIt(greeter)('Hello')(', ')('.')\n\n  expect(greetHello('Heidi')).toBe('Hello, Heidi.')\n  expect(greetHello('Eddie')).toBe('Hello, Eddie.')\n</code></pre>\n<p>Y al igual que antes, no estamos limitados en términos del número de argumentos\nque queremos utilizar al construir funciones derivadas de nuestra función\noriginal que usa <em>curry</em>:</p>\n<pre><code class=\"language-js\">  const greetGoodbye = curryIt(greeter)('Goodbye')(', ')\n\n  expect(greetGoodbye('.')('Joe')).toBe('Goodbye, Joe.')\n})\n</code></pre>\n<h2>Siendo serios sobre <em>curry</em></h2>\n<p>Nuestra pequeña función <code>curryIt</code> no puede manejar todos los casos de borde,\ncomo los parámetros faltantes u opcionales, pero hace un trabajo razonable\nsiempre y cuando permanezcamos estrictos sobre la sintaxis para pasar\nargumentos.</p>\n<p>Algunas bibliotecas funcionales de JavaScript como <a href=\"http://ramdajs.com/\">Ramda</a> tienen funciones de\n<em>curry</em> más flexibles que pueden dividir los parámetros requeridos para una\nfunción y permiten pasarlos individualmente o en grupos para crear variaciones\n<em>curry</em> personalizadas. Si deseas aplicar <em>curry</em> extensivamente, este es\nprobablemente el camino a seguir.</p>\n<p>Independientemente de cómo elijas añadir <em>curry</em> a tu programación, ya sea que\ndesee utilizar paréntesis anidados o prefieras incluir una función de transporte\nmás robusta, llegar a una convención de nomenclatura coherente para sus\nfunciones <em>curry</em> ayudará a hacer tu código más legible. Te recomiendo que cada\nvariación derivada de una función tenga un nombre que deje claro cómo se\ncomporta, y qué argumentos está esperando.</p>\n<h2>Orden de los argumentos</h2>\n<p>Una cosa que es importante tener en cuenta al momento de implementar <em>curry</em> es\nel orden de los argumentos. Usando el enfoque que hemos descrito, obviamente lo\nque tú deseas es que el argumento que es más probable que sea reemplazado de\nuna variación a la siguiente sea el último argumento pasado a la función\noriginal.</p>\n<p>Pensar con antelación sobre el orden de los argumentos hará que sea más fácil\ndiseñar un algoritmo para ser implementado con <em>curry</em>  y aplicarlo a tu\ntrabajo. Tener en cuenta el orden de tus argumentos en términos de menor a mayor\nprobabilidades de cambiar es un buen hábito al momento de diseñar funciones.</p>\n<h2>Conclusión</h2>\n<p><em>Curry</em> es una técnica increíblemente útil en JavaScript funcional. Te permitirá\ngenerar una biblioteca de funciones pequeñas y fácilmente configuradas que se\ncomportan consistentemente, son rápidas de usar y que se pueden entender al leer\nsu código. Agregar <em>curry</em> a tu práctica de codificación alentará el uso de\nfunciones parcialmente aplicadas a través de tu código, evitando una gran\ncantidad de repeticiones, y puede ayudarte a obtener mejores hábitos sobre cómo\nnombrar y manejar los argumentos de la función.</p>\n<h2>Referencias</h2>\n<ul>\n<li><a href=\"https://www.sitepoint.com/currying-in-functional-javascript/\">A Beginner’s Guide to Currying in Functional JavaScript</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">Function.prototype.bind()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\">Function.length</a></li>\n<li><a href=\"http://www.cs.nott.ac.uk/~pszgmh/faq.html#currying\">Frequently Asked Questions for comp.lang.functional</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=iZLP4qOwY8I\">Currying - Part 6 of Functional Programming in JavaScript</a>\npor Mattias P Johansson</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "06",
          "slug": "practice-3",
          "type": "practice",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Ejercicios de currying",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "curry-n",
              "prefix": "01",
              "path": "topics/functional/03-hof/06-practice-3/01-curry-n",
              "createdAt": "2024-06-21T17:34:26.947Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "curryN",
                  "body": "<p>Este es un ejemplo de implementación usando <code>curry3</code>, el cual tiene capacidad de\nmanejar hasta tres argumentos:</p>\n<pre><code class=\"language-js\">function curry3(fun) {\n  return function(one) {\n    return function(two) {\n      return function (three) {\n        return fun(one, two, three)\n      }\n    }\n  }\n}\n</code></pre>\n<p>Si la fuesemos a implementar con la función ejemplo:</p>\n<pre><code class=\"language-js\">function abc(one, two, three) {\n  return one/two/three\n}\n</code></pre>\n<p>Se vería de la siguiente manera:</p>\n<pre><code class=\"language-js\">const curryC = curry3(abc)\nconst curryB = curryC(6)\nconst curryA = curryB(3)\n\nconsole.log(curryA(2)) // => 1\n</code></pre>\n<h2>Tarea</h2>\n<p>En este reto, vamos a implementar la función 'curry' para un número arbitrario\nde argumentos.</p>\n<p><code>curryN</code> recibe dos parámetros:</p>\n<ul>\n<li>fn: la función a la que le queremos añadir <em>curry</em>.</li>\n<li>n: número opcional de argumentos para <em>curry</em>. Si no se suministra, entonces\n<code>curryN</code> debe usar la aridad de <code>fn</code> como el valor para <code>n</code>.</li>\n</ul>\n<h2>Ejemplo</h2>\n<pre><code class=\"language-js\">function add3(one, two, three) {\n  return one + two + three\n}\n\nconst curryC = curryN(add3)\nconst curryB = curryC(1)\nconst curryA = curryB(2)\nconsole.log(curryA(3)) // => 6\nconsole.log(curryA(10)) // => 13\n\nconsole.log(curryN(add3)(1)(2)(3)) // => 6\n</code></pre>\n<h2>Condiciones</h2>\n<ul>\n<li>No usar lazos for/while o <code>Array.prototype.forEach</code>.</li>\n</ul>\n<h2>Pista</h2>\n<ul>\n<li>Se puede detectar el número esperado de argumentos de una función (su aridad)\nrevisando la propiedad .length de la función.</li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/curryN.js": "function curryN(fn, n) {\n  // La solución vá aquí,\n}\n\nmodule.exports = curryN\n",
                "/solution/curryN.js": "function curryN(fn, n) {\n  n = n || fn.length\n  return function curriedN(arg) {\n    if (n <= 1) return fn(arg)\n    return curryN(fn.bind(this, arg), n - 1)\n  }\n}\n\nmodule.exports = curryN\n",
                "/test/curryN.spec.js": "const Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/curryN');\n\n\ndescribe('curryN()', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería crear cadena de funciones hasta haber agotado todos los argumentos', () => {\n    function add3(one, two, three) {\n      return one + two + three;\n    }\n\n    const curryC = Submission(add3);\n    const curryB = curryC(1);\n    const curryA = curryB(2);\n\n    Assert.equal(curryA(3), 6);\n    Assert.equal(curryA(10), 13);\n\n    Assert.equal(Submission(add3)(1)(2)(3), 6);\n  });\n\n  it('no debería usar bucles for/while', () => {\n    const fnBody = Submission.toString();\n    Assert.equal(/(for|while)\\s*\\(/g.test(fnBody), false);\n  });\n\n  it('no debería usar forEach', () => {\n    function add3(one, two, three) {\n      return one + two + three;\n    }\n\n    const spy = Sinon.spy(Array.prototype, 'forEach');\n\n    Assert.equal(Submission(add3)(1)(2)(3), 6);\n    Assert.equal(spy.callCount, 0);\n    spy.restore();\n  });\n\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "10",
          "slug": "closing",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Cierre",
              "body": "<h2>Resumen</h2>\n<p>En esta unidad hemos hablado de funciones de orden superior, las cuales son\nfunciones de primera clase que también realizan una o ambas de las siguientes\ntareas:</p>\n<ul>\n<li>Tomar una función como argumento</li>\n<li>Devolver una función como valor de retorno</li>\n</ul>\n<p>Para ilustrar el pase de una función a otra, se dieron algunos ejemplos,\nincluyendo <code>max</code>, <code>finder</code>, <code>best</code>, <code>repeatedly</code>. Muy a menudo, pasar valores a\nfunciones para lograr algún comportamiento es valioso, pero a veces tal tarea\npuede hacerse más genérica al pasar una función.</p>\n<p>La cobertura de las funciones que devuelven otras funciones comenzó con el\nsiempre valioso <code>always</code>. Una característica interesante de <code>always</code> es que\ndevolvió un closure/cierre, una técnica que verás una y otra vez en JavaScript.\nAdemás, las funciones que devuelven funciones permiten crear funciones\npotentes.</p>\n<h2>Respondamos juntxs las preguntas de la apertura</h2>\n<ul>\n<li>Qué significa que las funciones son de primera clase en JavaScript?</li>\n<li>Qué es una función de orden superior</li>\n<li>Qué es una función de primer orden</li>\n<li>Qué es la técnica de la aplicación parcial</li>\n<li>Qué es el <em>currying</em> en programación funcional</li>\n</ul>"
            }
          }
        }
      ]
    },
    {
      "slug": "flow-control",
      "intl": {
        "es": {
          "title": "Control de flujo"
        }
      },
      "prefix": "05",
      "parts": [
        {
          "prefix": "00",
          "slug": "opening",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Apertura",
              "body": "<p>En esta unidad nos concentraremos en control de flujo usando funciones:\n<em>recursividad</em> y <em>asincronía</em>.</p>\n<h2>¿Por qué aprender esto?</h2>\n<p>La recursión es un concepto fundamental en programación, que nos puede llevar a\nsoluciones elegantes y eficientes a problemas algorítmicos. De hecho, la\nrecursión es tan poderosa, que toda lógica iterativa puede ser expresada usando\nfunciones recursivas. A la hora de iterar estructuras de datos anidadas, la\nrecursión se convierte en una herramienta indispensable.</p>\n<p>Como desarrolladora de JavaScript, dominar la recursividad es fundamental para\nresolver ciertos problemas así como para visualizar el comportamiento de las\nfunciones. Para ser una buena programadora debes interiorizar la recursión como\nsegunda naturaleza.</p>\n<p>En la programación funcional, que es de estilo declarativo, intentamos evitar\nsentencias imperativas como bucles, usando recursividad como alternativa.</p>\n<p>Por otro lado, en JavaScript a menudo necesitamos lidiar con el comportamiento\nasincrónico, que puede ser confuso para los programadores que sólo tienen\nexperiencia con código síncrono. A continuación se explicará qué es código\nasíncrono, algunas de las dificultades de usar código asíncrono, y maneras de\nmanejar estas dificultades.</p>\n<h2>Guía de preguntas y conceptos clave</h2>\n<ul>\n<li>Toda iteración puede reemplazarse con recursión y viceversa</li>\n<li>La recursividad nos permite explorar estructuras con un nivel indeterminado de\nanidación.</li>\n<li>¿Cómo identificamos el caso base en una función recursiva?</li>\n<li>¿Cómo identificamos el caso recursivo en una función recursiva? ¿hay más de un\ncaso recursivo?</li>\n<li>¿He incluido alguna otra condición de terminación necesaria?</li>\n<li>¿Las declaraciones de la función conducen al caso base?</li>\n<li>¿Se construye la recursión en el caso base hasta que el resultado deseado es\ndevuelto por la función?</li>\n<li>El call stack o pila de llamadas aumenta con cada invocación a una función</li>\n<li>El call stack limita la profundidad de anidación en funciones recursivas.</li>\n<li>Cómo podemos evitar \"reventar\" el call stack?</li>\n<li>Usando funciones asícronas podemos ejecutar tareas que dependen de servicios\nexternos (por ejemplo AJAX) sin bloquear la ejecución del programa.</li>\n<li>Gracias a la asincronía podemos diseñar procesos que ejecuten tareas en\nparalelo, en series o una combinación de ambos.</li>\n</ul>"
            }
          }
        },
        {
          "prefix": "01",
          "slug": "recursion",
          "type": "read",
          "duration": 45,
          "intl": {
            "es": {
              "title": "Recursividad en JavaScript",
              "body": "<p>La recursividad es uno de los conceptos de programación más simples pero a su\nvez uno de los más difíciles de dominar. La definición teórica para recursividad\nes: \"la capacidad de una función de invocarse a sí misma\". Ten en cuenta que la\nrecursión no es un concepto exclusivo de JavaScript, lo podemos encontrar en\ncasi todos los lenguajes de programación.</p>\n<p>A lo largo de esta lección veremos que la recursión es importante para la\nprogramación funcional por las siguientes razones:</p>\n<ul>\n<li>Las soluciones recursivas involucran el uso de abstracciones simples aplicadas\na subconjuntos de un problema común.</li>\n<li>La recursión puede ocultar la mutación del estado. Recuerda que hablamos sobre\nla mutación de estado en las lecciones de Funciones puras e Inmutabilidad.</li>\n<li>La recursión es una manera de implementar <em>lazyness</em> y estructuras muy largas\no infinitas.</li>\n</ul>\n<h2>Factorial</h2>\n<p>Este es el ejemplo clásico para entender la recursividad: <strong>factoriales.</strong></p>\n<p>El factorial de un número entero <code>n</code> es igual al producto de todos los números\nenteros positivos desde <code>1</code> hasta <code>n</code>. Así que el factorial de 5 es igual a\n<code>5 * 4 * 3 * 2 * 1</code>, lo que nos da como resultado 120.</p>\n<pre><code class=\"language-text\">5! = 5 * 4 * 3 * 2 * 1 = 120\n</code></pre>\n<p>En la programación, los factoriales son un ejemplo perfecto de un caso en el que\nse debe utilizar una función recursiva. ¿Por qué? Porque estamos haciendo lo\nmismo (multiplicación) una y otra vez a un valor particular (un entero positivo)\nhasta que obtenemos el resultado deseado.</p>\n<p>En principo desarrollemos, como ya hemos viniendo haciendo, el caso de prueba:</p>\n<p><strong>factorial.test.js.</strong></p>\n<pre><code class=\"language-js\">const factorial = require('./factorial')\n\ntest('Should calculate the factorial of the given number', () => {\n  expect(factorial(5)).toBe(120)\n})\n</code></pre>\n<p>Una primera implementación que cumple caso de pruebas especificado es la\nsiguiente:</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"language-js\">const factorial = n => {\n  if (n === 0) {\n    return 1\n  }\n\n  // ¡Aquí está la recursión!\n  return n * factorial(n - 1)\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Demostremos que nuestra implementación cumple con el caso de prueba:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- factorial.test.js\n\nPASS  ./factorial.test.js\n\n  ✓ Should calculate the factorial of the given number (3ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.638s, estimated 1s\nRan all test suites matching \"factorial.test.js\".\nDone in 1.12s.\n</code></pre>\n<h2>Caso base, caso recursivo</h2>\n<p>Hay características claves de la recursión que deben incluirse en tu código para\nque funcione correctamente.</p>\n<p>El primer caso a estudiar es el <strong>caso base</strong>: es sólo una línea de código o\nsentencia, normalmente dentro de una cláusula condicional como <code>if</code> que detiene\nla recursión. Si no se tiene un caso base, la recursión continuará infinitamente\ny tu programa se bloqueará (lo cual no es bueno).</p>\n<p>El segundo es el <strong>caso recursivo</strong>: ésta es el lugar donde realmente sucede la\nrecursión: es donde la función recursiva se llama a sí misma.</p>\n<p>Vamos a explorar ambos casos con más detalle. Mira bien el código del ejemplo a\ncontinuación:</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"language-js\">const factorial = n => {\n  // Este es nuestro caso base - cuando n es igual a 0, se detiene la recursión\n  // Devolvemos 1 pues es el elemento neutro de la multiplicación\n  if (n === 0) {\n    return 1\n  }\n\n  // Este es nuestro caso recursivo\n  // Correrá para todas las condiciones de n excepto cuando n es igual a 0\n  return n * factorial(n - 1)\n}\n\nmodule.exports = factorial\n</code></pre>\n<h2>Condición de terminación</h2>\n<p>Otra característica útil (y a menudo necesaria) de una función recursiva es la\n<strong>condición de terminación</strong>.</p>\n<p>Esta es una declaración específica que detendrá explícitamente la recursión. El\ncaso base es una forma de condición de terminación, aunque para nuestros fines\nusaremos la condición de terminación para describir una sentencia que cancelará\nla recursión en el caso de una entrada incorrecta u otro error potencial.</p>\n<p>Para poner esto en práctica, mira la función factorial. ¿Qué pasaría si la\nllamáramos usando un entero negativo? Dado que la recursión sólo se detendrá\ncuando n es igual a 0, y eso nunca sucedería con un entero negativo, nuestro\nprograma se bloquearía.</p>\n<p>Agreguemos un caso de prueba para demostrar lo indicado en el párrafo anterior:</p>\n<p><strong>factorial.test.js.</strong></p>\n<pre><code class=\"language-js\">const factorial = require('./factorial.verbose')\n\ntest('Should calculate the factorial of the given number', () => {\n  expect(factorial(5)).toBe(120)\n})\n\ntest('Should not accept negative values', () => {\n  expect(() => {\n    factorial(-1)\n  }).toThrow('Cannot compute the factorial of a negative integer')\n})\n</code></pre>\n<p>Si ejecutamos nuestras pruebas obtendremos lo siguiente:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- factorial.test.js\n\nFAIL  ./factorial.test.js\n\n  ● Should not accept negative values\n\n    RangeError: Maximum call stack size exceeded\n\n      at factorial (factorial.js:1:108)\n      at factorial (factorial.js:9:14)\n      ...\n      at factorial (factorial.js:9:14)\n\n\n  ✓ Should calculate the factorial of the given number (3ms)\n  ✕ Should not accept negative values (3ms)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 1 passed, 2 total\nSnapshots:   0 total\nTime:        0.685s, estimated 1s\nRan all test suites matching \"factorial.test.js\".\n</code></pre>\n<p><strong>¡Ouch!</strong>, nuestro programa está fallando.</p>\n<p>Para evitar que esto suceda, utilizaremos una condición de terminación para\nasegurarnos de que el valor pasado a la función sea válido y no bloquee nuestro\nprograma. Como programadora, debes estar constantemente pensando en cómo estar\npreparada para cualquier tipo de situación y asegurarte de que tu código puede\nmanejarla correctamente.</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"language-js\">const factorial = n => {\n  if (n &#x3C; 0) {\n    // Condición de terminación para prevenir recursividad infinita\n    throw new Error('Cannot compute the factorial of a negative integer')\n  }\n\n  // Caso base\n  if (n === 0) {\n    return 1\n  }\n\n  // Caso recursivo\n  return n * factorial(n - 1)\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Ejecutemos ahora nuestras pruebas:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- factorial.test.js\n\n PASS  ./factorial.test.js\n\n  ✓ Should calculate the factorial of the given number (3ms)\n  ✓ Should not accept negative values\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        0.674s, estimated 1s\nRan all test suites matching \"factorial.test.js\".\nDone in 1.29s.\n</code></pre>\n<p>Todo parece indicar que la condición de terminación nos ha servido para\nsolventar el error antes presentado.</p>\n<h2>Argumentos en la recursión</h2>\n<p>Cuando empieces a construir tu caso recursivo (el código que se repetirá), una\nde las reglas es asegurarse de que los argumentos que usamos para la recursión\nnos lleven a un caso base.</p>\n<p>Si el valor que le pasamos a la llamada de la función recursiva es el mismo que\nel valor inicial, es probable que nuestro código entre en un bucle infinito, e\ninevitablemente se bloqueará.</p>\n<p>Por lo tanto, la pregunta que debes hacerte es: ¿el caso recursivo modifica los\nargumentos de tal manera que cada recursión lo acerca más al caso base?</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"language-js\">const factorial = n => {\n  // Condición de terminación para prevenir la recursión infinita\n  if (n &#x3C; 0) {\n    throw new Error('Cannot compute the factorial of a negative integer')\n  }\n\n  // Caso base\n  if (n === 0) {\n    return 1\n  }\n\n  return n * factorial(n)\n}\n\nfactorial(6)\n</code></pre>\n<p>¿Qué está mal? ¿Por qué no funciona la recursión?</p>\n<h2>Ahora es tu turno</h2>\n<p>A la hora de plantear una función recursiva, hay cinco preguntas que puedes\nutilizar como guía:</p>\n<ul>\n<li>¿Cuáles son los casos básicos?</li>\n<li>¿Cuál es el caso recursivo?, ¿hay más de un caso recursivo?</li>\n<li>¿He incluido alguna otra condición de terminación necesaria?</li>\n<li>¿Las declaraciones de la función conducen al caso base?</li>\n<li>¿Se construye la recursión en el caso base hasta que el resultado deseado es\ndevuelto por la función?</li>\n</ul>\n<h2>Pila de llamadas (Call Stack)</h2>\n<p>Imagina por un momento que una compañera mientras hacia revisión de la función\n<code>factorial()</code> encontró un comportamiento extraño, su caso de prueba fue el\nsiguiente:</p>\n<pre><code class=\"language-sh\">> factorial(32768)\nRangeError: Maximum call stack size exceeded\n</code></pre>\n<p>Por si no lo recuerdas, este error ya lo habíamos visto antes, cuando intentamos\ncalcular el <code>factorial(-1)</code> y no teníamos la <strong>condición de terminación</strong>\napropiada.</p>\n<p>Ahora bien, para poder resolver este problema, primero debemos dejar claro un\nconcepto que no habíamos explicado anteriormente, definamos entonces qué es la\npila de llamadas o <em>Call Stack</em>.</p>\n<p>Sería útil examinar más de cerca la forma en que se maneja el control a través\nde las funciones. Aquí está un programa simple que hace algunas llamadas a\nfunciones:</p>\n<p><strong>greet.</strong></p>\n<pre><code class=\"language-js\">function greet(who) {\n  console.log(\"Hello \" + who)\n}\ngreet(\"Harry\")\nconsole.log(\"Bye\")\n</code></pre>\n<ul>\n<li>La llamada a <code>greet</code> hace que el control salte al inicio de esa función (línea\n2).</li>\n<li>Se hace una llamada a <code>console.log</code> (una función predeterminada del\nnavegador), esta función toma el control, hace su trabajo, devuelve el control\na la línea 2.</li>\n<li>Entonces llega al final de la función <code>greet</code>, así que el control se vuelve al\nlugar de la llamada, en la línea 4.</li>\n<li>La línea siguiente llama a <code>console.log</code> de nuevo (línea 5).</li>\n</ul>\n<p>Veamos otra representación de lo mencionado previamente, mostraremos un esquema\nde cómo fluye el control en la función:</p>\n<pre><code class=\"language-text\">top\n    greet\n        console.log\n    greet\ntop\n    console.log\ntop\n</code></pre>\n<p>Como la función debe saltar de nuevo al lugar de la llamada original cuando\nllega al final de la función, la computadora debe recordar el contexto o entorno\ndesde el cual se hizo la llamada a la función. Por ejemplo, en un caso,\n<code>console.log</code> tiene que volver a saltar a la función <code>greet</code>. En otro caso, debe\nsaltar al final del programa.</p>\n<p>El lugar donde la computadora almacena este contexto es la pila de llamadas o\n<em>call stack</em>. Cada vez que se hace una llamada a una función, el contexto actual\nse pone encima de esta pila de llamadas. Cuando la función se devuelve, elimina\nel contexto superior de la pila y lo utiliza para continuar con la ejecución de\nla función.</p>\n<p>El almacenamiento de esta pila requiere espacio en la memoria de la computadora.\nCuando la pila crece demasiado, la computadora fallará y mostrará un mensaje\ncomo \"No hay espacio en la pila\" o \"Hay demasiada recursión\". El código\nsiguiente ilustra esto haciendo una pregunta realmente difícil a la computadora,\nesto causa llamadas infinitas hacia adelante y hacia atrás entre dos funciones.\nComo la computadora no tiene una pila infinita, se queda sin espacio, y sucede\nque \"explotamos la pila\".</p>\n<pre><code class=\"language-js\">function chicken() {\n  return egg()\n}\nfunction egg() {\n  return chicken()\n}\nconsole.log(chicken() + \" came first.\")\n// → ??\n</code></pre>\n<p>Esto es precisamente lo que está pasando con nuestra función <code>factorial</code>, a\npartir de ciertos enteros positivos nuestra pila de llamadas crece demasido y\nobtenemos el error: <em>Maximum call stack size exceeded</em>. Veamos entonces si\npodemos solventar dicho error.</p>\n<hr>\n<h2>Lecturas complementarias</h2>\n<h3>Tail-call Optimization</h3>\n<p>La optimización de llamadas de cola o <em>tail-call optimization</em> es una\ncaracterística del compilador que reemplaza las invocaciones de funciones\nrecursivas con una estructura de control o bucle. La eliminación de las\ninvocaciones de funciones elimina tanto el tamaño de la pila como el tiempo\nnecesario para configurar los marcos de la pila de funciones. Tanto el tiempo\ncomo el espacio se guardan.</p>\n<p>Una programadora debe escribir funciones de una manera que facilite la\n<em>optimización de llamadas de cola</em>. Esto significa que la última función\ninvocada debe ser la función recursiva. Si revisamos con detenimiento nuestra\nfunción <code>factorial</code> podremos apreciar que nuestra llamada recursiva es como\nsigue:</p>\n<pre><code class=\"language-js\">return n * factorial(n - 1)\n</code></pre>\n<p>Cabe preguntarnos si <strong>la última función invocada debe ser la función\nrecursiva</strong>, en nuestra implementación actual en realidad es la multiplicación\nlo último que se invoca. Sin embargo, podemos mejorar la implementación tal\ncomo sigue:</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"language-js\">'use strict'\nconst factorial = (n, acc = 1) => {\n  if (n &#x3C; 0) {\n    // Condición de terminación para prevenir recursividad infinita\n    throw new Error('Cannot compute the factorial of a negative integer')\n  }\n\n  // Caso base\n  if (n === 0) {\n    return acc\n  }\n\n  // Caso recursivo\n  return factorial(n - 1, n * acc)\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Esta implementación del <code>factorial</code> ahora si hace <em>tail-call recursion</em> y por\nende está optimizada, nota que la última función llamada es <code>factorial</code> y no la\nmultiplicación (caso previo). De este modo, el compilador es capaz de invocar\n<code>factorial</code> en un bucle hasta que se devuelva un resultado distinto a este en la\nrepetición.</p>\n<p>Nota que hemos agregado un parámetro adicional a <code>factorial</code> este parametro es\n<code>acc</code>. Este es el acumulador, <code>acc</code> es el valor acumulado hasta este punto.\nHagamos una simulación escrita del método recurrente para ver cómo se acumula el\nresultado factorial:</p>\n<pre><code class=\"language-text\">factorial(5)\nfactorial(5, 1)\nfactorial(4, 5)\nfactorial(3, 20)\nfactorial(2, 60)\nfactorial(1, 120)\nfactorial(0, 120)\n120\n</code></pre>\n<p>Todas las funciones recursivas deben tener un caso base que termine la\nrecursión. Anteriormente el caso base para la función <code>factorial</code> era cuando\n<code>n = 0</code>, en cuyo caso se devuelve <code>1</code>. Con esta nueva implementación, el caso\nbase de <code>factorial</code> sigue siendo cuando <code>n = 0</code>, pero en lugar de retornar <code>1</code>,\nse devuelve el valor acumulado (<code>acc</code>).</p>\n<h4>Tarea</h4>\n<p>Nuestra nueva implementación de <code>factorial</code> igualmente tiene un problema, si\nbien hacemos uso de una característica de ES2015, la cual es la definición de\nparamétros por omisión de una función, un usuario podría invocar nuestra nueva\nfunción <code>factorial</code> de la siguiente manera: <code>factorial(5, 2)</code>, ¿qué crees que\npasaría en dicho caso?, trata de hacer una simulación escrita antes de ejecutar\ncódigo, ¿el resultado es correcto?</p>\n<p>Un modo de corregir la nueva implementación es siguiendo la siguientes consejos:</p>\n<h4>Estrategia para la optimización de llamadas de cola</h4>\n<p>Utiliza esta estrategia para crear funciones recursivas optimizadas:</p>\n<ul>\n<li>Crear una función recursiva interna que tenga un parámetro acumulador\nadicional</li>\n<li>El caso base de la función recursiva interna será devolver el acumulador</li>\n<li>La invocación recursiva proporciona un valor actualizado para el acumulador</li>\n<li>La función externa delega a la función recursiva interna usando los valores\niniciales apropiados</li>\n</ul>\n<p>Sigue estas estrategias y tus funciones recursivas serán óptimas, proporcionando\nmejoras significativas en el rendimiento.</p>\n<blockquote>\n<p><strong>Nota</strong></p>\n<p>Si tú código fuese a producción con esta implementación, se utilizarían otras\ntécnicas como\n<a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\">IIFEs</a>\nentre otras para encapsular y prevenir la creación de un nuevo <em>closure</em> cada\nvez que llamamos a <code>factorial</code>.</p>\n</blockquote>\n<p>Si probamos la función <code>factorial</code> haciendo uso de <em>tail-call optimization</em> con\nnúmeros enteros positivos pequeños observamos que todo funciona de igual manera,\npero, en esta ocasión debemos actualizar nuestro caso de pruebas para incluir el\nejemplo que nos dio nuestra amiga:</p>\n<p><strong>factorial.test.js.</strong></p>\n<pre><code class=\"language-js\">const factorial = require('./factorial.tail')\n\ntest('Should calculate the factorial of the given number', () => {\n  expect(factorial(5)).toBe(120)\n})\n\ntest('Should not accept negative values', () => {\n  expect(() => {\n    factorial(-1)\n  }).toThrow('Cannot compute the factorial of a negative integer')\n})\n\ntest('Should avoid too much recursion', () => {\n  expect(() => {\n    factorial(32768)\n  }).not.toThrowError(/stack size exceeded/)\n})\n</code></pre>\n<p>Si ejecutamos nuestras pruebas obtendremos un resultado similar al siguiente:</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- factorial.test.js\n\n FAIL  ./factorial.tail.test.js\n  ● Should avoid too much recursion\n\n    expect(function).not.toThrowError(regexp)\n\n    Expected the function not to throw an error matching:\n      /stack size exceeded/\n    Instead, it threw:\n      RangeError: Maximum call stack size exceeded\n\n  ✓ Should calculate the factorial of the given number (5ms)\n  ✓ Should not accept negative values (1ms)\n  ✕ Should avoid too much recursion (10ms)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 2 passed, 3 total\nSnapshots:   0 total\nTime:        0.656s, estimated 1s\nRan all test suites matching \"factorial.test.js\".\n</code></pre>\n<p><strong>(o_O)</strong> ¡Un momento!, ¿qué ha pasado?, ¿por qué sigue fallando?.</p>\n<p>Pues resulta que es importante mencionar que esto funcionará si tu sistema\nproporciona optimizaciones de llamadas de cola. Ya que JavaScript no lo hace en\nla mayoría de sus implementaciones, tal como se indica\n<a href=\"https://babeljs.io/learn-es2015/#ecmascript-2015-features-tail-calls\">acá</a></p>\n<blockquote>\n<p><strong>Nota</strong></p>\n<p>Al momento de la publicación de esta lectura, la única implementación de\nJavaScript conocida por el autor que soporta tail-call optimization es\n<a href=\"https://github.com/Kinoma/kinomajs\">KinomaJS</a>, la cual ofrece un <em>runtime</em>\noptimizado para el desarrollo de aplicaciones que funcionen en dispositivos IoT\ny ofrecen compatibilidad con ES6, de hecho,\n<a href=\"http://kinoma.com/develop/documentation/js6/\">acá</a> puedes ver los resultados\nde sus pruebas.</p>\n<p>Si bien no es necesario para los objetivos de este curso, puedes intentar\ndescargar el código de KinomaJS pues es <em>Open Source</em>, construirla y correr la\n<em>suite</em> de pruebas que ofrecen y corroborar por tu cuenta.</p>\n</blockquote>\n<p>Ahora que sabemos que la mayoría de las implementaciones de JavaScript no\nimplementan todavía la <em>tail-call optimization</em> es necesario ver si existen\notras alternativas con las cuales podamos solventar el error antes visto.</p>\n<h3>Trampolining</h3>\n<p>¿Cómo podemos optimizar las funciones de JavaScript recursivas sin la\noptimización de llamadas de cola? Una opción es volver a escribir tu función\nrecursiva en forma de bucle.</p>\n<p>Función factorial escrita usando estructura de datos de control:</p>\n<pre><code class=\"language-js\">const factorial = n => {\n  let acc = 1\n  for (let i = n; i > 0; i--) {\n    acc *= i\n  }\n  return acc\n}\n</code></pre>\n<p>Así se implementa la optimización de llamadas de cola manualmente. La desventaja\nes la pérdida de elegancia y la expresividad de la implementación recursiva.</p>\n<p>Otra opción es usar un trampolín.</p>\n<p>Las trampolines son ubicaciones de memoria que mantienen direcciones apuntando a\nrutinas de servicio de interrupción, como por ejemplo rutinas de E/S. Al correr\nel código la ejecución salta al trampolín y luego salta inmediatamente hacia\nafuera, o rebota, de ahí el término trampolín.</p>\n<p>Un solo trampolín es suficiente para expresar todas las transferencias de\ncontrol de un programa; Un programa expresado de esta manera podemos decir que\nestá escrito al estilo trampolín. Las funciones de trampolín se pueden utilizar\npara implementar llamadas de función recursivas de cola en lenguajes de\nprogramación orientados al uso de pilas.</p>\n<p>Pero es más fácil de lo que parece en la teoría, como veremos a continuación.</p>\n<h4>Un simple trampolín</h4>\n<p>Veamos una implementación simple de trampolín:</p>\n<pre><code class=\"language-js\">const trampoline = f => {\n  while (f &#x26;&#x26; f instanceof Function) {\n    f = f.apply(f.context, f.args)\n  }\n  return f\n}\n</code></pre>\n<p>El trampolín toma una función y ejecuta repetidamente el valor de retorno hasta\nque se devuelve un resultado distinto al de una función. Uno se siente tentado a\nusar el trampolín de la siguiente manera:</p>\n<pre><code class=\"language-js\">const factorial = (n) => {\n  const recur = (n, acc) => n ? recur(n - 1, n * acc) : acc\n  return trampoline(recur(n, 1));\n}\n</code></pre>\n<p>Pero esto no produce la optimización deseada. ¿Por qué? Supongamos que se invoca\nla función factorial con <code>n = 5</code>. ¿Qué valor se le pasa al trampolín?</p>\n<pre><code class=\"language-js\">recur(5, 1)\n</code></pre>\n<p>Es una expresión de función que devuelve el valor 120. El trampolín se invoca\ncon el valor 120. Esto es esencialmente la misma aplicación de la llamada de\ncola optimizada del factorial, excepto que la optimización de la llamada de la\ncola no está disponible en el entorno de JavaScript. ¿Qué salió mal?</p>\n<p>Teníamos la intención de invocar un trampolín con una función de referencia, no\ncon un resultado de la función. Mientras que lo siguiente funciona</p>\n<pre><code class=\"language-js\">return trampoline(function() { recur(n, 1) })\n</code></pre>\n<p>Es difícil de manejar. Necesitamos un medio para obtener una referencia a la\ninvocación de la función, completa con todos los parámetros, por lo que podemos\ninvocar la función en un momento posterior. Aunque no estaba destinado para este\npropósito, la función <em>Function.bind</em> se ajusta bien a nuestra intención, y por\nlo tanto, mejora nuestra implementación de Factorial:</p>\n<p>Mejor pero no del todo óptima</p>\n<pre><code class=\"language-js\">const factorial = n => {\n  const recur = (n, acc) => n ? recur(n - 1, n * acc) : acc\n\n  return trampoline(recur.bind(null, n, 1))\n}\n</code></pre>\n<p>Ahora invocamos el trampolín con la expresión:</p>\n<pre><code class=\"language-js\">recur.bind(null, n, 1))\n</code></pre>\n<p>La función <em>bind</em> es una función que cuando se invoca devuelve el valor de la\nfunción que está haciendo la llamada, en este caso <em>recur</em>, utilizando el\ncontexto de llamada especificado (el puntero <em>this</em>, que en este caso es nulo,\nya que no llamamos a nuestra función dentro de una instancia del objeto), Y la\nlista de parámetros. El resultado de <em>recur (n, 1)</em> se devuelve cuando se invoca\nla función <em>bind</em>. ¡Esto es exactamente lo que pretendíamos pasar al trampolín,\nuna función!</p>\n<p>Sin embargo, esta implementación aún no está optimizada. Para ver esto\nsupongamos que invocamos <em>factorial</em> con el valor n = 5. Cuando el trampolín\ninvoca la función <em>bind</em> devolviendo la invocación de <em>recur(5, 1)</em> ¿qué\nresultado se devuelve? No es una función, sino que es el resultado de la\nrecurrencia (4, 5), que es 120. Sólo tenemos un rebote.</p>\n<p>Esto se arregla fácilmente:</p>\n<p>Implementación optimizada de factorial:</p>\n<pre><code class=\"language-js\">const factorial = n => {\n  const recur = (n, acc) => n ? recur.bind(null, n - 1, n * acc) : acc\n\n  return trampoline(recur.bind(null, n, 1));\n}\n</code></pre>\n<p>Ahora el trampolín proporcionará el efecto deseado y continuará haciendo un\nbucle hasta que vuelva a devolver el valor acumulado.</p>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"language-js\">'use strict'\n\nconst isFunction = require('lodash.isfunction')\n\nconst trampoline = (fn, ...args) => {\n  let result = fn.apply(fn, args)\n\n  while (isFunction(result)) {\n    result = result()\n  }\n\n  return result\n}\n\nconst factorial = n => {\n  if (n &#x3C; 0) {\n    throw new Error('Cannot compute the factorial of a negative integer')\n  }\n\n  const fun = (n, acc = 1) => {\n    return n ? () => fun(n - 1, n * acc) : acc\n  }\n\n  return trampoline(fun(n))\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Tras este ultimo cambio ejecutemos nuestras pruebas.</p>\n<pre><code class=\"language-sh\">$ yarn run jest -- factorial.test.js\n\n PASS  ./factorial.safe.test.js\n  ✓ Should calculate the factorial of the given number (3ms)\n  ✓ Should not accept negative values (1ms)\n  ✓ Should avoid too much recursion (7ms)\n\nTest Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        0.648s, estimated 1s\nRan all test suites matching \"factorial.test.js\".\nDone in 1.15s.\n</code></pre>\n<p>Con esto ya hemos evitado saturar el <em>stack</em>. Sin embargo, el resultado es el\nsiguiente:</p>\n<pre><code class=\"language-sh\">> factorial(32768)\nInfinity\n</code></pre>\n<blockquote>\n<p><strong>(o_O) Advertencia</strong></p>\n<p>Este error se debe a otra limitación en JavaScript, esta vez relacionada con el\nmanejo de enteros largos. Si bien la reparación de este último <em>bug</em> está fuera\ndel alcance de la lección actual, igual se mostrará su resolución para\ncompletar el recorrido.</p>\n<p>Esta limitación puede ser arreglada haciendo uso de\n<a href=\"https://github.com/peterolson/BigInteger.js\">BigInteger.js</a>. Ejecutemos\nentonces</p>\n<pre><code class=\"language-sh\">yarn add --dev big-integer\n</code></pre>\n<p>y ajustemos de nuevo nuestra implementación.</p>\n</blockquote>\n<p><strong>factorial.js.</strong></p>\n<pre><code class=\"language-js\">'use strict'\n\nconst isFunction = require('lodash.isfunction')\nconst bigInt = require('big-integer')\n\nconst trampoline = (fn, ...args) => {\n  let result = fn.apply(fn, args)\n\n  while (isFunction(result)) {\n    result = result()\n  }\n\n  return result\n}\n\nconst factorial = n => {\n  if (n &#x3C; 0) {\n    throw new Error('Cannot compute the factorial of a negative integer')\n  }\n\n  const fun = (n, acc = bigInt.one) => {\n    return n.greater(0) ? () => fun(n.minus(1), acc.multiply(n)) : acc\n  }\n\n  return trampoline(fun(bigInt(n)))\n}\n\nmodule.exports = factorial\n</code></pre>\n<p>Ahora podremos obtener una representación que nos funciona para números grandes:</p>\n<pre><code class=\"language-sh\">> factorial(5)\n{ [Number: 120] value: 120, sign: false, isSmall: true }\n> factorial(5) == 120\ntrue\n> factorial(180)\n{ [Number: Infinity]\n  value:\n    [ 0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      9603200,\n      3198603,\n      3278187,\n      2302693,\n      9233864,\n      7538181,\n      4141796,\n      3001782,\n      1142564,\n      4664891,\n      6331964,\n      5603584,\n      809209,\n      5744504,\n      8568581,\n      5064353,\n      1980647,\n      6535588,\n      972945,\n      3196673,\n      6095985,\n      1495273,\n      3218633,\n      6710321,\n      7399609,\n      9410103,\n      7356315,\n      2097309,\n      8013811,\n      9809411,\n      953395,\n      6004486,\n      4353351,\n      7777940,\n      4079886,\n      9175403,\n      8466838,\n      5133689,\n      2996569,\n      2499134,\n      89606,\n      2 ],\n  sign: false,\n  isSmall: false }\n</code></pre>\n<p>Y dichos números grandes (<code>isSmall: false</code>) los podemos transformar a cadenas de\ncaracteres de la siguiente manera:</p>\n<pre><code class=\"language-sh\">> fact(180).toString()\n'200896062499134299656951336898466838917540340798867777940435335160044860953395980941180138112097309735631594101037399609671032132186331495273609598531966730972945653558819806475064353856858157445040809209560358463319644664891114256430017824141796753818192338642302693327818731986039603200000000000000000000000000000000000000000000'\n</code></pre>\n<h2>Otros ejercicios que puedes hacer</h2>\n<ul>\n<li>Implementa la función <code>myLength</code>, la cual toma un <em>array</em> como entrada y\nretorna la longitud de dicho <em>array</em> o número de elementos. Ejemplo:\n<code>myLength([1, 2, 3]) = 3</code></li>\n<li>Crea una función <code>cycle</code> que toma un número entero positivo y un <em>array</em> como\nargumentos y crea un nuevo <em>array</em> que contendrá los elementos del <em>array</em> de\nentrada multiplicados tantas veces como indica el número entero positivo\npasado como primer argumento. Ejemplo: <code>cycle(2, [1, 2, 3]) = [1, 2, 3, 1, 2, 3]</code></li>\n</ul>\n<h2>Referencias</h2>\n<ul>\n<li><a href=\"https://www.codecademy.com/en/courses/javascript-lesson-205\">Recursion in JavaScript</a>\npor Code Academy</li>\n<li><a href=\"http://eloquentjavascript.net/03_functions.html#h_D2Yui+mx6D\">The Call Stack</a>\nde Marijn Haverbeke</li>\n<li><a href=\"http://shop.oreilly.com/product/0636920028857.do\">Functional Javascript</a> de\nMichael Fogus</li>\n<li><a href=\"https://taylodl.wordpress.com/2013/06/07/functional-javascript-tail-call-optimization-and-trampolines/\">Functional JavaScript – Tail Call Optimization and Trampolines</a></li>\n<li><a href=\"http://raganwald.com/2013/03/28/trampolines-in-javascript.html\">Trampolines in JavaScript</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "02",
          "slug": "practice",
          "type": "practice",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Ejercicios de recursividad",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "apply-discount",
              "prefix": "01",
              "path": "topics/functional/05-flow-control/02-practice/01-apply-discount",
              "createdAt": "2024-06-21T17:34:26.947Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "Reemplaza iteración con recursión",
                  "body": "<h2>Tarea</h2>\n<p>Refactoriza la función <code>applyDiscount()</code> reemplazando iteración con recursión y\nasegúrate de que no tenga efectos secundarios.</p>\n<pre><code class=\"language-js\">// Broken: mutates array as well as objects!!\nconst applyDiscount = (cart, discount) => {\n  for (let i = 0; i &#x3C; cart.length; i++) {\n    cart[i].price *= (1 - discount);\n  }\n  return cart;\n};\n\nmodule.exports = applyDiscount;\n</code></pre>\n<h2>Ejemplo</h2>\n<p>Ejemplo de uso de la función:</p>\n<pre><code class=\"language-js\">const myCart = [\n  { price: 1 },\n  { price: 2 },\n  { price: 3 }\n];\n\nconst cartWithDiscount = applyDiscount(myCart, .3);\nconsole.log(myCart, cartWithDiscount);\n// => [ { price: 0.7 }, { price: 1.4 }, { price: 2.0999999999999996 } ]\n</code></pre>"
                }
              },
              "files": {
                "/boilerplate/applyDiscount.js": "// Broken: mutates array as well as objects!!\nconst applyDiscount = (cart, discount) => {\n  for (let i = 0; i < cart.length; i++) {\n    cart[i].price *= (1 - discount);\n  }\n  return cart;\n};\n\nmodule.exports = applyDiscount;\n",
                "/solution/applyDiscount.js": "// const applyDiscount = (cart, discount) => {\n//   if (!cart.length) {\n//     return [];\n//   }\n//   return [{...cart[0], price: cart[0].price * (1 - discount) }]\n//     .concat(applyDiscount(cart.slice(1), discount));\n// };\n\nconst applyDiscount = (cart, discount) => (!cart.length) ?\n  [] :\n  [{...cart[0], price: cart[0].price * (1 - discount) }]\n    .concat(applyDiscount(cart.slice(1), discount));\n\nmodule.exports = applyDiscount;\n",
                "/test/applyDiscount.spec.js": "const Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/applyDiscount');\n\n\ndescribe('applyDiscount()', () => {\n\n  it('debería de retornar una array nuevo en vez de mutar el array de entrada', () => {\n    const cart = [{ price: 1 }, { price: 2 }, { price: 3 }];\n    Assert.notEqual(Submission(cart, .2), cart);\n  });\n\n  it('debería aplicar descuento esperado', () => {\n    const cart = [{ price: 1 }, { price: 2 }, { price: 3 }];\n    Assert.deepEqual(\n      Submission(cart, .2),\n      [{ price: 0.8 }, { price: 1.6 }, { price: 2.4000000000000004 }]\n    );\n  });\n\n  it('debería usar recursión', () => {\n    const fnBody = Function.prototype.toString.call(Submission);\n    // strip comments from source code\n    const strippedFnBody = fnBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n    Assert.equal(/(applyDiscount|module\\.exports)\\(/.test(strippedFnBody), true);\n  });\n\n  it('no debería usar for o while', () => {\n    const fnBody = Function.prototype.toString.call(Submission);\n    // strip comments from source code\n    const strippedFnBody = fnBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n    Assert.equal(/(for|while)\\s*\\(/g.test(strippedFnBody), false);\n  });\n\n  it('no debería usar Array#map, Array#forEach o Array#reduce', () => {\n    const cart = [{ price: 1 }, { price: 2 }, { price: 3 }];\n    const mapSpy = Sinon.spy(Array.prototype, 'map');\n    const forEachSpy = Sinon.spy(Array.prototype, 'forEach');\n    const reduceSpy = Sinon.spy(Array.prototype, 'reduce');\n    const result = Submission(cart, .2);\n    Assert.equal(result.length, 3);\n    Assert.equal(result[0].price, 0.8);\n    Assert.equal(result[1].price, 1.6);\n    Assert.equal(result[2].price, 2.4000000000000004);\n    Assert.equal(mapSpy.callCount, 0);\n    Assert.equal(forEachSpy.callCount, 0);\n    Assert.equal(reduceSpy.callCount, 0);\n    mapSpy.restore();\n    forEachSpy.restore();\n    reduceSpy.restore();\n  });\n\n});\n"
              }
            },
            {
              "slug": "reduce",
              "prefix": "02",
              "path": "topics/functional/05-flow-control/02-practice/02-reduce",
              "createdAt": "2024-06-21T17:34:26.947Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "reduce",
                  "body": "<p>Una función recursiva es una función que se llama a sí misma. Por ejemplo, esta\nfunción recursiva recibe un Array de palabras, y retorna un arreglo con las\nmismas palabras, pero todas en mayúsculas.</p>\n<pre><code class=\"language-js\">function toUpperArray(items) {\n  if (!items.length) {                      // caso base\n    return [];\n  }\n\n  let head = items[0];                      // elemento sobre el que operar\n  head = head.toUpperCase();                // llevamos a cabo operación\n  const tail = items.slice(1);                // siguiente\n  return [head].concat(toUpperArray(tail)); // recursión\n}\n\ntoUpperArray(['hello', 'world']); // => ['HELLO', 'WORLD']\n</code></pre>\n<p>El objetivo de este ejercicio es que te familiarices con la recursión a través\nde la implementación de una interfaz conocida usando una función recursiva.</p>\n<h2>Tarea</h2>\n<p>Implementa <code>Array#reduce</code> usando recursión.</p>\n<p>Tu función <code>reduce</code> recibirá un arreglo de palabras, una función, y un valor\ninicial al que iremos sumando la cuenta de apariciones de cada palabra.</p>\n<p>Por simplicidad, tu implementación de <code>reduce</code> <strong>no necesita imitar el\ncomportamiento de un reduce sin valor inicial</strong>. Puedes asumir que el valor\nsiempre se incluye en la invocación.</p>\n<h2>Argumentos</h2>\n<ul>\n<li><code>arr</code>: El Array que queremos reducir</li>\n<li><code>fn</code>: Function para usar en cada paso de la reducción. Igual que\n<code>Array#reduce</code>, esta función debe recibir <code>previousValue</code>, <code>currentValue</code>,\n<code>index</code> y el <code>array</code> sobre el que estamos iterando.</li>\n<li><code>init</code>: Valor inicial de la reducción. A diferencia de <code>Array#reduce</code>, este\nvalor es obligatorio (puedes asumir que siempre se incluye).</li>\n</ul>\n<h2>Ejemplo</h2>\n<pre><code class=\"language-js\">// Tu función `reduce` debe comportarse como `Array.reduce`, pero recibirá el\n// arreglo sobre el que operar como primer argumento:\n\nreduce([1,2,3], function(prev, curr, index, arr) {\n  return prev + curr\n}, 0)\n// => 6\n</code></pre>\n<h2>Requisitos</h2>\n<ul>\n<li>No uses bucles <code>for/while</code> ni <code>Array#forEach</code>.</li>\n<li>No uses métodos de <code>Array</code> como <code>Array#map</code> o <code>Array.reduce</code>.</li>\n</ul>\n<h2>Recursos</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Recursion\">Wikipedia - Recursion</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\">MDN - Array.reduce</a></li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/reduce.js": "function reduce(arr, fn, initial) {\n  // TU SOLUCIÓN AQUÍ\n}\n\nmodule.exports = reduce;\n",
                "/solution/reduce.js": "function reduce(arr, fn, initial) {\n  return (function reduceOne(index, value) {\n    if (index > arr.length - 1) { // end condition\n      return value;\n    }\n    return reduceOne(index + 1, fn(value, arr[index], index, arr)); // calculate & pass values to next step\n  })(0, initial); // IIFE. kick off recursion with initial values\n}\n\nmodule.exports = reduce;\n",
                "/test/reduce.spec.js": "const Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/reduce');\n\n\ndescribe('reduce()', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('debería comportarse como reduce con array de números y valor inicial numérico', () => {\n    Assert.equal(Submission([1, 2, 3], (prev, curr, index, arr) => {\n      return prev + curr;\n    }, 0), 6);\n  });\n\n  it('debería comportarse como reduce con array de strings y valor inicial objeto', () => {\n    Assert.deepEqual(Submission(['foo', 'bar', 'foo', 'baz', 'foo'], (memo, curr) => {\n      memo[curr] = (memo[curr]) ? memo[curr] + 1 : 1;\n      return memo;\n    }, {}), { foo: 3, bar: 1, baz: 1 });\n  });\n\n  // it('debería usar recursión', () => {\n  //   const fnBody = Function.prototype.toString.call(Submission);\n  //   // strip comments from source code\n  //   const strippedFnBody = fnBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n  //   console.log(strippedFnBody);\n  //   Assert.equal(/(reduce|module\\.exports)\\(/.test(strippedFnBody), true);\n  // });\n\n  it('no debería usar for, while no Array#forEach', () => {\n    const fnBody = Function.prototype.toString.call(Submission);\n    // strip comments from source code\n    const strippedFnBody = fnBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n    Assert.equal(/(for|while)\\s*\\(/g.test(strippedFnBody), false);\n    Assert.equal(/\\.forEach\\(/g.test(strippedFnBody), false);\n  });\n\n  it('no debería usar Array#map o Array#reduce', () => {\n    const cart = [{ price: 1 }, { price: 2 }, { price: 3 }];\n    const mapSpy = Sinon.spy(Array.prototype, 'map');\n    // const forEachSpy = Sinon.spy(Array.prototype, 'forEach');\n    const reduceSpy = Sinon.spy(Array.prototype, 'reduce');\n    Assert.equal(Submission([1, 2, 3], (prev, curr, index, arr) => {\n      return prev + curr;\n    }, 0), 6);\n    Assert.equal(mapSpy.callCount, 0);\n    // Assert.equal(forEachSpy.callCount, 0);\n    Assert.equal(reduceSpy.callCount, 0);\n    mapSpy.restore();\n    // forEachSpy.restore();\n    reduceSpy.restore();\n  });\n\n});\n"
              }
            },
            {
              "slug": "get-dependencies",
              "prefix": "03",
              "path": "topics/functional/05-flow-control/02-practice/03-get-dependencies",
              "createdAt": "2024-06-21T17:34:26.947Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "getDependencies",
                  "body": "<h2>Tarea</h2>\n<p>Implementar una función recursiva que devuelva todas las dependencias únicas y\nsubdependencias de un módulo ordenadas alfabéticamente. Las dependencias deben\nimprimirse como dependencia@versión, por ejemplo: <code>inflection@1.2.6</code>.</p>\n<p>Se permiten múltiples versiones del mismo módulo, pero los módulos duplicados de\nla misma versión deben eliminarse</p>\n<h2>Argumentos</h2>\n<ul>\n<li>tree: un árbol de dependencias. Vea a continuación un ejemplo de la estructura.</li>\n</ul>\n<h2>Ejemplo</h2>\n<pre><code class=\"language-js\">const loremIpsum = {\n  \"name\": \"lorem-ipsum\",\n  \"version\": \"0.1.1\",\n  \"dependencies\": {\n    \"optimist\": {\n      \"version\": \"0.3.7\",\n      \"dependencies\": {\n        \"wordwrap\": {\n          \"version\": \"0.0.2\"\n        }\n      }\n    },\n    \"inflection\": {\n      \"version\": \"1.2.6\"\n    }\n  }\n};\n\ngetDependencies(loremIpsum);\n// => ['inflection@1.2.6', 'optimist@0.3.7', 'wordwrap@0.0.2']\n</code></pre>\n<h2>Condiciones</h2>\n<ul>\n<li>No usar bucles for o while</li>\n<li>Usa <code>Object.keys()</code> para obtener un array con las propiedades enumerables de\nun objeto</li>\n</ul>\n<h2>Recursos</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\">Object.keys</a></li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/getDependencies.js": "function getDependencies(tree) {\n  // LA SOLUCIóN VA AQUí\n  // Nota: sea libre de agregar argumentos adicionales\n  // a esta función para usarla con llamadas recursivas.\n  // o no! Hay muchas maneras de hacer funcionar la recursividad.\n}\n\nmodule.exports = getDependencies;\n",
                "/solution/getDependencies.js": "function getDependencies(mod, result) {\n  result = result || [];\n  const dependencies = mod && mod.dependencies || [];\n  Object.keys(dependencies).forEach(dep => {\n    const key = dep + '@' + mod.dependencies[dep].version;\n    if (result.indexOf(key) === -1) result.push(key);\n    getDependencies(mod.dependencies[dep], result);\n  });\n  return result.sort();\n}\n\nmodule.exports = getDependencies;\n",
                "/test/getDependencies.spec.js": "const Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/getDependencies');\n\n\ndescribe('getDependencies()', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('no debería usar for o while', () => {\n    const fnBody = Function.prototype.toString.call(Submission);\n    // strip comments from source code\n    const strippedFnBody = fnBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n    Assert.equal(/(for|while)\\s*\\(/g.test(strippedFnBody), false);\n  });\n\n  it('debería usar Object.keys() en cada invación', () => {\n    const spy = Sinon.spy(Object, 'keys');\n    Submission({\n      \"name\": \"lorem-ipsum\",\n      \"version\": \"0.1.1\",\n      \"dependencies\": {\n        \"optimist\": {\n          \"version\": \"0.3.7\",\n          \"dependencies\": {\n            \"wordwrap\": {\n              \"version\": \"0.0.2\"\n            }\n          }\n        },\n        \"inflection\": {\n          \"version\": \"1.2.6\"\n        }\n      }\n    });\n    Assert.equal(spy.callCount, 4);\n    spy.restore();\n  });\n\n  it('debería retornar un array con las dependencias en formato dependencia@versión', () => {\n    const loremIpsum = {\n      \"name\": \"lorem-ipsum\",\n      \"version\": \"0.1.1\",\n      \"dependencies\": {\n        \"optimist\": {\n          \"version\": \"0.3.7\",\n          \"dependencies\": {\n            \"wordwrap\": {\n              \"version\": \"0.0.2\"\n            }\n          }\n        },\n        \"inflection\": {\n          \"version\": \"1.2.6\"\n        }\n      }\n    };\n    Assert.deepEqual(\n      Submission(loremIpsum),\n      ['inflection@1.2.6', 'optimist@0.3.7', 'wordwrap@0.0.2']\n    );\n  });\n\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "03",
          "slug": "async",
          "type": "read",
          "duration": 30,
          "intl": {
            "es": {
              "title": "Asincronía en JavaScript",
              "body": "<h2>¿Cuál es la diferencia entre código síncrono y asíncrono?</h2>\n<h2>Código síncrono</h2>\n<p>En los programas síncronos, si tienes dos líneas de código (L1 seguida de L2),\nentonces L2 no puede comenzar a ejecutarse hasta que L1 haya terminado de\nejecutarse.</p>\n<p>Puedes imaginar que estuvieses en una fila de gente que espera para comprar\nboletos de tren. No puedes comenzar a comprar un boleto de tren hasta que todas\nlas personas delante de tí hayan terminado de comprar sus boletos. Del mismo\nmodo, la gente detrás de tí no puede comenzar a comprar sus boletos hasta que\nhayas comprado el tuyo.</p>\n<h2>Código asíncrono</h2>\n<p>En los programas asíncronos, se pueden tener dos líneas de código (L1 seguido\npor L2), donde L1 programa alguna tarea que se ejecutará en el futuro, pero L2\nse ejecuta antes de que se complete esa tarea programada por L1.</p>\n<p>Imagina que estás sentada comiendo en un restaurante. Otras personas ordenan su\ncomida. Tú También puedes pedir tu comida. No tienes que esperar a que las\notras personas reciban su comida y terminen de comer antes de que tomen tu\norden. Del mismo modo, otras personas no tienen que esperar para obtener su\ncomida y terminar de comer antes de que puedas ordenar tu comida. Todo el mundo\nobtendrá su comida en cuanto esté lista.</p>\n<p>La secuencia en la que las personas reciben su pedido a menudo se correlaciona\ncon la secuencia en la que hicieron su orden, pero estas secuencias no siempre\ntienen que ser idénticas. Por ejemplo, si tu pides un bistec, y luego yo pido un\nvaso de agua, probablemente recibiré mi pedido primero, ya que normalmente no\ntoma tanto tiempo servir un vaso de agua en comparación con preparar y servir un\nfilete.</p>\n<p>Ten en cuenta que asíncrono no significa lo mismo que concurrente o multihilo.\nJavaScript puede tener código asíncrono, pero generalmente es de subproceso\núnico. Esto es como si un restaurante con un solo trabajador hiciera todas las\ntareas. Si este trabajador hace sus oficios lo suficientemente rápido y cambia\nentre las tareas de forma eficiente, entonces el restaurante aparentemente\ntendría múltiples trabajadores.</p>\n<h2>Ejemplos</h2>\n<p>La función <code>setTimeout</code> es probablemente la manera más sencilla de programar de\nforma asíncrona el código para que se ejecute en el futuro:</p>\n<pre><code class=\"language-js\">// Diga \"Hola.\"\nconsole.log(\"Hola.\")\n// Diga \"Adiós\" en dos segundos contando desde este momento.\nsetTimeout(() => {\n  console.log(\"¡Adiós!\")\n}, 2000)\n // Decir  \"Hola de nuevo\"\nconsole.log(\"¡Hola de nuevo!\")\n</code></pre>\n<p>Si sólo está familiarizado con el código síncrono, puede esperar que el código\nanterior se comporte de la siguiente manera:</p>\n<pre><code class=\"language-text\">Diga “Hola\".\nNo haga nada durante dos segundos.\nDiga ¡Adiós!\"\nDiga \"¡Hola de nuevo!\"\n</code></pre>\n<p>Pero <code>setTimeout</code> no interrumpe la ejecución del código. Sólo programa algo para\nque suceda en el futuro, y luego sigue inmediatamente a la siguiente línea. Así\nque el resultado del código anterior sería:</p>\n<pre><code class=\"language-js\">'Hola'\n'¡Hola de nuevo!'\n'¡Adiós!' // 2 segundos después\n</code></pre>\n<h2>Obtener datos de solicitudes AJAX</h2>\n<p>La confusión entre el comportamiento del código síncrono y el código asíncrono\nes un problema común para los personas que están aprendiendo a programar y que\nestán lidiando con el tema de las solicitudes AJAX en JavaScript. A menudo\nescriben código jQuery que se parece a algo como esto:</p>\n<pre><code class=\"language-js\">const getData = () => {\n  let data\n  $.get(\"/api/example\", response => {\n    data = response\n  })\n\n  return data\n}\nconst data = getData()\nconsole.log(`La data es: ${data}`)\n</code></pre>\n<p>Este código no se comporta como tú esperarías desde el punto de vista síncrono.\nAl igual que <code>setTimeout</code> en el ejemplo anterior, <code>$.get</code> no pausa la ejecución\ndel código, sólo programa algún código para ejecutarse una vez que el servidor\nretorna una respuesta. Eso significa que la linea <code>return data</code> se ejecutará\nantes que <code>data = response</code>, por lo que el código anterior siempre imprimirá\n<code>La data es: _undefined_</code>.</p>\n<p>El código asíncrono necesita ser estructurado de una manera diferente que el\ncódigo síncrono, y la forma más básica de hacerlo es con las funciones de\ndevolución de llamada, más comunmente conocidas como <em>callbacks</em> (en inglés).</p>\n<h2><em>Callbacks</em></h2>\n<p>Supongamos que llamas a una amiga y le pides alguna información, por ejemplo,\nla dirección postal de un amigo mutuo que has perdido. Tu amiga no tiene esta\ninformación memorizada, por lo que tiene que buscarla en su libreta de\ndirecciones. Esto podría llevarle unos minutos. Existen diferentes estrategias\npara proceder:</p>\n<ul>\n<li><em>Síncrono:</em> Tú permaneces en la línea telefónica con ella y esperas mientras\nella mira su libreta.</li>\n<li><em>Asíncrono:</em> Le dices a tu amiga que te devuelva la llamada una vez que tenga\nla información. Mientras tanto, tu puedes concentrar toda tu atención en\notras tareas que necesitas hacer, como por ejemplo diseñar un algoritmo.</li>\n</ul>\n<p>En JavaScript, podemos crear funciones asíncronas que reciben otras funciones\ncomo argumentos, que se llamarán una vez que la tarea se haya completado.\nSiguiendo nuestro ejemplo, podemos pasarle una funcion <em>callback</em> a <code>getData</code>:</p>\n<pre><code class=\"language-js\">getData(data => {\n  console.log(`The data is: ${data}`)\n})\n</code></pre>\n<p>Por supuesto, ¿cómo sabe <code>getData</code> que estamos pasando una función? ¿Cómo se\nllama y cómo se carga el parámetro <code>data</code>? En este momento, nada de esto está\nsucediendo. Tenemos que cambiar la función <code>getData</code> para que acepte un callback\ncomo argumento.</p>\n<pre><code class=\"language-js\">const getData = callback => {\n  $.get(\"/api/example\", response => {\n    callback(response)\n  })\n}\n</code></pre>\n<p>Notarás que ya estábamos pasando una función de respuesta de llamada o\n<em>callback</em> a <code>$.get</code>, tal vez sin darnos cuenta de lo que era. También pasamos\nuna respuesta de llamada a la función <code>setTimeout(callback, delay)</code> en el\nprimer ejemplo.</p>\n<p>Dado que <code>$.get</code> ya acepta una respuesta de llamada, no necesitamos crear\nmanualmente otro en <code>getData</code>, podemos pasar directamente la respuesta de\nllamada que nos dieron:</p>\n<pre><code class=\"language-js\">const getData = callback => {\n $.get(\"/api/example\", callback)\n}\n</code></pre>\n<p>Las funciones de respuesta de llamada se usan con mucha frecuencia en\n<em>JavaScript</em> y, si has pasado algún tiempo escribiendo código en <em>JavaScript</em>,\nes muy probable que las hayas utilizado. Toda aplicación web hará uso de\nrespuestas de llamada a través de eventos (por ejemplo, <code>window.onclick</code>,\n<code>setTimeout</code> y <code>setInterval</code>, o solicitudes AJAX).</p>\n<h2>Problemas comunes del código asíncrono</h2>\n<h3>Puede resultar confuso al principio</h3>\n<p>Algunas personas deciden que tratar con código asíncrono es demasiado\ncomplicado para trabajar, por lo que intentan hacer que todo sea sincrónico.\nPor ejemplo, en lugar de usar <code>setTimeout</code>, podría crear una función síncrona\npara no hacer nada durante un período de tiempo determinado:</p>\n<pre><code class=\"language-js\">const pause = duration => {\n  const start = new Date().getTime()\n  while (new Date().getTime() - start &#x3C; duration) {}\n}\n</code></pre>\n<p>Del mismo modo, al realizar una llamada <em>AJAX</em>, es posible establecer una opción\npara que la llamada sea síncrona en lugar de asíncrona (aunque esta opción\npierde lentamente el soporte del navegador). También hay alternativas síncronas\na muchas funciones asíncronas en Node.js.</p>\n<p>Tratar de evitar código asíncrono y reemplazarlo con código síncrono es casi\nsiempre una mala idea porque <em>JavaScript</em> sólo tiene un solo hilo (excepto\ncuando se utilizan <em>Web Workers</em>). Esto significa que la página web no responderá\nmientras se ejecuta el <em>script</em>. Si utilizas la función sincrónica <code>pause</code> o una\nllamada <em>AJAX</em> síncrona, el usuario no podrá hacer nada mientras estén en\nejecución.</p>\n<p>El problema es aún peor cuando se utiliza <em>JavaScript</em> en el servidor: el\nservidor no podrá responder a ninguna solicitud mientras espera que se\ncompleten las funciones síncronas, lo que significa que cada usuario que haga\nuna solicitud al servidor tendrá que esperar para obtener una respuesta.</p>\n<h3>Problemas de alcance con <em>callbacks</em> dentro de lazos</h3>\n<p>Cuando se crea una devolución de llamada o <em>callback</em> dentro de un bucle <code>for</code>,\npuedes encontrarte con algún comportamiento inesperado. Piensa en lo que\nesperarías que el código escrito a continuación hiciera, y luego intenta\nejecutarlo en la consola <em>JavaScript</em> de tu navegador.</p>\n<pre><code class=\"language-js\">for (var i = 1; i &#x3C;= 3; i++) {\n  setTimeout(() => {\n    console.log(i + \" second(s) elapsed\")\n  }, i * 1000)\n}\n</code></pre>\n<p>Es probable que el código anterior está diseñado con la intención de mostrar los\nmensajes siguientes, con un segundo de retardo entre cada mensaje:</p>\n<pre><code class=\"language-console\">1 second(s) elapsed.\n2 second(s) elapsed.\n3 second(s) elapsed.\n</code></pre>\n<p>Pero el resultado que realmente muestra es el siguiente:</p>\n<pre><code class=\"language-console\">4 second(s) elapsed.\n4 second(s) elapsed.\n4 second(s) elapsed.\n</code></pre>\n<p>El problema es que <code>console.log (i + \"second (s) elapsed\")</code> está en la\ndevolución de llamada de una función asíncrona. En el momento en que se\nejecuta, el bucle <code>for</code> se habrá terminado y la variable <code>i</code> será igual a 4.</p>\n<p>Hay varias soluciones a este problema, pero la más común es envolver la llamada\na <code>setTimeout</code> en un <em>closure</em>, lo que creará un nuevo ámbito con una <code>i</code>\ndiferente en cada iteración:</p>\n<pre><code class=\"language-js\">for (var i = 1; i &#x3C;= 3; i++) {\n  ((i) => {\n    setTimeout(() => {\n      console.log(`${i} second(s) elapsed`);\n    }, i * 1000);\n  })(i);\n}\n</code></pre>\n<p>Pero como estamos utilizando ECMAScript 2015, entonces una solución\nmás elegante es usar <code>let</code> en lugar de <code>var</code>, ya que permite crear un nuevo\námbito para <code>i</code> en cada iteración:</p>\n<pre><code class=\"language-js\">for (let i = 1; i &#x3C;= 3; i++) {\n  setTimeout(() => {\n    console.log(`${i} second(s) elapsed`);\n  }, i * 1000);\n}\n</code></pre>\n<h3>Infierno de <em>callback</em></h3>\n<p>A veces se tiene una serie de tareas en las que cada paso depende de los\nresultados del paso anterior. Esto es muy sencillo de tratar usando código\nsíncrono:</p>\n<pre><code class=\"language-js\">const text = readFile(fileName)\nconst tokens = tokenize(text)\nconst parseTree = parse(tokens)\nconst optimizedTree = optimize(parseTree)\nconst output = evaluate(optimizedTree)\n\nconsole.log(output);\n</code></pre>\n<p>Cuando intentas hacer eso usando código asíncrono, es fácil caer en el llamado\ninfierno de <em>callback</em>, que es un problema común en el que se termina con\nfunciones <em>callback</em> profundamente anidadas unas dentro de otras. Son\nparticularmente susceptibles a este fenómeno el código Node.js y las\naplicaciones de <em>front-end</em> con un montón de llamadas AJAX. Podrían terminar\nviéndose así:</p>\n<pre><code class=\"language-js\">readFile(fileName, text => {\n  tokenize(text, tokens => {\n    parse(tokens, parseTree => {\n      optimize(parseTree, optimizedTree => {\n        evaluate(optimizedTree, output => {\n          console.log(output)\n        })\n      })\n    })\n  })\n})\n</code></pre>\n<p>Este tipo de código es difícil de leer y puede ser un verdadero dolor de cabeza\ncada vez que se necesite hacer cambios. Si tiene devoluciones de llamada\nprofundamente anidadas como esta, normalmente es una buena idea organizar el\ncódigo de forma diferente. Existen varias estrategias diferentes para\nrefactorizar devoluciones de llamada profundamente anidadas.</p>\n<h4>Divide el código en distintas funciones con nombres apropiados</h4>\n<p>Le puedes dar nombres a las funciones de devolución de llamada para que puedas\nhacer referencia a ellas por nombre. Esto ayuda a que el código sea más\nsuperficial, y también divide el código de manera natural en pequeñas secciones\nlógicas.</p>\n<pre><code class=\"language-js\">const readFinish = text => {\n  tokenize(text, tokenizeFinish)\n}\nconst tokenizeFinish = tokens => {\n  parse(tokens, parseFinish)\n}\nconst parseFinish = parseTree => {\n  optimize(parseTree, optimizeFinish)\n}\nconst optimizeFinish = optimizedTree => {\n  evalutate(optimizedTree, evaluateFinish)\n}\nconst evaluateFinish = output => {\n  console.log(output)\n}\nreadFile(fileName, readFinish)\n</code></pre>\n<h4>Crear una función para ejecutar una serie de tareas</h4>\n<p>Esta solución no es tan flexible como la anterior, pero si se tiene una\nsecuencia de tareas compuesta de funciones asíncronas, se puede crear una\nfunción de utilidad que tome una matriz de tareas y las ejecute una tras otra.</p>\n<pre><code class=\"language-js\">const performTasks = (input, tasks) => {\n  if (tasks.length === 1) {\n    return tasks[0](input)\n  }\n\n  tasks[0](input, output => {\n    // Ejecuta las tareas en el arreglo 'tasks[]'\n    performTasks(output, tasks.slice(1))\n  })\n}\n\nperformTasks(fileName,\n  [readFile, token, parse, optimize, evaluate, output => {\n  console.log(output)\n}])\n</code></pre>\n<h2>Herramientas para el manejo de código asíncrono</h2>\n<h3>Librerías Async</h3>\n<p>Si estás utilizando un montón de funciones asíncronas, puede valer la pena\nutilizar una librería o biblioteca de funciones asíncronas, en lugar de tener\nque crear tus propias funciones de utilidad.\n<a href=\"https://github.com/caolan/async\">Async.js</a> es una biblioteca popular\nque tiene muchas herramientas útiles para tratar el código asíncrono.</p>\n<h3>Promises</h3>\n<p>Las promesas o <em>promises</em> son una forma popular de deshacerse del infierno de\n<em>callback</em>. Originalmente se trataba de un tipo de constructo introducido por\nlibrerías <em>JavaScript</em> como <code>Q</code> y <code>when.js</code>, pero estos tipos de librerías\nse volvieron lo suficientemente populares como para que <em>promises</em> se\nproporcionan de forma nativa en ECMAScript 2015.</p>\n<p>La idea es que en lugar de usar funciones que acepten una entrada y un\n<em>callback</em>, hacemos una función que devuelve un objeto <em>promise</em>, es decir, un\nobjeto que representa un valor que está destinado a existir en el futuro.</p>\n<p>Por ejemplo, supongamos que comenzamos con una función <code>getData</code> que hace una\nsolicitud AJAX y usa un <em>callback</em> de la manera habitual:</p>\n<pre><code class=\"language-js\">const getData = (options, callback) => {\n  $.get(\"/api/example\", options, response => {\n    callback(null, JSON.parse(response))\n  }, () => {\n    callback(new Error(\"AJAX request failed!\"))\n  })\n}\n// uso\ngetData({name: \"John\"}, (err, data) => {\n  if (err) {\n    console.log(`Error! ${err}`)\n  } else {\n    console.log(data)\n  }\n})\n</code></pre>\n<p>Podemos cambiar la función <code>getData</code> para que devuelva un <em>promise</em>. Podemos\ncrear un objeto <em>promise</em> con la nueva funcion <code>Promise(callback)</code>, donde\ncallback es una función con dos argumentos: <code>resolve</code> y <code>reject</code>. Llamaremos a\n<code>resolve</code> si conseguimos obtener los datos. Si algo sale mal, llamaremos a\n<code>reject</code>.</p>\n<p>Una vez que tenemos una función que devuelve un objeto <em>promise</em>, podemos usar\nel método <code>.then</code> en este objeto para especificar lo que debe suceder una vez\nque se llama a <code>resolve</code> o <code>reject</code>.</p>\n<pre><code class=\"language-js\">const getData = options =>\n  new Promise((resolve, reject) => { // crear un nuevo objeto promise\n    $.get('/api/example', options, response => {\n      resolve(JSON.parse(response)) // en caso que todo salga como planeamos\n    }, () => {\n      reject(new Error('AJAX request failed!')) // en caso que algo salga mal\n    })\n  })\n\n// uso\ngetData({name: 'John'}).then(data => {\n  console.log(data)\n}, err => {\n  console.log('Error! ' + err)\n}\n</code></pre>\n<p>El manejo de errores parece mejor, pero es difícil ver cómo estamos haciendo\nlas cosas de manera mas conveniente dado el tamaño de la función. La ventaja es\nmás clara cuando reescribimos nuestro ejemplo de infierno <em>callback</em> usando\n<em>promises</em>:</p>\n<pre><code class=\"language-js\">readFile('fileName')\n  .then(text => tokenize(text))\n  .then(tokens => parse(tokens))\n  .then(parseTree => optimize(parseTree))\n  .then(optimizedTree => evaluate(optimizedTree))\n  .then(output => console.log(output))\n  .catch(err => console.error(err))\n</code></pre>\n<h2>Conclusión</h2>\n<p>A este punto, ya deberías estar familiarizada con las estrategias para hacer\nfrente a algunas de las dificultades que surgen cuando se utiliza código\nasíncrono.</p>\n<h2>Referencias</h2>\n<ul>\n<li><a href=\"https://www.pluralsight.com/guides/introduction-to-asynchronous-javascript\">Introduction to asynchronous JavaScript</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval\">WindowOrWorkerGlobalScope.setInterval()</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\">WindowOrWorkerGlobalScope.setTimeout()</a></li>\n<li><a href=\"http://caolan.github.io/async/\">Async</a></li>\n<li><a href=\"https://github.com/kriskowal/q\">Q</a></li>\n<li><a href=\"https://github.com/cujojs/when\">when.js</a></li>\n</ul>"
            }
          }
        },
        {
          "prefix": "04",
          "slug": "practice-2",
          "type": "practice",
          "duration": 10,
          "intl": {
            "es": {
              "title": "Ejercicios de asincronía",
              "body": ""
            }
          },
          "challenges": [
            {
              "slug": "load-users",
              "prefix": "01",
              "path": "topics/functional/05-flow-control/04-practice-2/01-load-users",
              "createdAt": "2024-06-21T17:34:26.947Z",
              "track": "web-dev",
              "tracks": [
                "web-dev"
              ],
              "env": "cjs",
              "intl": {
                "es": {
                  "title": "loadUsers",
                  "body": "<p>¡Este código está dañado!</p>\n<p>Un desarrollador que trabaja en Java ha hecho <em>commit</em> de este terrible código a\nnuestro repositorio y, ¡no lo probó!</p>\n<pre><code class=\"language-js\">function loadUsers(userIds, load, done) {\n  var users = []\n  for (var i = 0; i &#x3C; userIds.length; i++) {\n    users.push(load(userIds[i]))\n  }\n  return users\n}\n\nmodule.exports = loadUsers\n</code></pre>\n<h2>Tarea</h2>\n<p>¡Arregla este código! La función <em>callback</em> debería ser llamada con todos los\nusuarios ya cargados. El orden de los usuarios debería coincidir con el orden de\nlos ID de usuarios suministrados. Porque esta función es asíncrona, no nos\nimporta el valor que retorna.</p>\n<h2>Argumentos</h2>\n<ul>\n<li><code>userIds</code>: un arreglo numérico de ID de usuarios.</li>\n<li><code>load</code>: una función usada para cargar los objetos usuario. La función espera un\nID numérico y una llamada <em>callback</em>. La llamada <em>callback</em> se invoca con el\nresultado de cargar los usuarios con el ID especificado (un objeto ID de\nusuario o devuelve una respuesta nula <em>null</em>).</li>\n<li><code>done</code>: una función que espera un arreglo con objetos usuario (como fue\nrecuperado desde <code>load</code>).</li>\n</ul>\n<h2>Condiciones</h2>\n<ul>\n<li>No usar lazos for/while  (usar <em>Array#forEach</em> está bien).</li>\n<li>El orden de los resultados en <code>done</code> debe ser los mismos que fueron\nespecificados en <code>userIds</code>.</li>\n<li>Los usuarios deben ser cargados en paralelo, por ejemplo el tiempo  total de\nla tarea no debe tomar más de un segundo.</li>\n<li>No crear ninguna función innecesaria como por ejemplo <em>helpers</em>.</li>\n</ul>\n<h2>Pistas</h2>\n<ul>\n<li>No se necesita usar <em>sort</em> para mantener el orden.</li>\n</ul>"
                }
              },
              "files": {
                "/boilerplate/loadUsers.js": "const loadUsers = (userIds, load, done) => {\n  var users = [];\n  for (var i = 0; i < userIds.length; i++) {\n    users.push(load(userIds[i]));\n  }\n  return users;\n}\n\nmodule.exports = loadUsers;\n",
                "/solution/loadUsers.js": "const loadUsers = (userIds, load, done) => {\n  let completed = 0;\n  const users = [];\n  userIds.forEach((id, index) => {\n    load(id, user => {\n      users[index] = user;\n      if (++completed === userIds.length) {\n        return done(users);\n      }\n    });\n  });\n};\n\nmodule.exports = loadUsers;\n",
                "/test/loadUsers.spec.js": "const Assert = require('chai').assert;\nconst Sinon = require('sinon');\nconst Submission = require('../solution/loadUsers');\n\n\ndescribe('loadUsers()', () => {\n\n  it('debería exportar una función', () => {\n    Assert.equal(typeof Submission, 'function');\n  });\n\n  it('no debería usar for o while', () => {\n    const fnBody = Function.prototype.toString.call(Submission);\n    // strip comments from source code\n    const strippedFnBody = fnBody.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n    Assert.equal(/(for|while)\\s*\\(/g.test(strippedFnBody), false);\n  });\n\n  it('debería mantener el orden de userIds en los resultados', (done) => {\n    let count = 0;\n    const load = (id, cb) =>\n      setTimeout(() => cb && cb({ id: id, name: 'Lorem ipsum' }), 100 / ++count);\n\n    Submission([1, 2, 3], load, (users) => {\n      Assert.deepEqual(users, [\n        { id: 1, name: 'Lorem ipsum' },\n        { id: 2, name: 'Lorem ipsum' },\n        { id: 3, name: 'Lorem ipsum' }\n      ]);\n      done();\n    });\n  });\n\n  it('debería cargar los usuarios en paralelo', (done) => {\n    const load = (id, cb) =>\n      setTimeout(() => cb && cb({ id: id, name: 'Lorem ipsum' }), 100);\n\n    const start = Date.now();\n    Submission([3, 2, 1], load, (users) => {\n      Assert.ok((Date.now() - start) < 150);\n      done();\n    });\n  });\n\n  it('debería invocar load para cada id de usario y callback con usuarios', (done) => {\n    const load = (id, cb) =>\n      setTimeout(() => cb && cb({ id: id, name: 'Lorem ipsum' }), 100);\n\n    Submission([1, 2, 3], load, (users) => {\n      Assert.deepEqual(users, [\n        { id: 1, name: 'Lorem ipsum' },\n        { id: 2, name: 'Lorem ipsum' },\n        { id: 3, name: 'Lorem ipsum' }\n      ]);\n      done();\n    });\n  });\n\n});\n"
              }
            }
          ]
        },
        {
          "prefix": "08",
          "slug": "closing",
          "type": "read",
          "duration": 5,
          "intl": {
            "es": {
              "title": "Cierre",
              "body": "<h2>Resumen</h2>\n<p>La recursividad, así como muchos otros conceptos de la programación funcional\npueden ser engañosamente simples. La definición en sí es corta, pero\nacostumbrarse al concepto e interiorizarlo lleva un tiempo.</p>\n<p>En este unidad hemos hablado de recursión y asincronía como formas de contralar\nel flujo de un programa usando funciones. Ambos conceptos son fundamentales\npara cualquier desarrolladora JavaSript.</p>\n<h2>Repasemos juntxs las preguntas y conceptos clave de la apertura</h2>\n<ul>\n<li>Toda iteración puede reemplazarse con recursión y viceversa</li>\n<li>La recursividad nos permite explorar estructuras con un nivel indeterminado de\nanidación.</li>\n<li>¿Cómo identificamos el caso base en una función recursiva?</li>\n<li>¿Cómo identificamos el caso recursivo en una función recursiva? ¿hay más de un\ncaso recursivo?</li>\n<li>¿He incluido alguna otra condición de terminación necesaria?</li>\n<li>¿Las declaraciones de la función conducen al caso base?</li>\n<li>¿Se construye la recursión en el caso base hasta que el resultado deseado es\ndevuelto por la función?</li>\n<li>El call stack o pila de llamadas aumenta con cada invocación a una función</li>\n<li>El call stack limita la profundidad de anidación en funciones recursivas.</li>\n<li>Cómo podemos evitar \"reventar\" el call stack?</li>\n<li>Usando funciones asícronas podemos ejecutar tareas que dependen de servicios\nexternos (por ejemplo AJAX) sin bloquear la ejecución del programa.</li>\n<li>Gracias a la asincronía podemos diseñar procesos que ejecuten tareas en\nparalelo, en series o una combinación de ambos.</li>\n</ul>\n<h2>Auto-evaluación</h2>\n<p>Tus instructorxs te compartirán un link al cuestionario de <em>auto evaliación</em>.\nEste cuestionario no es calificado.</p>"
            }
          }
        }
      ]
    }
  ]
}
